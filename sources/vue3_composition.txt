Vue (pronounced /vjuː/, like view) is a JavaScript framework for building user interfaces. It
builds on top of standard HTML, CSS, and JavaScript and provides a declarative and
component-based programming model that helps you efficiently develop user interfaces, be
they simple or complex.
Here is a minimal example:
ResultIntroduction
You are reading the documentation for Vue 3! ⓘ
Vue 2 support will end on Dec 31, 2023. Learn more about Vue 2 Extended LTS.
Vue 2 documentation has been moved to v2.vuejs.org.
Upgrading from Vue 2? Check out the Migration Guide.
What is Vue?
import { createApp } from 'vue'
createApp({
  data() {
    return {
      count: 0
    }
  }
}).mount('#app')
<div id="app">
  <button @click="count++">
    Count is: {{ count }}
  </button>
</div>templaCount is: 0
The above example demonstrates the two core features of Vue:
You may already have questions - don't worry. We will cover every little detail in the rest of
the documentation. For now, please read along so you can have a high-level understanding
of what Vue offers.
Vue is a framework and ecosystem that covers most of the common features needed in
frontend development. But the web is extremely diverse - the things we build on the web
may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and
incrementally adoptable. Depending on your use case, Vue can be used in different ways:Declarative Rendering: Vue extends standard HTML with a template syntax that allows
us to declaratively describe HTML output based on JavaScript state.
Reactivity: Vue automatically tracks JavaScript state changes and efficiently updates the
DOM when changes happen.
Prerequisites
The rest of the documentation assumes basic familiarity with HTML, CSS, and JavaScript.
If you are totally new to frontend development, it might not be the best idea to jump right
into a framework as your first step - grasp the basics and then come back! You can check
your knowledge level with this JavaScript overview. Prior experience with other
frameworks helps, but is not required.ⓘ
The Progressive Framework
Enhancing static HTML without a build step
Embedding as Web Components on any page
Single-Page Application (SPA)
Fullstack / Server-Side Rendering (SSR)If you find these concepts intimidating, don't worry! The tutorial and guide only require basic
HTML and JavaScript knowledge, and you should be able to follow along without being an
expert in any of these.
If you are an experienced developer interested in how to best integrate Vue into your stack,
or you are curious about what these terms mean, we discuss them in more detail in Ways of
Using Vue.
Despite the flexibility, the core knowledge about how Vue works is shared across all these
use cases. Even if you are just a beginner now, the knowledge gained along the way will stay
useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can
pick the optimal way to leverage Vue based on the problems you are trying to solve, while
retaining the same productivity. This is why we call Vue "The Progressive Framework": it's a
framework that can grow with you and adapt to your needs.
In most build-tool-enabled Vue projects, we author Vue components using an HTML-like file
format called Single-File Component (also known as *.vue files, abbreviated as SFC). A
Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template
(HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:Jamstack / Static Site Generation (SSG)
Targeting desktop, mobile, WebGL, and even the terminal
Single-File ComponentsSFC is a defining feature of Vue and is the recommended way to author Vue components if
your use case warrants a build setup. You can learn more about the how and why of SFC in
its dedicated section - but for now, just know that Vue will handle all the build tools setup for
you.
Vue components can be authored in two different API styles: Options API and Composition
API.
With Options API, we define a component's logic using an object of options such as data,
methods, and mounted. Properties defined by options are exposed on this inside
functions, which points to the component instance:API Styles
Options API<script>
export default {
  data() {
    return {
      count: 0
    }
  }
}
</script>
<template>
  <button @click="count++">Count is: {{ count }}</button>
</template>
<style scoped>
button {
  font-weight: bold;
}
</style>vuTry it in the Playground
With Composition API, we define a component's logic using imported API functions. In SFCs,
Composition API is typically used with <script setup>. The setup attribute is a hint that
makes Vue perform compile-time transforms that allow us to use Composition API with less
boilerplate. For example, imports and top-level variables / functions declared in <script
setup> are directly usable in the template.▶
Composition API<script>
export default {
  // Properties returned from data() become reactive state
  // and will be exposed on `this`.
  data() {
    return {
      count: 0
    }
  },
  // Methods are functions that mutate state and trigger updates.
  // They can be bound as event listeners in templates.
  methods: {
    increment() {
      this.count++
    }
  },
  // Lifecycle hooks are called at different stages
  // of a component's lifecycle.
  // This function will be called when the component is mounted.
  mounted() {
    console.log(`The initial count is ${this.count}.`)
  }
}
</script>
<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>vuHere is the same component, with the exact same template, but using Composition API and
<script setup> instead:
Try it in the Playground
Both API styles are fully capable of covering common use cases. They are different
interfaces powered by the exact same underlying system. In fact, the Options API is
implemented on top of the Composition API! The fundamental concepts and knowledge
about Vue are shared across the two styles.
The Options API is centered around the concept of a "component instance" (this as seen
in the example), which typically aligns better with a class-based mental model for users
coming from OOP language backgrounds. It is also more beginner-friendly by abstracting
away the reactivity details and enforcing code organization via option groups.
The Composition API is centered around declaring reactive state variables directly in a
function scope and composing state from multiple functions together to handle complexity.▶
Which to Choose?<script setup>
import { ref, onMounted } from 'vue'
// reactive state
const count = ref(0)
// functions that mutate state and trigger updates
function increment() {
  count.value++
}
// lifecycle hooks
onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>
<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>vuIt is more free-form and requires an understanding of how reactivity works in Vue to be used
effectively. In return, its flexibility enables more powerful patterns for organizing and reusing
logic.
You can learn more about the comparison between the two styles and the potential benefits
of Composition API in the Composition API FAQ.
If you are new to Vue, here's our general recommendation:
You don't have to commit to only one style during the learning phase. The rest of the
documentation will provide code samples in both styles where applicable, and you can
toggle between them at any time using the API Preference switches at the top of the left
sidebar.
Check out our FAQ.For learning purposes, go with the style that looks easier to understand to you. Again,
most of the core concepts are shared between the two styles. You can always pick up the
other style later.
For production use:
Go with Options API if you are not using build tools, or plan to use Vue primarily in low-
complexity scenarios, e.g. progressive enhancement.
Go with Composition API + Single-File Components if you plan to build full applications
with Vue.
Still Got Questions?
Pick Your Learning PathDifferent developers have different learning styles. Feel free to pick a learning path that suits
your preference - although we do recommend going over all of the content, if possible!
Try the Tutorial
For those who prefer learning things hands-on.
Read the Guide
The guide walks you through every aspect of the framework in full detail.
Check out the Examples
Explore examples of core features and common UI tasks.In this section we will introduce how to scaffold a Vue Single Page Application on your local
machine. The created project will be using a build setup based on Vite and allow us to use
Vue Single-File Components (SFCs).
Make sure you have an up-to-date version of Node.js installed, then run the following
command in your command line (without the > sign):
This command will install and execute create-vue, the official Vue project scaffolding tool.
You will be presented with prompts for several optional features such as TypeScript and
testing support:Quick Start
Try Vue Online
To quickly get a taste of Vue, you can try it directly in our Playground. ▶
If you prefer a plain HTML setup without any build steps, you can use this JSFiddle as
your starting point.
If you are already familiar with Node.js and the concept of build tools, you can also try a
complete build setup right within your browser on StackBlitz.
Creating a Vue Application
Prerequisites ⓘ
Familiarity with the command line
Install Node.js version 16.0 or higher
> npm init vue@latestIf you are unsure about an option, simply choose No by hitting enter for now. Once the
project is created, follow the instructions to install dependencies and start the dev server:
You should now have your first Vue project running! Note that the example components in
the generated project are written using the Composition API and <script setup>, rather
than the Options API. Here are some additional tips:
When you are ready to ship your app to production, run the following:
This will create a production-ready build of your app in the project's ./dist directory.
Check out the Production Deployment Guide to learn more about shipping your app toThe recommended IDE setup is Visual Studio Code + Volar extension. If you use other
editors, check out the IDE support section.
More tooling details, including integration with backend frameworks, are discussed in the
Tooling Guide.
To learn more about the underlying build tool Vite, check out the Vite docs.
If you choose to use TypeScript, check out the TypeScript Usage Guide.✔ Project name: … <your-project-name>
✔ Add TypeScript? … No / Yes
✔ Add JSX Support? … No / Yes
✔ Add Vue Router for Single Page Application development? … No / Yes
✔ Add Pinia for state management? … No / Yes
✔ Add Vitest for Unit testing? … No / Yes
✔ Add Cypress for both Unit and End-to-End testing? … No / Yes
✔ Add ESLint for code quality? … No / Yes
✔ Add Prettier for code formatting? … No / Yes
Scaffolding project in ./<your-project-name>...
Done.
> cd <your-project-name>
> npm install
> npm run dev
> npm run buildproduction.
Next Steps >
You can use Vue directly from a CDN via a script tag:
Here we are using unpkg, but you can also use any CDN that serves npm packages, for
example jsdelivr or cdnjs. Of course, you can also download this file and serve it yourself.
When using Vue from a CDN, there is no "build step" involved. This makes the setup a lot
simpler, and is suitable for enhancing static HTML or integrating with a backend framework.
However, you won't be able to use the Single-File Component (SFC) syntax.
The above link loads the global build of Vue, where all top-level APIs are exposed as
properties on the global Vue object. Here is a full example using the global build:Using Vue from CDN
Using the Global Build<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>htmJSFiddle demo
Throughout the rest of the documentation, we will be primarily using ES modules syntax.
Most modern browsers now support ES modules natively, so we can use Vue from a CDN via
native ES modules like this:
Notice that we are using <script type="module">, and the imported CDN URL is pointing
to the ES modules build of Vue instead.Using the ES Module Build<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<div id="app">{{ message }}</div>
<script>
  const { createApp } = Vue
  createApp({
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }).mount('#app')
</script>
<div id="app">{{ message }}</div>
<script type="module">
  import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
  createApp({
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }).mount('#app')
</script>htm
htmJSFiddle demo
In the above example, we are importing from the full CDN URL, but in the rest of the
documentation you will see code like this:
We can teach the browser where to locate the vue import by using Import Maps:
JSFiddle demo
You can also add entries for other dependencies to the import map - but make sure they
point to the ES modules version of the library you intend to use.Enabling Import maps
import { createApp } from 'vue'
<script type="importmap">
  {
    "imports": {
      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
    }
  }
</script>
<div id="app">{{ message }}</div>
<script type="module">
  import { createApp } from 'vue'
  createApp({
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }).mount('#app')
</script>htmAs we dive deeper into the guide, we may need to split our code into separate JavaScript
files so that they are easier to manage. For example:Import Maps Browser Support
Import maps are supported by default in Chromium-based browsers, so we recommend
using Chrome or Edge during the learning process.
If using Firefox, it is supported by default in version 108+ or by setting the
dom.importMaps.enabled option to true in about:config for versions 102+.
If your preferred browser does not support import maps yet, you can polyfill it with es-
module-shims.ⓘ
Notes on Production Use
The examples so far are using the development build of Vue - if you intend to use Vue
from a CDN in production, make sure to check out the Production Deployment Guide.⚠
Splitting Up the Modules
<!-- index.html -->
<div id="app"></div>
<script type="module">
  import { createApp } from 'vue'
  import MyComponent from './my-component.js'
  createApp(MyComponent).mount('#app')
</script>
// my-component.js
export default {
  data() {
    return { count: 0 }
  },
  template: `<div>count is {{ count }}</div>`
}htmIf you directly open the above index.html in your browser, you will find that it throws an
error because ES modules cannot work over the file:// protocol. In order for this to
work, you need to serve your index.html over the http:// protocol, with a local HTTP
server.
To start a local HTTP server, first install Node.js and then run npx serve from the
command line in the same directory where your HTML file is. You can also use any other
HTTP server that can serve static files with the correct MIME types.
You may have noticed that the imported component's template is inlined as a JavaScript
string. If you are using VSCode, you can install the es6-string-html extension and prefix the
strings with a /*html*/ comment to get syntax highlighting for them.
Many of the examples for Composition API will be using the <script setup> syntax. If you
intend to use Composition API without a build step, consult the usage of the setup()
option.
If you skipped the Introduction, we strongly recommend reading it before moving on to the
rest of the documentation.
Continue with the Guide
The guide walks you through every aspect of the framework in full detail.
Try the TutorialUsing Composition API without a Build Step
Next StepsFor those who prefer learning things hands-on.
Check out the Examples
Explore examples of core features and common UI tasks.Every Vue application starts by creating a new application instance with the createApp
function:
The object we are passing into createApp is in fact a component. Every app requires a
"root component" that can contain other components as its children.
If you are using Single-File Components, we typically import the root component from
another file:
While many examples in this guide only need a single component, most real applications are
organized into a tree of nested, reusable components. For example, a Todo application's
component tree might look like this:Creating a Vue Application
The application instance
The Root Componentimport { createApp } from 'vue'
const app = createApp({
  /* root component options */
})
import { createApp } from 'vue'
// import the root component App from a single-file component.
import App from './App.vue'
const app = createApp(App)In later sections of the guide, we will discuss how to define and compose multiple
components together. Before that, we will focus on what happens inside a single
component.
An application instance won't render anything until its .mount() method is called. It
expects a "container" argument, which can either be an actual DOM element or a selector
string:
The content of the app's root component will be rendered inside the container element. The
container element itself is not considered part of the app.
The .mount() method should always be called after all app configurations and asset
registrations are done. Also note that its return value, unlike the asset registration methods,
is the root component instance instead of the application instance.Mounting the App
In-DOM Root Component TemplateApp (root component)
├─ TodoList
│  └─ TodoItem
│     ├─ TodoDeleteButton
│     └─ TodoEditButton
└─ TodoFooter
   ├─ TodoClearButton
   └─ TodoStatistics
<div id="app"></div>
app.mount('#app')htmWhen using Vue without a build step, we can write our root component's template directly
inside the mount container:
Vue will automatically use the container's innerHTML as the template if the root component
does not already have a template option.
The application instance exposes a .config object that allows us to configure a few app-
level options, for example, defining an app-level error handler that captures errors from all
descendant components:
The application instance also provides a few methods for registering app-scoped assets. For
example, registering a component:App Configurations<div id="app">
  <button @click="count++">{{ count }}</button>
</div>
import { createApp } from 'vue'
const app = createApp({
  data() {
    return {
      count: 0
    }
  }
})
app.mount('#app')
app.config.errorHandler = (err) => {
  /* handle error */
}htmThis makes the TodoDeleteButton available for use anywhere in our app. We will discuss
registration for components and other types of assets in later sections of the guide. You can
also browse the full list of application instance APIs in its API reference.
Make sure to apply all app configurations before mounting the app!
You are not limited to a single application instance on the same page. The createApp API
allows multiple Vue applications to co-exist on the same page, each with its own scope for
configuration and global assets:
If you are using Vue to enhance server-rendered HTML and only need Vue to control specific
parts of a large page, avoid mounting a single Vue application instance on the entire page.
Instead, create multiple small application instances and mount them on the elements they
are responsible for.Multiple application instancesapp.component('TodoDeleteButton', TodoDeleteButton)
const app1 = createApp({
  /* ... */
})
app1.mount('#container-1')
const app2 = createApp({
  /* ... */
})
app2.mount('#container-2')Vue uses an HTML-based template syntax that allows you to declaratively bind the rendered
DOM to the underlying component instance's data. All Vue templates are syntactically valid
HTML that can be parsed by spec-compliant browsers and HTML parsers.
Under the hood, Vue compiles the templates into highly-optimized JavaScript code.
Combined with the reactivity system, Vue can intelligently figure out the minimal number of
components to re-render and apply the minimal amount of DOM manipulations when the
app state changes.
If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you
can also directly write render functions instead of templates, with optional JSX support.
However, do note that they do not enjoy the same level of compile-time optimizations as
templates.
The most basic form of data binding is text interpolation using the "Mustache" syntax
(double curly braces):
The mustache tag will be replaced with the value of the msg property from the
corresponding component instance. It will also be updated whenever the msg property
changes.Template Syntax
Text Interpolation
Raw HTML<span>Message: {{ msg }}</span>templaThe double mustaches interpret the data as plain text, not HTML. In order to output real
HTML, you will need to use the v-html directive:
Using text interpolation: <span style="color: red">This should be red.</span>
Using v-html directive: This should be red.
Here we're encountering something new. The v-html attribute you're seeing is called a
directive. Directives are prefixed with v- to indicate that they are special attributes
provided by Vue, and as you may have guessed, they apply special reactive behavior to the
rendered DOM. Here, we're basically saying "keep this element's inner HTML up-to-date
with the rawHtml property on the current active instance."
The contents of the span will be replaced with the value of the rawHtml property,
interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html to
compose template partials, because Vue is not a string-based templating engine. Instead,
components are preferred as the fundamental unit for UI reuse and composition.
Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive:Security Warning
Dynamically rendering arbitrary HTML on your website can be very dangerous because it
can easily lead to XSS vulnerabilities. Only use v-html on trusted content and never on
user-provided content.⚠
Attribute Bindings<p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
<div v-bind:id="dynamicId"></div>templa
templaThe v-bind directive instructs Vue to keep the element's id attribute in sync with the
component's dynamicId property. If the bound value is null or undefined, then the
attribute will be removed from the rendered element.
Because v-bind is so commonly used, it has a dedicated shorthand syntax:
Attributes that start with : may look a bit different from normal HTML, but it is in fact a
valid character for attribute names and all Vue-supported browsers can parse it correctly. In
addition, they do not appear in the final rendered markup. The shorthand syntax is optional,
but you will likely appreciate it when you learn more about its usage later.
For the rest of the guide, we will be using the shorthand syntax in code examples, as
that's the most common usage for Vue developers.
Boolean attributes are attributes that can indicate true / false values by their presence on
an element. For example, disabled is one of the most commonly used boolean attributes.
v-bind works a bit differently in this case:
The disabled attribute will be included if isButtonDisabled has a truthy value. It will
also be included if the value is an empty string, maintaining consistency with <button
disabled="">. For other falsy values the attribute will be omitted.
If you have a JavaScript object representing multiple attributes that looks like this:Shorthand
Boolean Attributes
Dynamically Binding Multiple Attributes<div :id="dynamicId"></div>
<button :disabled="isButtonDisabled">Button</button>templa
templaYou can bind them to a single element by using v-bind without an argument:
So far we've only been binding to simple property keys in our templates. But Vue actually
supports the full power of JavaScript expressions inside all data bindings:
These expressions will be evaluated as JavaScript in the data scope of the current
component instance.
In Vue templates, JavaScript expressions can be used in the following positions:Using JavaScript Expressions
Inside text interpolations (mustaches)
In the attribute value of any Vue directives (special attributes that start with v-)
Expressions Onlyconst objectOfAttrs = {
  id: 'container',
  class: 'wrapper'
}
<div v-bind="objectOfAttrs"></div>
{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div :id="`list-${id}`"></div>templa
templaEach binding can only contain one single expression. An expression is a piece of code that
can be evaluated to a value. A simple check is whether it can be used after return.
Therefore, the following will NOT work:
It is possible to call a component-exposed method inside a binding expression:
Template expressions are sandboxed and only have access to a restricted list of globals.
The list exposes commonly used built-in globals such as Math and Date.
Globals not explicitly included in the list, for example user-attached properties on window,
will not be accessible in template expressions. You can, however, explicitly define additional
globals for all Vue expressions by adding them to app.config.globalProperties.Calling Functions
TIP
Functions called inside binding expressions will be called every time the component
updates, so they should not have any side effects, such as changing data or triggering
asynchronous operations.ⓘ
Restricted Globals Access<!-- this is a statement, not an expression: -->
{{ var a = 1 }}
<!-- flow control won't work either, use ternary expressions -->
{{ if (ok) { return message } }}
<span :title="toTitleDate(date)">
  {{ formatDate(date) }}
</span>templa
templaDirectives are special attributes with the v- prefix. Vue provides a number of built-in
directives, including v-html and v-bind which we have introduced above.
Directive attribute values are expected to be single JavaScript expressions (with the
exception of v-for, v-on and v-slot, which will be discussed in their respective
sections later). A directive's job is to reactively apply updates to the DOM when the value of
its expression changes. Take v-if as an example:
Here, the v-if directive would remove / insert the <p> element based on the truthiness
of the value of the expression seen.
Some directives can take an "argument", denoted by a colon after the directive name. For
example, the v-bind directive is used to reactively update an HTML attribute:
Here, href is the argument, which tells the v-bind directive to bind the element's href
attribute to the value of the expression url. In the shorthand, everything before the
argument (i.e., v-bind:) is condensed into a single character, :.
Another example is the v-on directive, which listens to DOM events:Directives
Arguments<p v-if="seen">Now you see me</p>
<a v-bind:href="url"> ... </a>
<!-- shorthand -->
<a :href="url"> ... </a>templa
templaHere, the argument is the event name to listen to: click. v-on has a corresponding
shorthand, namely the @ character. We will talk about event handling in more detail too.
It is also possible to use a JavaScript expression in a directive argument by wrapping it with
square brackets:
Here, attributeName will be dynamically evaluated as a JavaScript expression, and its
evaluated value will be used as the final value for the argument. For example, if your
component instance has a data property, attributeName, whose value is "href", then
this binding will be equivalent to v-bind:href.
Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:
In this example, when eventName's value is "focus", v-on:[eventName] will be
equivalent to v-on:focus.Dynamic Arguments<a v-on:click="doSomething"> ... </a>
<!-- shorthand -->
<a @click="doSomething"> ... </a>
<!--
Note that there are some constraints to the argument expression,
as explained in the "Dynamic Argument Value Constraints" and "Dynamic Argumen
-->
<a v-bind:[attributeName]="url"> ... </a>
<!-- shorthand -->
<a :[attributeName]="url"> ... </a>
<a v-on:[eventName]="doSomething"> ... </a>
<!-- shorthand -->
<a @[eventName]="doSomething">templa
templa
templaDynamic arguments are expected to evaluate to a string, with the exception of null. The
special value null can be used to explicitly remove the binding. Any other non-string value
will trigger a warning.
Dynamic argument expressions have some syntax constraints because certain characters,
such as spaces and quotes, are invalid inside HTML attribute names. For example, the
following is invalid:
If you need to pass a complex dynamic argument, it's probably better to use a computed
property, which we will cover shortly.
When using in-DOM templates (templates directly written in an HTML file), you should also
avoid naming keys with uppercase characters, as browsers will coerce attribute names into
lowercase:
The above will be converted to :[someattr] in in-DOM templates. If your component has a
someAttr property instead of someattr, your code won't work. Templates inside Single-
File Components are not subject to this constraint.
Modifiers are special postfixes denoted by a dot, which indicate that a directive should be
bound in some special way. For example, the .prevent modifier tells the v-on directive
to call event.preventDefault() on the triggered event:Dynamic Argument Value Constraints
Dynamic Argument Syntax Constraints
Modifiers<!-- This will trigger a compiler warning. -->
<a :['foo' + bar]="value"> ... </a>
<a :[someAttr]="value"> ... </a>
<form @submit.prevent="onSubmit">...</form>templa
templa
templaYou'll see other examples of modifiers later, for v-on and for v-model, when we explore
those features.
And finally, here's the full directive syntax visualized:
We can create a reactive object or array with the reactive() function:
Reactive objects are JavaScript Proxies and behave just like normal objects. The difference
is that Vue is able to track the property access and mutations of a reactive object. If you are
curious about the details, we explain how Vue's reactivity system works in Reactivity in
Depth - but we recommend reading it after you have finished the main guide.
See also: Typing Reactive
To use reactive state in a component's template, declare and return them from a
component's setup() function:Reactivity Fundamentals
API Preference
This page and many other chapters later in the guide contain different content for Options
API and Composition API. Your current preference is Composition API. You can toggle
between the API styles using the "API Preference" switches at the top of the left sidebar.ⓘ
Declaring Reactive State
TSimport { reactive } from 'vue'
const state = reactive({ count: 0 })Similarly, we can declare functions that mutate reactive state in the same scope and expose
them as methods alongside the state:
Exposed methods are typically used as event listeners:import { reactive } from 'vue'
export default {
  // `setup` is a special hook dedicated for composition API.
  setup() {
    const state = reactive({ count: 0 })
    // expose the state to the template
    return {
      state
    }
  }
}
<div>{{ state.count }}</div>
import { reactive } from 'vue'
export default {
  setup() {
    const state = reactive({ count: 0 })
    function increment() {
      state.count++
    }
    // don't forget to expose the function as well.
    return {
      state,
      increment
    }
  }
}templaManually exposing state and methods via setup() can be verbose. Luckily, it is only
necessary when not using a build step. When using Single-File Components (SFCs), we can
greatly simplify the usage with <script setup>:
Try it in the Playground
Top-level imports and variables declared in <script setup> are automatically usable in
the template of the same component.
For the rest of the guide, we will be primarily using SFC + <script setup> syntax for
Composition API code examples, as that is the most common usage for Vue developers.
When you mutate reactive state, the DOM is updated automatically. However, it should be
noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until<script setup>
▶
DOM Update Timing<button @click="increment">
  {{ state.count }}
</button>
<script setup>
import { reactive } from 'vue'
const state = reactive({ count: 0 })
function increment() {
  state.count++
}
</script>
<template>
  <button @click="increment">
    {{ state.count }}
  </button>
</template>templa
vuthe "next tick" in the update cycle to ensure that each component updates only once no
matter how many state changes you have made.
To wait for the DOM update to complete after a state change, you can use the nextTick()
global API:
In Vue, state is deeply reactive by default. This means you can expect changes to be
detected even when you mutate nested objects or arrays:
It is also possible to explicitly create shallow reactive objects where the reactivity is only
tracked at the root-level, but these are typically only needed in advanced use cases.Deep Reactivity
Reactive Proxy vs. Originalimport { nextTick } from 'vue'
function increment() {
  state.count++
  nextTick(() => {
    // access updated DOM
  })
}
import { reactive } from 'vue'
const obj = reactive({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})
function mutateDeeply() {
  // these will work as expected.
  obj.nested.count++
  obj.arr.push('baz')
}It is important to note that the returned value from reactive() is a Proxy of the original
object, which is not equal to the original object:
Only the proxy is reactive - mutating the original object will not trigger updates. Therefore,
the best practice when working with Vue's reactivity system is to exclusively use the
proxied versions of your state.
To ensure consistent access to the proxy, calling reactive() on the same object always
returns the same proxy, and calling reactive() on an existing proxy also returns that same
proxy:
This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a
reactive object are also proxies:
The reactive() API has two limitations:Limitations of reactive()const raw = {}
const proxy = reactive(raw)
// proxy is NOT equal to the original.
console.log(proxy === raw) // false
// calling reactive() on the same object returns the same proxy
console.log(reactive(raw) === proxy) // true
// calling reactive() on a proxy returns itself
console.log(reactive(proxy) === proxy) // true
const proxy = reactive({})
const raw = {}
proxy.nested = raw
console.log(proxy.nested === raw) // falseIt only works for object types (objects, arrays, and collection types such as Map and
Set). It cannot hold primitive types such as string, number or boolean.1.
Since Vue's reactivity tracking works over property access, we must always keep the
same reference to the reactive object. This means we can't easily "replace" a reactive
object because the reactivity connection to the first reference is lost:
It also means that when we assign or destructure a reactive object's property into local
variables, or when we pass that property into a function, we will lose the reactivity
connection:2.
Reactive Variables with ref()let state = reactive({ count: 0 })
// the above reference ({ count: 0 }) is no longer being tracked (reactivit
state = reactive({ count: 1 })
const state = reactive({ count: 0 })
// n is a local variable that is disconnected
// from state.count.
let n = state.count
// does not affect original state
n++
// count is also disconnected from state.count.
let { count } = state
// does not affect original state
count++
// the function receives a plain number and
// won't be able to track changes to state.count
callSomeFunction(state.count)To address the limitations of reactive(), Vue also provides a ref() function which
allows us to create reactive "refs" that can hold any value type:
ref() takes the argument and returns it wrapped within a ref object with a .value
property:
See also: Typing Refs
Similar to properties on a reactive object, the .value property of a ref is reactive. In
addition, when holding object types, ref automatically converts its .value with
reactive().
A ref containing an object value can reactively replace the entire object:
Refs can also be passed into functions or destructured from plain objects without losing
reactivity:TSimport { ref } from 'vue'
const count = ref(0)
const count = ref(0)
console.log(count) // { value: 0 }
console.log(count.value) // 0
count.value++
console.log(count.value) // 1
const objectRef = ref({ count: 0 })
// this works reactively
objectRef.value = { count: 1 }In other words, ref() allows us to create a "reference" to any value and pass it around
without losing reactivity. This capability is quite important as it is frequently used when
extracting logic into Composable Functions.
When refs are accessed as top-level properties in the template, they are automatically
"unwrapped" so there is no need to use .value. Here's the previous counter example,
using ref() instead:
Try it in the PlaygroundRef Unwrapping in Templates
▶const obj = {
  foo: ref(1),
  bar: ref(2)
}
// the function receives a ref
// it needs to access the value via .value but it
// will retain the reactivity connection
callSomeFunction(obj.foo)
// still reactive
const { foo, bar } = obj
<script setup>
import { ref } from 'vue'
const count = ref(0)
function increment() {
  count.value++
}
</script>
<template>
  <button @click="increment">
    {{ count }} <!-- no .value needed -->
  </button>
</template>vuNote that the unwrapping only applies if the ref is a top-level property on the template
render context. As an example, object is a top-level property, but object.foo is not.
So, given the following object:
The following expression will NOT work as expected:
The rendered result will be [object Object]1 because object.foo is a ref object. We
can fix that by making foo a top-level property:
Now the render result will be 2.
One thing to note is that a ref will also be unwrapped if it is the final evaluated value of a text
interpolation (i.e. a {{ }} tag), so the following will render 1:
This is just a convenience feature of text interpolation and is equivalent to {{
object.foo.value }}.
When a ref is accessed or mutated as a property of a reactive object, it is also
automatically unwrapped so it behaves like a normal property:Ref Unwrapping in Reactive Objectsconst object = { foo: ref(1) }
{{ object.foo + 1 }}
const { foo } = object
{{ foo + 1 }}
{{ object.foo }}templa
templa
templaIf a new ref is assigned to a property linked to an existing ref, it will replace the old ref:
Ref unwrapping only happens when nested inside a deep reactive object. It does not apply
when it is accessed as a property of a shallow reactive object.
Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an
element of a reactive array or a native collection type like Map:Ref Unwrapping in Arrays and Collectionsconst count = ref(0)
const state = reactive({
  count
})
console.log(state.count) // 0
state.count = 1
console.log(count.value) // 1
const otherCount = ref(2)
state.count = otherCount
console.log(state.count) // 2
// original ref is now disconnected from state.count
console.log(count.value) // 1
const books = reactive([ref('Vue 3 Guide')])
// need .value here
console.log(books[0].value)
const map = reactive(new Map([['count', ref(0)]]))
// need .value here
console.log(map.get('count').value)Having to use .value with refs is a drawback imposed by the language constraints of
JavaScript. However, with compile-time transforms we can improve the ergonomics by
automatically appending .value in appropriate locations. Vue provides a compile-time
transform that allows us to write the earlier "counter" example like this:
You can learn more about Reactivity Transform in its dedicated section. Do note that it is
currently still experimental and may change before being finalized.Reactivity Transform Experimental
<script setup>
let count = $ref(0)
function increment() {
  // no need for .value
  count++
}
</script>
<template>
  <button @click="increment">{{ count }}</button>
</template>vuIn-template expressions are very convenient, but they are meant for simple operations.
Putting too much logic in your templates can make them bloated and hard to maintain. For
example, if we have an object with a nested array:
And we want to display different messages depending on if author already has some
books or not:
At this point, the template is getting a bit cluttered. We have to look at it for a second before
realizing that it performs a calculation depending on author.books. More importantly, we
probably don't want to repeat ourselves if we need to include this calculation in the template
more than once.
That's why for complex logic that includes reactive data, it is recommended to use a
computed property. Here's the same example, refactored:Computed Properties
Basic Example
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})
<p>Has published books:</p>
<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>templaTry it in the Playground
Here we have declared a computed property publishedBooksMessage. The computed()
function expects to be passed a getter function, and the returned value is a computed ref.
Similar to normal refs, you can access the computed result as
publishedBooksMessage.value. Computed refs are also auto-unwrapped in templates so
you can reference them without .value in template expressions.
A computed property automatically tracks its reactive dependencies. Vue is aware that the
computation of publishedBooksMessage depends on author.books, so it will update any
bindings that depend on publishedBooksMessage when author.books changes.
See also: Typing Computed▶
TS
Computed Caching vs. Methods<script setup>
import { reactive, computed } from 'vue'
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})
// a computed ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>
<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>vuYou may have noticed we can achieve the same result by invoking a method in the
expression:
Instead of a computed property, we can define the same function as a method. For the end
result, the two approaches are indeed exactly the same. However, the difference is that
computed properties are cached based on their reactive dependencies. A computed
property will only re-evaluate when some of its reactive dependencies have changed. This
means as long as author.books has not changed, multiple access to
publishedBooksMessage will immediately return the previously computed result without
having to run the getter function again.
This also means the following computed property will never update, because Date.now()
is not a reactive dependency:
In comparison, a method invocation will always run the function whenever a re-render
happens.
Why do we need caching? Imagine we have an expensive computed property list, which
requires looping through a huge array and doing a lot of computations. Then we may have
other computed properties that in turn depend on list. Without caching, we would be
executing listʼs getter many more times than necessary! In cases where you do not want
caching, use a method call instead.
Writable Computed<p>{{ calculateBooksMessage() }}</p>
// in component
function calculateBooksMessage() {
  return author.books.length > 0 ? 'Yes' : 'No'
}
const now = computed(() => Date.now())templaComputed properties are by default getter-only. If you attempt to assign a new value to a
computed property, you will receive a runtime warning. In the rare cases where you need a
"writable" computed property, you can create one by providing both a getter and a setter:
Now when you run fullName.value = 'John Doe', the setter will be invoked and
firstName and lastName will be updated accordingly.
It is important to remember that computed getter functions should only perform pure
computation and be free of side effects. For example, don't make async requests or
mutate the DOM inside a computed getter! Think of a computed property as declaratively
describing how to derive a value based on other values - its only responsibility should be
computing and returning that value. Later in the guide we will discuss how we can perform
side effects in reaction to state changes with watchers.Best Practices
Getters should be side-effect free<script setup>
import { ref, computed } from 'vue'
const firstName = ref('John')
const lastName = ref('Doe')
const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // Note: we are using destructuring assignment syntax here.
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>vuThe returned value from a computed property is derived state. Think of it as a temporary
snapshot - every time the source state changes, a new snapshot is created. It does not
make sense to mutate a snapshot, so a computed return value should be treated as read-
only and never be mutated - instead, update the source state it depends on to trigger new
computations.Avoid mutating computed valueA common need for data binding is manipulating an element's class list and inline styles.
Since class and style are both attributes, we can use v-bind to assign them a string
value dynamically, much like with other attributes. However, trying to generate those values
using string concatenation can be annoying and error-prone. For this reason, Vue provides
special enhancements when v-bind is used with class and style. In addition to
strings, the expressions can also evaluate to objects or arrays.
We can pass an object to :class (short for v-bind:class) to dynamically toggle classes:
The above syntax means the presence of the active class will be determined by the
truthiness of the data property isActive.
You can have multiple classes toggled by having more fields in the object. In addition, the
:class directive can also co-exist with the plain class attribute. So given the following
state:
And the following template:Class and Style Bindings
Binding HTML Classes
Binding to Objects
<div :class="{ active: isActive }"></div>
const isActive = ref(true)
const hasError = ref(false)templaIt will render:
When isActive or hasError changes, the class list will be updated accordingly. For
example, if hasError becomes true, the class list will become "static active text-
danger".
The bound object doesn't have to be inline:
This will render the same result. We can also bind to a computed property that returns an
object. This is a common and powerful pattern:<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>
<div class="static active"></div>
const classObject = reactive({
  active: true,
  'text-danger': false
})
<div :class="classObject"></div>
const isActive = ref(true)
const error = ref(null)
const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
<div :class="classObject"></div>templa
templa
templa
templaWe can bind :class to an array to apply a list of classes:
Which will render:
If you would like to also toggle a class in the list conditionally, you can do it with a ternary
expression:
This will always apply errorClass, but activeClass will only be applied when
isActive is truthy.
However, this can be a bit verbose if you have multiple conditional classes. That's why it's
also possible to use the object syntax inside array syntax:
This section assumes knowledge of Components. Feel free to skip it and come back
later.
When you use the class attribute on a component with a single root element, those
classes will be added to the component's root element, and merged with any existing class
already on it.Binding to Arrays
With Componentsconst activeClass = ref('active')
const errorClass = ref('text-danger')
<div :class="[activeClass, errorClass]"></div>
<div class="active text-danger"></div>
<div :class="[isActive ? activeClass : '', errorClass]"></div>
<div :class="[{ active: isActive }, errorClass]"></div>templa
templa
templa
templaFor example, if we have a component named MyComponent with the following template:
Then add some classes when using it:
The rendered HTML will be:
The same is true for class bindings:
When isActive is truthy, the rendered HTML will be:
If your component has multiple root elements, you would need to define which element will
receive this class. You can do this using the $attrs component property:
Will render:<!-- child component template -->
<p class="foo bar">Hi!</p>
<!-- when using the component -->
<MyComponent class="baz boo" />
<p class="foo bar baz boo">Hi</p>
<MyComponent :class="{ active: isActive }" />
<p class="foo bar active">Hi</p>
<!-- MyComponent template using $attrs -->
<p :class="$attrs.class">Hi!</p>
<span>This is a child component</span>
<MyComponent class="baz" />templa
templa
templa
templa
templa
templa
templaYou can learn more about component attribute inheritance in Fallthrough Attributes
section.
:style supports binding to JavaScript object values - it corresponds to an HTML
element's style property:
Although camelCase keys are recommended, :style also supports kebab-cased CSS
property keys (corresponds to how they are used in actual CSS) - for example:
It is often a good idea to bind to a style object directly so that the template is cleaner:Binding Inline Styles
Binding to Objects<p class="baz">Hi!</p>
<span>This is a child component</span>
const activeColor = ref('red')
const fontSize = ref(30)
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
<div :style="{ 'font-size': fontSize + 'px' }"></div>
const styleObject = reactive({
  color: 'red',
  fontSize: '13px'
})
<div :style="styleObject"></div>htm
templa
templa
templaAgain, object style binding is often used in conjunction with computed properties that return
objects.
We can bind :style to an array of multiple style objects. These objects will be merged and
applied to the same element:
When you use a CSS property that requires a vendor prefix in :style, Vue will
automatically add the appropriate prefix. Vue does this by checking at runtime to see which
style properties are supported in the current browser. If the browser doesn't support a
particular property then various prefixed variants will be tested to try to find one that is
supported.
You can provide an array of multiple (prefixed) values to a style property, for example:
This will only render the last value in the array which the browser supports. In this example,
it will render display: flex for browsers that support the unprefixed version of flexbox.Binding to Arrays
Auto-prefixing
Multiple Values<div :style="[baseStyles, overridingStyles]"></div>
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>templa
templaThe directive v-if is used to conditionally render a block. The block will only be rendered
if the directive's expression returns a truthy value.
You can use the v-else directive to indicate an "else block" for v-if:
Toggle
Try it in the Playground
A v-else element must immediately follow a v-if or a v-else-if element - otherwise
it will not be recognized.Conditional Rendering
v-if
v-else
Vue is awesome!
▶<h1 v-if="awesome">Vue is awesome!</h1>
<button @click="awesome = !awesome">Toggle</button>
<h1 v-if="awesome">Vue is awesome!</h1>
<h1 v-else>Oh no 😢</h1>templa
templaThe v-else-if, as the name suggests, serves as an "else if block" for v-if. It can also
be chained multiple times:
Similar to v-else, a v-else-if element must immediately follow a v-if or a v-else-
if element.
Because v-if is a directive, it has to be attached to a single element. But what if we want
to toggle more than one element? In this case we can use v-if on a <template>
element, which serves as an invisible wrapper. The final rendered result will not include the
<template> element.v-else-if
v-if on <template><div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>templa
templav-else and v-else-if can also be used on <template>.
Another option for conditionally displaying an element is the v-show directive. The usage
is largely the same:
The difference is that an element with v-show will always be rendered and remain in the
DOM; v-show only toggles the display CSS property of the element.
v-show doesn't support the <template> element, nor does it work with v-else.
v-if is "real" conditional rendering because it ensures that event listeners and child
components inside the conditional block are properly destroyed and re-created during
toggles.
v-if is also lazy: if the condition is false on initial render, it will not do anything - the
conditional block won't be rendered until the condition becomes true for the first time.
In comparison, v-show is much simpler - the element is always rendered regardless of
initial condition, with CSS-based toggling.
Generally speaking, v-if has higher toggle costs while v-show has higher initial render
costs. So prefer v-show if you need to toggle something very often, and prefer v-if if
the condition is unlikely to change at runtime.v-show
v-if vs. v-show<h1 v-show="ok">Hello!</h1>templaWhen v-if and v-for are both used on the same element, v-if will be evaluated first.
See the list rendering guide for details.v-if with v-for
Note
It's not recommended to use v-if and v-for on the same element due to implicit
precedence. Refer to style guide for details.⚠We can use the v-for directive to render a list of items based on an array. The v-for
directive requires a special syntax in the form of item in items, where items is the
source data array and item is an alias for the array element being iterated on:
Inside the v-for scope, template expressions have access to all parent scope properties.
In addition, v-for also supports an optional second alias for the index of the current item:
Try it in the Playground
The variable scoping of v-for is similar to the following JavaScript:List Rendering
v-for
Parent - 0 - Foo
Parent - 1 - Bar
▶const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
<li v-for="item in items">
  {{ item.message }}
</li>
const parentMessage = ref('Parent')
const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
<li v-for="(item, index) in items">
  {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>templa
templaNotice how the v-for value matches the function signature of the forEach callback. In
fact, you can use destructuring on the v-for item alias similar to destructuring function
arguments:
For nested v-for, scoping also works similar to nested functions. Each v-for scope has
access to parent scopes:
You can also use of as the delimiter instead of in, so that it is closer to JavaScript's
syntax for iterators:const parentMessage = 'Parent'
const items = [
  /* ... */
]
items.forEach((item, index) => {
  // has access to outer scope `parentMessage`
  // but `item` and `index` are only available in here
  console.log(parentMessage, item.message, index)
})
<li v-for="{ message } in items">
  {{ message }}
</li>
<!-- with index alias -->
<li v-for="({ message }, index) in items">
  {{ message }} {{ index }}
</li>
<li v-for="item in items">
  <span v-for="childItem in item.children">
    {{ item.message }} {{ childItem }}
  </span>
</li>
<div v-for="item of items"></div>templa
templa
templaYou can also use v-for to iterate through the properties of an object. The iteration order
will be based on the result of calling Object.keys() on the object:
You can also provide a second alias for the property's name (a.k.a. key):
And another for the index:
Try it in the Playgroundv-for with an Object
▶
v-for with a Rangeconst myObject = reactive({
  title: 'How to do lists in Vue',
  author: 'Jane Doe',
  publishedAt: '2016-04-10'
})
<ul>
  <li v-for="value in myObject">
    {{ value }}
  </li>
</ul>
<li v-for="(value, key) in myObject">
  {{ key }}: {{ value }}
</li>
<li v-for="(value, key, index) in myObject">
  {{ index }}. {{ key }}: {{ value }}
</li>templa
templa
templav-for can also take an integer. In this case it will repeat the template that many times,
based on a range of 1...n.
Note here n starts with an initial value of 1 instead of 0.
Similar to template v-if, you can also use a <template> tag with v-for to render a
block of multiple elements. For example:
When they exist on the same node, v-if has a higher priority than v-for. That means
the v-if condition will not have access to variables from the scope of the v-for:v-for on <template>
v-for with v-if
Note
It's not recommended to use v-if and v-for on the same element due to implicit
precedence. Refer to style guide for details.⚠<span v-for="n in 10">{{ n }}</span>
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>templa
templaThis can be fixed by moving v-for to a wrapping <template> tag (which is also more
explicit):
When Vue is updating a list of elements rendered with v-for, by default it uses an "in-
place patch" strategy. If the order of the data items has changed, instead of moving the
DOM elements to match the order of the items, Vue will patch each element in-place and
make sure it reflects what should be rendered at that particular index.
This default mode is efficient, but only suitable when your list render output does not
rely on child component state or temporary DOM state (e.g. form input values).
To give Vue a hint so that it can track each node's identity, and thus reuse and reorder
existing elements, you need to provide a unique key attribute for each item:
When using <template v-for>, the key should be placed on the <template> container:Maintaining State with key<!--
This will throw an error because property "todo"
is not defined on instance.
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
<div v-for="item in items" :key="item.id">
  <!-- content -->
</div>templa
templa
templaIt is recommended to provide a key attribute with v-for whenever possible, unless the
iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or
you are intentionally relying on the default behavior for performance gains.
The key binding expects primitive values - i.e. strings and numbers. Do not use objects as
v-for keys. For detailed usage of the key attribute, please see the key API
documentation.
This section assumes knowledge of Components. Feel free to skip it and come back
later.
You can directly use v-for on a component, like any normal element (don't forget to
provide a key):
However, this won't automatically pass any data to the component, because components
have isolated scopes of their own. In order to pass the iterated data into the component, we
should also use props:Note
key here is a special attribute being bound with v-bind. It should not be confused
with the property key variable when using v-for with an object.ⓘ
v-for with a Component<template v-for="todo in todos" :key="todo.name">
  <li>{{ todo.name }}</li>
</template>
<MyComponent v-for="item in items" :key="item.id" />templa
templaThe reason for not automatically injecting item into the component is because that makes
the component tightly coupled to how v-for works. Being explicit about where its data
comes from makes the component reusable in other situations.
Check out this example of a simple todo list to see how to render a list of components
using v-for, passing different data to each instance.
Vue is able to detect when a reactive array's mutation methods are called and trigger
necessary updates. These mutation methods are:
Mutation methods, as the name suggests, mutate the original array they are called on. In
comparison, there are also non-mutating methods, e.g. filter(), concat() and▶
Array Change Detection
Mutation Methods
push()
pop()
shift()
unshift()
splice()
sort()
reverse()
Replacing an Array<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>templaslice(), which do not mutate the original array but always return a new array. When
working with non-mutating methods, we should replace the old array with the new one:
You might think this will cause Vue to throw away the existing DOM and re-render the entire
list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM
element reuse, so replacing an array with another array containing overlapping objects is a
very efficient operation.
Sometimes we want to display a filtered or sorted version of an array without actually
mutating or resetting the original data. In this case, you can create a computed property that
returns the filtered or sorted array.
For example:
In situations where computed properties are not feasible (e.g. inside nested v-for loops),
you can use a method:Displaying Filtered/Sorted Results// `items` is a ref with array value
items.value = items.value.filter((item) => item.message.match(/Foo/))
const numbers = ref([1, 2, 3, 4, 5])
const evenNumbers = computed(() => {
  return numbers.value.filter((n) => n % 2 === 0)
})
<li v-for="n in evenNumbers">{{ n }}</li>templaBe careful with reverse() and sort() in a computed property! These two methods will
mutate the original array, which should be avoided in computed getters. Create a copy of the
original array before calling these methods:const sets = ref([
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10]
])
function even(numbers) {
  return numbers.filter((number) => number % 2 === 0)
}
<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
- return numbers.reverse()
+ return [...numbers].reverse()templa
dWe can use the v-on directive, which we typically shorten to the @ symbol, to listen to
DOM events and run some JavaScript when they're triggered. The usage would be v-
on:click="handler" or with the shortcut, @click="handler".
The handler value can be one of the following:
Inline handlers are typically used in simple cases, for example:
Try it in the PlaygroundEvent Handling
Listening to Events
Inline handlers: Inline JavaScript to be executed when the event is triggered (similar to
the native onclick attribute).1.
Method handlers: A property name or path that points to a method defined on the
component.2.
Inline Handlers
▶
Method Handlersconst count = ref(0)
<button @click="count++">Add 1</button>
<p>Count is: {{ count }}</p>templaThe logic for many event handlers will be more complex though, and likely isn't feasible with
inline handlers. That's why v-on can also accept the name or path of a component method
you'd like to call.
For example:
Try it in the Playground
A method handler automatically receives the native DOM Event object that triggers it - in the
example above, we are able to access the element dispatching the event via
event.target.tagName.
See also: Typing Event Handlers
The template compiler detects method handlers by checking whether the v-on value string
is a valid JavaScript identifier or property access path. For example, foo, foo.bar and
foo['bar'] are treated as method handlers, while foo() and count++ are treated as
inline handlers.▶
TS
Method vs. Inline Detection
Calling Methods in Inline Handlersconst name = ref('Vue.js')
function greet(event) {
  alert(`Hello ${name.value}!`)
  // `event` is the native DOM event
  if (event) {
    alert(event.target.tagName)
  }
}
<!-- `greet` is the name of the method defined above -->
<button @click="greet">Greet</button>templaInstead of binding directly to a method name, we can also call methods in an inline handler.
This allows us to pass the method custom arguments instead of the native event:
Try it in the Playground
Sometimes we also need to access the original DOM event in an inline handler. You can pass
it into a method using the special $event variable, or use an inline arrow function:▶
Accessing Event Argument in Inline Handlersfunction say(message) {
  alert(message)
}
<button @click="say('hello')">Say hello</button>
<button @click="say('bye')">Say bye</button>
<!-- using $event special variable -->
<button @click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
<!-- using inline arrow function -->
<button @click="(event) => warn('Form cannot be submitted yet.', event)">
  Submit
</button>
function warn(message, event) {
  // now we have access to the native event
  if (event) {
    event.preventDefault()
  }
  alert(message)
}templa
templaIt is a very common need to call event.preventDefault() or event.stopPropagation()
inside event handlers. Although we can do this easily inside methods, it would be better if
the methods can be purely about data logic rather than having to deal with DOM event
details.
To address this problem, Vue provides event modifiers for v-on. Recall that modifiers are
directive postfixes denoted by a dot.Event Modifiers
.stop
.prevent
.self
.capture
.once
.passive
<!-- the click event's propagation will be stopped -->
<a @click.stop="doThis"></a>
<!-- the submit event will no longer reload the page -->
<form @submit.prevent="onSubmit"></form>
<!-- modifiers can be chained -->
<a @click.stop.prevent="doThat"></a>
<!-- just the modifier -->
<form @submit.prevent></form>
<!-- only trigger handler if event.target is the element itself -->
<!-- i.e. not from a child element -->
<div @click.self="doThat">...</div>templaThe .capture, .once, and .passive modifiers mirror the options of the native
addEventListener method:
The .passive modifier is typically used with touch event listeners for improving
performance on mobile devices.
When listening for keyboard events, we often need to check for specific keys. Vue allows
adding key modifiers for v-on or @ when listening for key events:TIP
Order matters when using modifiers because the relevant code is generated in the same
order. Therefore using @click.prevent.self will prevent click's default action on the
element itself and its children, while @click.self.prevent will only prevent click's
default action on the element itself.ⓘ
TIP
Do not use .passive and .prevent together, because .passive already indicates to
the browser that you do not intend to prevent the event's default behavior, and you will
likely see a warning from the browser if you do so.ⓘ
Key Modifiers<!-- use capture mode when adding the event listener -->
<!-- i.e. an event targeting an inner element is handled here before being ha
<div @click.capture="doThis">...</div>
<!-- the click event will be triggered at most once -->
<a @click.once="doThis"></a>
<!-- the scroll event's default behavior (scrolling) will happen -->
<!-- immediately, instead of waiting for `onScroll` to complete  -->
<!-- in case it contains `event.preventDefault()`                -->
<div @scroll.passive="onScroll">...</div>templaYou can directly use any valid key names exposed via KeyboardEvent.key as modifiers by
converting them to kebab-case.
In the above example, the handler will only be called if $event.key is equal to
'PageDown'.
Vue provides aliases for the most commonly used keys:
You can use the following modifiers to trigger mouse or keyboard event listeners only when
the corresponding modifier key is pressed:Key Aliases
.enter
.tab
.delete (captures both "Delete" and "Backspace" keys)
.esc
.space
.up
.down
.left
.right
System Modifier Keys
.ctrl
.alt
.shift
.meta<!-- only call `submit` when the `key` is `Enter` -->
<input @keyup.enter="submit" />
<input @keyup.page-down="onPageDown" />templa
templaFor example:
The .exact modifier allows control of the exact combination of system modifiers needed
to trigger an event.Note
On Macintosh keyboards, meta is the command key ( ⌘ ). On Windows keyboards, meta is
the Windows key ( ⊞ ). On Sun Microsystems keyboards, meta is marked as a solid
diamond ( ◆). On certain keyboards, specifically MIT and Lisp machine keyboards and
successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”.
On Symbolics keyboards, meta is labeled “META” or “Meta”.ⓘ
TIP
Note that modifier keys are different from regular keys and when used with keyup
events, they have to be pressed when the event is emitted. In other words, keyup.ctrl
will only trigger if you release a key while holding down ctrl. It won't trigger if you
release the ctrl key alone.ⓘ
.exact Modifier<!-- Alt + Enter -->
<input @keyup.alt.enter="clear" />
<!-- Ctrl + Click -->
<div @click.ctrl="doSomething">Do something</div>
<!-- this will fire even if Alt or Shift is also pressed -->
<button @click.ctrl="onClick">A</button>
<!-- this will only fire when Ctrl and no other keys are pressed -->
<button @click.ctrl.exact="onCtrlClick">A</button>
<!-- this will only fire when no system modifiers are pressed -->
<button @click.exact="onClick">A</button>templa
templaThese modifiers restrict the handler to events triggered by a specific mouse button.Mouse Button Modifiers
.left
.right
.middleWhen dealing with forms on the frontend, we often need to sync the state of form input
elements with corresponding state in JavaScript. It can be cumbersome to manually wire up
value bindings and change event listeners:
The v-model directive helps us simplify the above to:
In addition, v-model can be used on inputs of different types, <textarea>, and
<select> elements. It automatically expands to different DOM property and event pairs
based on the element it is used on:Form Input Bindings
<input> with text types and <textarea> elements use value property and input
event;
<input type="checkbox"> and <input type="radio"> use checked property and
change event;
<select> use value as a prop and change as an event.
Note
v-model will ignore the initial value, checked or selected attributes found on any
form elements. It will always treat the current bound JavaScript state as the source of
truth. You should declare the initial value on the JavaScript side, using reactivity APIs.ⓘ
Basic Usage<input
  :value="text"
  @input="event => text = event.target.value">
<input v-model="text">templa
templaMessage is:
edit me
Try it in the Playground
Multiline message is:
add multiple lines
Try it in the Playground
Note that interpolation inside <textarea> won't work. Use v-model instead.Text
▶
Note
For languages that require an IME (Chinese, Japanese, Korean etc.), you'll notice that v-
model doesn't get updated during IME composition. If you want to respond to these
updates as well, use your own input event listener and value binding instead of using
v-model.ⓘ
Multiline text
▶<p>Message is: {{ message }}</p>
<input v-model="message" placeholder="edit me" />
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<textarea v-model="message" placeholder="add multiple lines"></textarea>templa
templaSingle checkbox, boolean value:
false
Try it in the Playground
We can also bind multiple checkboxes to the same array or Set value:
Checked names: []
JackJohnMikeCheckbox
▶<!-- bad -->
<textarea>{{ text }}</textarea>
<!-- good -->
<textarea v-model="text"></textarea>
<input type="checkbox" id="checkbox" v-model="checked" />
<label for="checkbox">{{ checked }}</label>
const checkedNames = ref([])
<div>Checked names: {{ checkedNames }}</div>
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>templa
templa
templaIn this case, the checkedNames array will always contain the values from the currently
checked boxes.
Try it in the Playground
Picked:
OneTwo
Try it in the Playground
Single select:
Selected:▶
Radio
▶
Select<div>Picked: {{ picked }}</div>
<input type="radio" id="one" value="One" v-model="picked" />
<label for="one">One</label>
<input type="radio" id="two" value="Two" v-model="picked" />
<label for="two">Two</label>
<div>Selected: {{ selected }}</div>
<select v-model="selected">
  <option disabled value="">Please select one</option>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>templa
templaPlease select one
Try it in the Playground
Multiple select (bound to array):
Selected: []
A
B
C
Try it in the Playground
Select options can be dynamically rendered with v-for:▶
Note
If the initial value of your v-model expression does not match any of the options, the
<select> element will render in an "unselected" state. On iOS this will cause the user
not being able to select the first item because iOS does not fire a change event in this
case. It is therefore recommended to provide a disabled option with an empty value, as
demonstrated in the example above.ⓘ
▶<div>Selected: {{ selected }}</div>
<select v-model="selected" multiple>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>templaTry it in the Playground
For radio, checkbox and select options, the v-model binding values are usually static
strings (or booleans for checkbox):
But sometimes we may want to bind the value to a dynamic property on the current active
instance. We can use v-bind to achieve that. In addition, using v-bind allows us to bind▶
Value Bindingsconst selected = ref('A')
const options = ref([
  { text: 'One', value: 'A' },
  { text: 'Two', value: 'B' },
  { text: 'Three', value: 'C' }
])
<select v-model="selected">
  <option v-for="option in options" :value="option.value">
    {{ option.text }}
  </option>
</select>
<div>Selected: {{ selected }}</div>
<!-- `picked` is a string "a" when checked -->
<input type="radio" v-model="picked" value="a" />
<!-- `toggle` is either true or false -->
<input type="checkbox" v-model="toggle" />
<!-- `selected` is a string "abc" when the first option is selected -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>templa
templathe input value to non-string values.
true-value and false-value are Vue-specific attributes that only work with v-model.
Here the toggle property's value will be set to 'yes' when the box is checked, and set
to 'no' when unchecked. You can also bind them to dynamic values using v-bind:
pick will be set to the value of first when the first radio input is checked, and set to the
value of second when the second one is checked.Checkbox
Tip
The true-value and false-value attributes don't affect the input's value attribute,
because browsers don't include unchecked boxes in form submissions. To guarantee that
one of two values is submitted in a form (e.g. "yes" or "no"), use radio inputs instead.ⓘ
Radio<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no" />
<input
  type="checkbox"
  v-model="toggle"
  :true-value="dynamicTrueValue"
  :false-value="dynamicFalseValue" />
<input type="radio" v-model="pick" :value="first" />
<input type="radio" v-model="pick" :value="second" />templa
templa
templav-model supports value bindings of non-string values as well! In the above example, when
the option is selected, selected will be set to the object literal value of { number: 123
}.
By default, v-model syncs the input with the data after each input event (with the
exception of IME composition as stated above). You can add the lazy modifier to instead
sync after change events:
If you want user input to be automatically typecast as a number, you can add the number
modifier to your v-model managed inputs:
If the value cannot be parsed with parseFloat(), then the original value is used instead.
The number modifier is applied automatically if the input has type="number".Select Options
Modifiers
.lazy
.number<select v-model="selected">
  <!-- inline object literal -->
  <option :value="{ number: 123 }">123</option>
</select>
<!-- synced after "change" instead of "input" -->
<input v-model.lazy="msg" />
<input v-model.number="age" />templa
templa
templaIf you want whitespace from user input to be trimmed automatically, you can add the trim
modifier to your v-model-managed inputs:
If you're not yet familiar with Vue's components, you can skip this for now.
HTML's built-in input types won't always meet your needs. Fortunately, Vue components
allow you to build reusable inputs with completely customized behavior. These inputs even
work with v-model! To learn more, read about Usage with v-model in the Components
guide..trim
v-model with Components<input v-model.trim="msg" />templaEach Vue component instance goes through a series of initialization steps when it's created
- for example, it needs to set up data observation, compile the template, mount the instance
to the DOM, and update the DOM when data changes. Along the way, it also runs functions
called lifecycle hooks, giving users the opportunity to add their own code at specific stages.
For example, the onMounted hook can be used to run code after the component has
finished the initial rendering and created the DOM nodes:
There are also other hooks which will be called at different stages of the instance's lifecycle,
with the most commonly used being onMounted, onUpdated, and onUnmounted.
When calling onMounted, Vue automatically associates the registered callback function
with the current active component instance. This requires these hooks to be registered
synchronously during component setup. For example, do not do this:Lifecycle Hooks
Registering Lifecycle Hooks
<script setup>
import { onMounted } from 'vue'
onMounted(() => {
  console.log(`the component is now mounted.`)
})
</script>
setTimeout(() => {
  onMounted(() => {
    // this won't work.
  })
}, 100)vuDo note this doesn't mean that the call must be placed lexically inside setup() or <script
setup>. onMounted() can be called in an external function as long as the call stack is
synchronous and originates from within setup().
Below is a diagram for the instance lifecycle. You don't need to fully understand everything
going on right now, but as you learn and build more, it will be a useful reference.Lifecycle DiagramConsult the Lifecycle Hooks API reference for details on all lifecycle hooks and their
respective use cases.Computed properties allow us to declaratively compute derived values. However, there are
cases where we need to perform "side effects" in reaction to state changes - for example,
mutating the DOM, or changing another piece of state based on the result of an async
operation.
With Composition API, we can use the watch function to trigger a callback whenever a
piece of reactive state changes:Watchers
Basic Example
<script setup>
import { ref, watch } from 'vue'
const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')
// watch works directly on a ref
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.indexOf('?') > -1) {
    answer.value = 'Thinking...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
</script>
<template>
  <p>
    Ask a yes/no question:
    <input v-model="question" />
  </p>
  <p>{{ answer }}</p>
</template>vuTry it in the Playground
watch's first argument can be different types of reactive "sources": it can be a ref
(including computed refs), a reactive object, a getter function, or an array of multiple
sources:
Do note that you can't watch a property of a reactive object like this:
Instead, use a getter:▶
Watch Source Types
const x = ref(0)
const y = ref(0)
// single ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})
// getter
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)
// array of multiple sources
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})
const obj = reactive({ count: 0 })
// this won't work because we are passing a number to watch()
watch(obj.count, (count) => {
  console.log(`count is: ${count}`)
})When you call watch() directly on a reactive object, it will implicitly create a deep watcher
- the callback will be triggered on all nested mutations:
This should be differentiated with a getter that returns a reactive object - in the latter case,
the callback will only fire if the getter returns a different object:
You can, however, force the second case into a deep watcher by explicitly using the deep
option:Deep Watchers// instead, use a getter:
watch(
  () => obj.count,
  (count) => {
    console.log(`count is: ${count}`)
  }
)
const obj = reactive({ count: 0 })
watch(obj, (newValue, oldValue) => {
  // fires on nested property mutations
  // Note: `newValue` will be equal to `oldValue` here
  // because they both point to the same object!
})
obj.count++
watch(
  () => state.someObject,
  () => {
    // fires only when state.someObject is replaced
  }
)watch is lazy by default: the callback won't be called until the watched source has
changed. But in some cases we may want the same callback logic to be run eagerly - for
example, we may want to fetch some initial data, and then re-fetch the data whenever
relevant state changes.
We can force a watcher's callback to be executed immediately by passing the immediate:
true option:Use with Caution
Deep watch requires traversing all nested properties in the watched object, and can be
expensive when used on large data structures. Use it only when necessary and beware of
the performance implications.⚠
Eager Watchers
watchEffect()watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // Note: `newValue` will be equal to `oldValue` here
    // *unless* state.someObject has been replaced
  },
  { deep: true }
)
watch(source, (newValue, oldValue) => {
  // executed immediately, then again when `source` changes
}, { immediate: true })It is common for the watcher callback to use exactly the same reactive state as the source.
For example, consider the following code, which uses a watcher to load a remote resource
whenever the todoId ref changes:
In particular, notice how the watcher uses todoId twice, once as the source and then again
inside the callback.
This can be simplified with watchEffect(). watchEffect() allows us to track the
callback's reactive dependencies automatically. The watcher above can be rewritten as:
Here, the callback will run immediately, there's no need to specify immediate: true.
During its execution, it will automatically track todoId.value as a dependency (similar to
computed properties). Whenever todoId.value changes, the callback will be run again.
With watchEffect(), we no longer need to pass todoId explicitly as the source value.
You can check out this example of watchEffect() and reactive data-fetching in action.
For examples like these, with only one dependency, the benefit of watchEffect() is
relatively small. But for watchers that have multiple dependencies, using watchEffect()
removes the burden of having to maintain the list of dependencies manually. In addition, if
you need to watch several properties in a nested data structure, watchEffect() may proveconst todoId = ref(1)
const data = ref(null)
watch(todoId, async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
}, { immediate: true })
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})more efficient than a deep watcher, as it will only track the properties that are used in the
callback, rather than recursively tracking all of them.
watch and watchEffect both allow us to reactively perform side effects. Their main
difference is the way they track their reactive dependencies:
When you mutate reactive state, it may trigger both Vue component updates and watcher
callbacks created by you.
By default, user-created watcher callbacks are called before Vue component updates. This
means if you attempt to access the DOM inside a watcher callback, the DOM will be in the
state before Vue has applied any updates.TIP
watchEffect only tracks dependencies during its synchronous execution. When using it
with an async callback, only properties accessed before the first await tick will be
tracked.ⓘ
watch vs. watchEffect
watch only tracks the explicitly watched source. It won't track anything accessed inside
the callback. In addition, the callback only triggers when the source has actually changed.
watch separates dependency tracking from the side effect, giving us more precise
control over when the callback should fire.
watchEffect, on the other hand, combines dependency tracking and side effect into
one phase. It automatically tracks every reactive property accessed during its
synchronous execution. This is more convenient and typically results in terser code, but
makes its reactive dependencies less explicit.
Callback Flush TimingIf you want to access the DOM in a watcher callback after Vue has updated it, you need to
specify the flush: 'post' option:
Post-flush watchEffect() also has a convenience alias, watchPostEffect():
Watchers declared synchronously inside setup() or <script setup> are bound to the
owner component instance, and will be automatically stopped when the owner component is
unmounted. In most cases, you don't need to worry about stopping the watcher yourself.
The key here is that the watcher must be created synchronously: if the watcher is created
in an async callback, it won't be bound to the owner component and must be stopped
manually to avoid memory leaks. Here's an example:Stopping a Watcherwatch(source, callback, {
  flush: 'post'
})
watchEffect(callback, {
  flush: 'post'
})
import { watchPostEffect } from 'vue'
watchPostEffect(() => {
  /* executed after Vue updates */
})To manually stop a watcher, use the returned handle function. This works for both watch
and watchEffect:
Note that there should be very few cases where you need to create watchers
asynchronously, and synchronous creation should be preferred whenever possible. If you
need to wait for some async data, you can make your watch logic conditional instead:<script setup>
import { watchEffect } from 'vue'
// this one will be automatically stopped
watchEffect(() => {})
// ...this one will not!
setTimeout(() => {
  watchEffect(() => {})
}, 100)
</script>
const unwatch = watchEffect(() => {})
// ...later, when no longer needed
unwatch()
// data to be loaded asynchronously
const data = ref(null)
watchEffect(() => {
  if (data.value) {
    // do something when data is loaded
  }
})vuWhile Vue's declarative rendering model abstracts away most of the direct DOM operations
for you, there may still be cases where we need direct access to the underlying DOM
elements. To achieve this, we can use the special ref attribute:
ref is a special attribute, similar to the key attribute discussed in the v-for chapter. It
allows us to obtain a direct reference to a specific DOM element or child component
instance after it's mounted. This may be useful when you want to, for example,
programmatically focus an input on component mount, or initialize a 3rd party library on an
element.
To obtain the reference with Composition API, we need to declare a ref with the same name:
If not using <script setup>, make sure to also return the ref from setup():Template Refs
Accessing the Refs<input ref="input">
<script setup>
import { ref, onMounted } from 'vue'
// declare a ref to hold the element reference
// the name must match template ref value
const input = ref(null)
onMounted(() => {
  input.value.focus()
})
</script>
<template>
  <input ref="input" />
</template>templa
vuNote that you can only access the ref after the component is mounted. If you try to access
input in a template expression, it will be null on the first render. This is because the
element doesn't exist until after the first render!
If you are trying to watch the changes of a template ref, make sure to account for the case
where the ref has null value:
See also: Typing Template Refs
Requires v3.2.25 or above
When ref is used inside v-for, the corresponding ref should contain an Array value,
which will be populated with the elements after mount:TS
Refs inside v-forexport default {
  setup() {
    const input = ref(null)
    // ...
    return {
      input
    }
  }
}
watchEffect(() => {
  if (input.value) {
    input.value.focus()
  } else {
    // not mounted yet, or the element was unmounted (e.g. by v-if)
  }
})Try it in the Playground
It should be noted that the ref array does not guarantee the same order as the source array.
Instead of a string key, the ref attribute can also be bound to a function, which will be
called on each component update and gives you full flexibility on where to store the element
reference. The function receives the element reference as the first argument:
Note we are using a dynamic :ref binding so we can pass it a function instead of a ref
name string. When the element is unmounted, the argument will be null. You can, of
course, use a method instead of an inline function.▶
Function Refs<script setup>
import { ref, onMounted } from 'vue'
const list = ref([
  /* ... */
])
const itemRefs = ref([])
onMounted(() => console.log(itemRefs.value))
</script>
<template>
  <ul>
    <li v-for="item in list" ref="itemRefs">
      {{ item }}
    </li>
  </ul>
</template>
<input :ref="(el) => { /* assign el to a property or ref */ }">vu
templaThis section assumes knowledge of Components. Feel free to skip it and come back
later.
ref can also be used on a child component. In this case the reference will be that of a
component instance:
If the child component is using Options API or not using <script setup>, the referenced
instance will be identical to the child component's this, which means the parent
component will have full access to every property and method of the child component. This
makes it easy to create tightly coupled implementation details between the parent and the
child, so component refs should be only used when absolutely needed - in most cases, you
should try to implement parent / child interactions using the standard props and emit
interfaces first.
An exception here is that components using <script setup> are private by default: a
parent component referencing a child component using <script setup> won't be able to
access anything unless the child component chooses to expose a public interface using the
defineExpose macro:Ref on Component
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'
const child = ref(null)
onMounted(() => {
  // child.value will hold an instance of <Child />
})
</script>
<template>
  <Child ref="child" />
</template>vuWhen a parent gets an instance of this component via template refs, the retrieved instance
will be of the shape { a: number, b: number } (refs are automatically unwrapped just like
on normal instances).
See also: Typing Component Template RefsTS<script setup>
import { ref } from 'vue'
const a = 1
const b = ref(2)
// Compiler macros, such as defineExpose, don't need to be imported
defineExpose({
  a,
  b
})
</script>vuComponents allow us to split the UI into independent and reusable pieces, and think about
each piece in isolation. It's common for an app to be organized into a tree of nested
components:
This is very similar to how we nest native HTML elements, but Vue implements its own
component model that allow us to encapsulate custom content and logic in each
component. Vue also plays nicely with native Web Components. If you are curious about the
relationship between Vue Components and native Web Components, read more here.
When using a build step, we typically define each Vue component in a dedicated file using
the .vue extension - known as a Single-File Component (SFC for short):Components Basics
Defining a ComponentWhen not using a build step, a Vue component can be defined as a plain JavaScript object
containing Vue-specific options:
The template is inlined as a JavaScript string here, which Vue will compile on the fly. You can
also use an ID selector pointing to an element (usually native <template> elements) - Vue
will use its content as the template source.
The example above defines a single component and exports it as the default export of a
.js file, but you can use named exports to export multiple components from the same file.
Using a Component<script setup>
import { ref } from 'vue'
const count = ref(0)
</script>
<template>
  <button @click="count++">You clicked me {{ count }} times.</button>
</template>
import { ref } from 'vue'
export default {
  setup() {
    const count = ref(0)
    return { count }
  },
  template: `
    <button @click="count++">
      You clicked me {{ count }} times.
    </button>`
  // or `template: '#my-template-element'`
}vuTo use a child component, we need to import it in the parent component. Assuming we
placed our counter component inside a file called ButtonCounter.vue, the component will
be exposed as the file's default export:
With <script setup>, imported components are automatically made available to the
template.
It's also possible to globally register a component, making it available to all components in a
given app without having to import it. The pros and cons of global vs. local registration is
discussed in the dedicated Component Registration section.
Components can be reused as many times as you want:
Try it in the Playground
Notice that when clicking on the buttons, each one maintains its own, separate count.
That's because each time you use a component, a new instance of it is created.TIP
We will be using SFC syntax for the rest of this guide - the concepts around components
are the same regardless of whether you are using a build step or not. The Examples
section shows component usage in both scenarios.ⓘ
▶<script setup>
import ButtonCounter from './ButtonCounter.vue'
</script>
<template>
  <h1>Here is a child component!</h1>
  <ButtonCounter />
</template>
<h1>Here are many child components!</h1>
<ButtonCounter />
<ButtonCounter />
<ButtonCounter />vu
templaIn SFCs, it's recommended to use PascalCase tag names for child components to
differentiate from native HTML elements. Although native HTML tag names are case-
insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in
it. We are also able to use /> to close a tag.
If you are authoring your templates directly in a DOM (e.g. as the content of a native
<template> element), the template will be subject to the browser's native HTML parsing
behavior. In such cases, you will need to use kebab-case and explicit closing tags for
components:
See DOM template parsing caveats for more details.
If we are building a blog, we will likely need a component representing a blog post. We want
all the blog posts to share the same visual layout, but with different content. Such a
component won't be useful unless you can pass data to it, such as the title and content of
the specific post we want to display. That's where props come in.
Props are custom attributes you can register on a component. To pass a title to our blog
post component, we must declare it in the list of props this component accepts, using the
defineProps macro:Passing Props<!-- if this template is written in the DOM -->
<button-counter></button-counter>
<button-counter></button-counter>
<button-counter></button-counter>templadefineProps is a compile-time macro that is only available inside <script setup> and
does not need to be explicitly imported. Declared props are automatically exposed to the
template. defineProps also returns an object that contains all the props passed to the
component, so that we can access them in JavaScript if needed:
See also: Typing Component Props
If you are not using <script setup>, props should be declared using the props option,
and the props object will be passed to setup() as the first argument:
A component can have as many props as you like and, by default, any value can be passed
to any prop.
Once a prop is registered, you can pass data to it as a custom attribute, like this:TS<!-- BlogPost.vue -->
<script setup>
defineProps(['title'])
</script>
<template>
  <h4>{{ title }}</h4>
</template>
const props = defineProps(['title'])
console.log(props.title)
export default {
  props: ['title'],
  setup(props) {
    console.log(props.title)
  }
}vuIn a typical app, however, you'll likely have an array of posts in your parent component:
Then want to render a component for each one, using v-for:
Try it in the Playground
Notice how v-bind is used to pass dynamic prop values. This is especially useful when you
don't know the exact content you're going to render ahead of time.
That's all you need to know about props for now, but once you've finished reading this page
and feel comfortable with its content, we recommend coming back later to read the full
guide on Props.
As we develop our <BlogPost> component, some features may require communicating
back up to the parent. For example, we may decide to include an accessibility feature to
enlarge the text of blog posts, while leaving the rest of the page at its default size.▶
Listening to Events<BlogPost title="My journey with Vue" />
<BlogPost title="Blogging with Vue" />
<BlogPost title="Why Vue is so fun" />
const posts = ref([
  { id: 1, title: 'My journey with Vue' },
  { id: 2, title: 'Blogging with Vue' },
  { id: 3, title: 'Why Vue is so fun' }
])
<BlogPost
  v-for="post in posts"
  :key="post.id"
  :title="post.title"
 />templa
templaIn the parent, we can support this feature by adding a postFontSizeref:
Which can be used in the template to control the font size of all blog posts:
Now let's add a button to the <BlogPost> component's template:
The button doesn't do anything yet - we want clicking the button to communicate to the
parent that it should enlarge the text of all posts. To solve this problem, components provide
a custom events system. The parent can choose to listen to any event on the child
component instance with v-on or @, just as we would with a native DOM event:const posts = ref([
  /* ... */
])
const postFontSize = ref(1)
<div :style="{ fontSize: postFontSize + 'em' }">
  <BlogPost
    v-for="post in posts"
    :key="post.id"
    :title="post.title"
   />
</div>
<!-- BlogPost.vue, omitting <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button>Enlarge text</button>
  </div>
</template>
<BlogPost
  ...
  @enlarge-text="postFontSize += 0.1"
 />templa
vu
templaThen the child component can emit an event on itself by calling the built-in $emit method,
passing the name of the event:
Thanks to the @enlarge-text="postFontSize += 0.1" listener, the parent will receive the
event and update the value of postFontSize.
Try it in the Playground
We can optionally declare emitted events using the defineEmits macro:
This documents all the events that a component emits and optionally validates them. It also
allows Vue to avoid implicitly applying them as native listeners to the child component's root
element.
Similar to defineProps, defineEmits is only usable in <script setup> and doesn't
need to be imported. It returns an emit function that is equivalent to the $emit method.
It can be used to emit events in the <script setup> section of a component, where
$emit isn't directly accessible:▶<!-- BlogPost.vue, omitting <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Enlarge text</button>
  </div>
</template>
<!-- BlogPost.vue -->
<script setup>
defineProps(['title'])
defineEmits(['enlarge-text'])
</script>
<script setup>
const emit = defineEmits(['enlarge-text'])
emit('enlarge-text')
</script>vu
vu
vuSee also: Typing Component Emits
If you are not using <script setup>, you can declare emitted events using the emits
option. You can access the emit function as a property of the setup context (passed to
setup() as the second argument):
That's all you need to know about custom component events for now, but once you've
finished reading this page and feel comfortable with its content, we recommend coming
back later to read the full guide on Custom Events.
Just like with HTML elements, it's often useful to be able to pass content to a component,
like this:
Which might render something like:
This can be achieved using Vue's custom <slot> element:TS
Content Distribution with Slots
This is an Error for Demo Purposes
Something bad happened.⚠export default {
  emits: ['enlarge-text'],
  setup(props, ctx) {
    ctx.emit('enlarge-text')
  }
}
<AlertBox>
  Something bad happened.
</AlertBox>templaAs you'll see above, we use the <slot> as a placeholder where we want the content to go
– and that's it. We're done!
Try it in the Playground
That's all you need to know about slots for now, but once you've finished reading this page
and feel comfortable with its content, we recommend coming back later to read the full
guide on Slots.
Sometimes, it's useful to dynamically switch between components, like in a tabbed
interface:
Open example in the Playground
The above is made possible by Vue's <component> element with the special is attribute:
In the example above, the value passed to :is can contain either:▶
Dynamic Components
▶<template>
  <div class="alert-box">
    <strong>This is an Error for Demo Purposes</strong>
    <slot />
  </div>
</template>
<style scoped>
.alert-box {
  /* ... */
}
</style>
<!-- Component changes when currentTab changes -->
<component :is="tabs[currentTab]"></component>vu
templaYou can also use the is attribute to create regular HTML elements.
When switching between multiple components with <component :is="...">, a component
will be unmounted when it is switched away from. We can force the inactive components to
stay "alive" with the built-in <KeepAlive> component.
If you are writing your Vue templates directly in the DOM, Vue will have to retrieve the
template string from the DOM. This leads to some caveats due to browsers' native HTML
parsing behavior.
HTML tags and attribute names are case-insensitive, so browsers will interpret any
uppercase characters as lowercase. That means when youʼre using in-DOM templates,
PascalCase component names and camelCased prop names or v-on event names all need
to use their kebab-cased (hyphen-delimited) equivalents:the name string of a registered component, OR
the actual imported component object
DOM Template Parsing Caveats
TIP
It should be noted that the limitations discussed below only apply if you are writing your
templates directly in the DOM. They do NOT apply if you are using string templates from
the following sources:ⓘ
Single-File Components
Inlined template strings (e.g. template: '...')
<script type="text/x-template">
Case InsensitivityWe have been using self-closing tags for components in previous code samples:
This is because Vue's template parser respects /> as an indication to end any tag,
regardless of its type.
In DOM templates, however, we must always include explicit closing tags:
This is because the HTML spec only allows a few specific elements to omit closing tags,
the most common being <input> and <img>. For all other elements, if you omit the
closing tag, the native HTML parser will think you never terminated the opening tag. For
example, the following snippet:
will be parsed as:Self Closing Tags// camelCase in JavaScript
const BlogPost = {
  props: ['postTitle'],
  emits: ['updatePost'],
  template: `
    <h3>{{ postTitle }}</h3>
  `
}
<!-- kebab-case in HTML -->
<blog-post post-title="hello!" @update-post="onUpdatePost"></blog-post>
<MyComponent />
<my-component></my-component>
<my-component /> <!-- we intend to close the tag here... -->
<span>hello</span>templa
templa
templa
templaSome HTML elements, such as <ul>, <ol>, <table> and <select> have restrictions
on what elements can appear inside them, and some elements such as <li>, <tr>, and
<option> can only appear inside certain other elements.
This will lead to issues when using components with elements that have such restrictions.
For example:
The custom component <blog-post-row> will be hoisted out as invalid content, causing
errors in the eventual rendered output. We can use the special is attribute as a
workaround:
That's all you need to know about DOM template parsing caveats for now - and actually, the
end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend
taking a break to play with Vue yourself - build something fun, or check out some of the
Examples if you haven't already.Element Placement Restrictions
TIP
When used on native HTML elements, the value of is must be prefixed with vue: in
order to be interpreted as a Vue component. This is required to avoid confusion with
native customized built-in elements.ⓘ<my-component>
  <span>hello</span>
</my-component> <!-- but the browser will close it here. -->
<table>
  <blog-post-row></blog-post-row>
</table>
<table>
  <tr is="vue:blog-post-row"></tr>
</table>templa
templa
templaOnce you feel comfortable with the knowledge you've just digested, move on with the guide
to learn more about components in depth.This page assumes you've already read the Components Basics. Read that first if you are
new to components.
A Vue component needs to be "registered" so that Vue knows where to locate its
implementation when it is encountered in a template. There are two ways to register
components: global and local.
We can make components available globally in the current Vue application using the
app.component() method:
If using SFCs, you will be registering the imported .vue files:
The app.component() method can be chained:Component Registration
Global Registration
import { createApp } from 'vue'
const app = createApp({})
app.component(
  // the registered name
  'MyComponent',
  // the implementation
  {
    /* ... */
  }
)
import MyComponent from './App.vue'
app.component('MyComponent', MyComponent)Globally registered components can be used in the template of any component within this
application:
This even applies to all subcomponents, meaning all three of these components will also be
available inside each other.
While convenient, global registration has a few drawbacks:
Local registration scopes the availability of the registered components to the current
component only. It makes the dependency relationship more explicit, and is more tree-
shaking friendly.
When using SFC with <script setup>, imported components can be locally used without
registration:Local Registration
Global registration prevents build systems from removing unused components (a.k.a
"tree-shaking"). If you globally register a component but end up not using it anywhere in
your app, it will still be included in the final bundle.1.
Global registration makes dependency relationships less explicit in large applications. It
makes it difficult to locate a child component's implementation from a parent component
using it. This can affect long-term maintainability similar to using too many global
variables.2.app
  .component('ComponentA', ComponentA)
  .component('ComponentB', ComponentB)
  .component('ComponentC', ComponentC)
<!-- this will work in any component inside the app -->
<ComponentA/>
<ComponentB/>
<ComponentC/>templaIn non-<script setup>, you will need to use the components option:
For each property in the components object, the key will be the registered name of the
component, while the value will contain the implementation of the component. The above
example is using the ES2015 property shorthand and is equivalent to:
Note that locally registered components are not also available in descendant
components. In this case, ComponentA will be made available to the current component
only, not any of its child or descendant components.
Component Name Casing<script setup>
import ComponentA from './ComponentA.vue'
</script>
<template>
  <ComponentA />
</template>
import ComponentA from './ComponentA.js'
export default {
  components: {
    ComponentA
  },
  setup() {
    // ...
  }
}
export default {
  components: {
    ComponentA: ComponentA
  }
  // ...
}vuThroughout the guide, we are using PascalCase names when registering components. This
is because:
This is the recommended style when working with SFC or string templates. However, as
discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM
templates.
Luckily, Vue supports resolving kebab-case tags to components registered using
PascalCase. This means a component registered as MyComponent can be referenced in the
template via both <MyComponent> and <my-component>. This allows us to use the same
JavaScript component registration code regardless of template source.PascalCase names are valid JavaScript identifiers. This makes it easier to import and
register components in JavaScript. It also helps IDEs with auto-completion.1.
<PascalCase /> makes it more obvious that this is a Vue component instead of a native
HTML element in templates. It also differentiates Vue components from custom elements
(web components).2.This page assumes you've already read the Components Basics. Read that first if you are
new to components.
Vue components require explicit props declaration so that Vue knows what external props
passed to the component should be treated as fallthrough attributes (which will be
discussed in its dedicated section).
In SFCs using <script setup>, props can be declared using the defineProps() macro:
In non-<script setup> components, props are declared using the props option:
Notice the argument passed to defineProps() is the same as the value provided to the
props options: the same props options API is shared between the two declaration styles.
In addition to declaring props using an array of strings, we can also use the object syntax:Props
Props Declaration
<script setup>
const props = defineProps(['foo'])
console.log(props.foo)
</script>
export default {
  props: ['foo'],
  setup(props) {
    // setup() receives props as the first argument.
    console.log(props.foo)
  }
}vuFor each property in the object declaration syntax, the key is the name of the prop, while the
value should be the constructor function of the expected type.
This not only documents your component, but will also warn other developers using your
component in the browser console if they pass the wrong type. We will discuss more details
about prop validation further down this page.
If you are using TypeScript with <script setup>, it's also possible to declare props using
pure type annotations:
More details: Typing Component PropsTS
Prop Passing Details// in <script setup>
defineProps({
  title: String,
  likes: Number
})
// in non-<script setup>
export default {
  props: {
    title: String,
    likes: Number
  }
}
<script setup lang="ts">
defineProps<{
  title?: string
  likes?: number
}>()
</script>vuWe declare long prop names using camelCase because this avoids having to use quotes
when using them as property keys, and allows us to reference them directly in template
expressions because they are valid JavaScript identifiers:
Technically, you can also use camelCase when passing props to a child component (except
in DOM templates). However, the convention is using kebab-case in all cases to align with
HTML attributes:
We use PascalCase for component tags when possible because it improves template
readability by differentiating Vue components from native elements. However, there isn't as
much practical benefit in using camelCase when passing props, so we choose to follow each
language's conventions.
So far, you've seen props passed as static values, like in:
You've also seen props assigned dynamically with v-bind or its : shortcut, such as in:Prop Name Casing
Static vs. Dynamic PropsdefineProps({
  greetingMessage: String
})
<span>{{ greetingMessage }}</span>
<MyComponent greeting-message="hello" />
<BlogPost title="My journey with Vue" />templa
templa
templaIn the two examples above, we happen to pass string values, but any type of value can be
passed to a prop.Passing Different Value Types
Number
Boolean
Array<!-- Dynamically assign the value of a variable -->
<BlogPost :title="post.title" />
<!-- Dynamically assign the value of a complex expression -->
<BlogPost :title="post.title + ' by ' + post.author.name" />
<!-- Even though `42` is static, we need v-bind to tell Vue that -->
<!-- this is a JavaScript expression rather than a string.       -->
<BlogPost :likes="42" />
<!-- Dynamically assign to the value of a variable. -->
<BlogPost :likes="post.likes" />
<!-- Including the prop with no value will imply `true`. -->
<BlogPost is-published />
<!-- Even though `false` is static, we need v-bind to tell Vue that -->
<!-- this is a JavaScript expression rather than a string.          -->
<BlogPost :is-published="false" />
<!-- Dynamically assign to the value of a variable. -->
<BlogPost :is-published="post.isPublished" />templa
templa
templaIf you want to pass all the properties of an object as props, you can use v-bind without an
argument (v-bind instead of :prop-name). For example, given a post object:
The following template:
Will be equivalent to:Object
Binding Multiple Properties Using an Object<!-- Even though the array is static, we need v-bind to tell Vue that -->
<!-- this is a JavaScript expression rather than a string.            -->
<BlogPost :comment-ids="[234, 266, 273]" />
<!-- Dynamically assign to the value of a variable. -->
<BlogPost :comment-ids="post.commentIds" />
<!-- Even though the object is static, we need v-bind to tell Vue that -->
<!-- this is a JavaScript expression rather than a string.             -->
<BlogPost
  :author="{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }"
 />
<!-- Dynamically assign to the value of a variable. -->
<BlogPost :author="post.author" />
const post = {
  id: 1,
  title: 'My Journey with Vue'
}
<BlogPost v-bind="post" />templa
templa
templaAll props form a one-way-down binding between the child property and the parent one:
when the parent property updates, it will flow down to the child, but not the other way
around. This prevents child components from accidentally mutating the parent's state,
which can make your app's data flow harder to understand.
In addition, every time the parent component is updated, all props in the child component
will be refreshed with the latest value. This means you should not attempt to mutate a prop
inside a child component. If you do, Vue will warn you in the console:
There are usually two cases where it's tempting to mutate a prop:One-Way Data Flow
The prop is used to pass in an initial value; the child component wants to use it as a
local data property afterwards. In this case, it's best to define a local data property
that uses the prop as its initial value:1.
The prop is passed in as a raw value that needs to be transformed. In this case, it's
best to define a computed property using the prop's value:2.<BlogPost :id="post.id" :title="post.title" />
const props = defineProps(['foo'])
// ❌ warning, props are readonly!
props.foo = 'bar'
const props = defineProps(['initialCounter'])
// counter only uses props.initialCounter as the initial value;
// it is disconnected from future prop updates.
const counter = ref(props.initialCounter)templaWhen objects and arrays are passed as props, while the child component cannot mutate the
prop binding, it will be able to mutate the object or array's nested properties. This is
because in JavaScript objects and arrays are passed by reference, and it is unreasonably
expensive for Vue to prevent such mutations.
The main drawback of such mutations is that it allows the child component to affect parent
state in a way that isn't obvious to the parent component, potentially making it more difficult
to reason about the data flow in the future. As a best practice, you should avoid such
mutations unless the parent and child are tightly coupled by design. In most cases, the child
should emit an event to let the parent perform the mutation.
Components can specify requirements for their props, such as the types you've already
seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This
is especially useful when developing a component that is intended to be used by others.
To specify prop validations, you can provide an object with validation requirements to the
defineProps() macro, instead of an array of strings. For example:Mutating Object / Array Props
Prop Validationconst props = defineProps(['size'])
// computed property that auto-updates when the prop changes
const normalizedSize = computed(() => props.size.trim().toLowerCase())defineProps({
  // Basic type check
  //  (`null` and `undefined` values will allow any type)
  propA: Number,
  // Multiple possible types
  propB: [String, Number],
  // Required string
  propC: {
    type: String,
    required: true
  },
  // Number with a default value
  propD: {
    type: Number,
    default: 100
  },
  // Object with a default value
  propE: {
    type: Object,
    // Object or array defaults must be returned from
    // a factory function. The function receives the raw
    // props received by the component as the argument.
    default(rawProps) {
      return { message: 'hello' }
    }
  },
  // Custom validator function
  propF: {
    validator(value) {
      // The value must match one of these strings
      return ['success', 'warning', 'danger'].includes(value)
    }
  },
  // Function with a default value
  propG: {
    type: Function,
    // Unlike object or array default, this is not a factory function - this 
    default() {
      return 'Default function'
    }
  }
})Additional details:
When prop validation fails, Vue will produce a console warning (if using the development
build).
If using Type-based props declarations, Vue will try its best to compile the type
annotations into equivalent runtime prop declarations. For example, defineProps<{ msg:
string }> will be compiled into { msg: { type: String, required: true }}.
The type can be one of the following native constructors:TIP
Code inside the defineProps() argument cannot access other variables declared in
<script setup>, because the entire expression is moved to an outer function scope
when compiled.ⓘ
All props are optional by default, unless required: true is specified.
An absent optional prop other than Boolean will have undefined value.
The Boolean absent props will be cast to false. You can change this by setting a
default for it — i.e.: default: undefined to behave as a non-Boolean prop.
If a default value is specified, it will be used if the resolved prop value is undefined -
this includes both when the prop is absent, or an explicit undefined value is passed.
TS
Runtime Type Checks
String
Number
Boolean
Array
Object
Date
Function
SymbolIn addition, type can also be a custom class or constructor function and the assertion will
be made with an instanceof check. For example, given the following class:
You could use it as a prop's type:
Vue will use instanceof Person to validate whether the value of the author prop is
indeed an instance of the Person class.
Props with Boolean type have special casting rules to mimic the behavior of native boolean
attributes. Given a <MyComponent> with the following declaration:
The component can be used like this:Boolean Castingclass Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
}
defineProps({
  author: Person
})
defineProps({
  disabled: Boolean
})When a prop is declared to allow multiple types, e.g.
The casting rules for Boolean will apply regardless of type appearance order.<!-- equivalent of passing :disabled="true" -->
<MyComponent disabled />
<!-- equivalent of passing :disabled="false" -->
<MyComponent />
defineProps({
  disabled: [Boolean, Number]
})templaThis page assumes you've already read the Components Basics. Read that first if you are
new to components.
A component can emit custom events directly in template expressions (e.g. in a v-on
handler) using the built-in $emit method:
The parent can then listen to it using v-on:
The .once modifier is also supported on component event listeners:
Like components and props, event names provide an automatic case transformation. Notice
we emitted a camelCase event, but can listen for it using a kebab-cased listener in the
parent. As with props casing, we recommend using kebab-cased event listeners in
templates.Component Events
Emitting and Listening to Events
<!-- MyComponent -->
<button @click="$emit('someEvent')">click me</button>
<MyComponent @some-event="callback" />
<MyComponent @some-event.once="callback" />templa
templa
templaIt's sometimes useful to emit a specific value with an event. For example, we may want the
<BlogPost> component to be in charge of how much to enlarge the text by. In those cases,
we can pass extra arguments to $emit to provide this value:
Then, when we listen to the event in the parent, we can use an inline arrow function as the
listener, which allows us to access the event argument:
Or, if the event handler is a method:
Then the value will be passed as the first parameter of that method:TIP
Unlike native DOM events, component emitted events do not bubble. You can only listen
to the events emitted by a direct child component. If there is a need to communicate
between sibling or deeply nested components, use an external event bus or a global state
management solution.ⓘ
Event Arguments
<button @click="$emit('increaseBy', 1)">
  Increase by 1
</button>
<MyButton @increase-by="(n) => count += n" />
<MyButton @increase-by="increaseCount" />
function increaseCount(n) {
  count.value += n
}templa
templa
templaA component can explicitly declare the events it will emit using the defineEmits() macro:
The $emit method that we used in the <template> isn't accessible within the <script
setup> section of a component, but defineEmits() returns an equivalent function that
we can use instead:
The defineEmits() macro cannot be used inside a function, it must be placed directly
within <script setup>, as in the example above.
If you're using an explicit setup function instead of <script setup>, events should be
declared using the emits option, and the emit function is exposed on the setup()
context:TIP
All extra arguments passed to $emit() after the event name will be forwarded to the
listener. For example, with $emit('foo', 1, 2, 3) the listener function will receive
three arguments.ⓘ
Declaring Emitted Events
<script setup>
defineEmits(['inFocus', 'submit'])
</script>
<script setup>
const emit = defineEmits(['inFocus', 'submit'])
function buttonClick() {
  emit('submit')
}
</script>vu
vuAs with other properties of the setup() context, emit can safely be destructured:
The emits option also supports an object syntax, which allows us to perform runtime
validation of the payload of the emitted events:
If you are using TypeScript with <script setup>, it's also possible to declare emitted
events using pure type annotations:
More details: Typing Component EmitsTSexport default {
  emits: ['inFocus', 'submit'],
  setup(props, ctx) {
    ctx.emit('submit')
  }
}
export default {
  emits: ['inFocus', 'submit'],
  setup(props, { emit }) {
    emit('submit')
  }
}
<script setup>
const emit = defineEmits({
  submit(payload) {
    // return `true` or `false` to indicate
    // validation pass / fail
  }
})
</script>
<script setup lang="ts">
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>vu
vuAlthough optional, it is recommended to define all emitted events in order to better
document how a component should work. It also allows Vue to exclude known listeners from
fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by
3rd party code.
Similar to prop type validation, an emitted event can be validated if it is defined with the
object syntax instead of the array syntax.
To add validation, the event is assigned a function that receives the arguments passed to
the emit call and returns a boolean to indicate whether the event is valid or not.TIP
If a native event (e.g., click) is defined in the emits option, the listener will now only
listen to component-emitted click events and no longer respond to native click
events.ⓘ
Events Validation<script setup>
const emit = defineEmits({
  // No validation
  click: null,
  // Validate submit event
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  }
})
function submitForm(email, password) {
  emit('submit', { email, password })
}
</script>vuv-model can be used on a component to implement a two-way binding.
First let's revisit how v-model is used on a native element:
Under the hood, the template compiler expands v-model to the more verbose equivalent
for us. So the above code does the same as the following:
When used on a component, v-model instead expands to this:
For this to actually work though, the <CustomInput> component must do two things:
Here's that in action:Component v-model
Bind the value attribute of a native <input> element to the modelValue prop 1.
When a native input event is triggered, emit an update:modelValue custom event
with the new value2.<input v-model="searchText" />
<input
  :value="searchText"
  @input="searchText = $event.target.value"
/>
<CustomInput
  :modelValue="searchText"
  @update:modelValue="newValue => searchText = newValue"
/>templa
templa
templaNow v-model should work perfectly with this component:
Try it in the Playground
Another way of implementing v-model within this component is to use a writable
computed property with both a getter and a setter. The get method should return the
modelValue property and the set method should emit the corresponding event:▶<!-- CustomInput.vue -->
<script setup>
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
</script>
<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>
<CustomInput v-model="searchText" />vu
templaBy default, v-model on a component uses modelValue as the prop and
update:modelValue as the event. We can modify these names passing an argument to v-
model:
In this case, the child component should expect a title prop and emit an update:title
event to update the parent value:v-model arguments<!-- CustomInput.vue -->
<script setup>
import { computed } from 'vue'
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])
const value = computed({
  get() {
    return props.modelValue
  },
  set(value) {
    emit('update:modelValue', value)
  }
})
</script>
<template>
  <input v-model="value" />
</template>
<MyComponent v-model:title="bookTitle" />vu
templaTry it in the Playground
By leveraging the ability to target a particular prop and event as we learned before with v-
model arguments, we can now create multiple v-model bindings on a single component
instance.
Each v-model will sync to a different prop, without the need for extra options in the
component:▶
Multiple v-model bindings<!-- MyComponent.vue -->
<script setup>
defineProps(['title'])
defineEmits(['update:title'])
</script>
<template>
  <input
    type="text"
    :value="title"
    @input="$emit('update:title', $event.target.value)"
  />
</template>
<UserName
  v-model:first-name="first"
  v-model:last-name="last"
/>vu
templaTry it in the Playground
When we were learning about form input bindings, we saw that v-model has built-in
modifiers - .trim, .number and .lazy. In some cases, you might also want the v-
model on your custom input component to support custom modifiers.
Let's create an example custom modifier, capitalize, that capitalizes the first letter of the
string provided by the v-model binding:
Modifiers added to a component v-model will be provided to the component via the
modelModifiers prop. In the below example, we have created a component that contains a
modelModifiers prop that defaults to an empty object:▶
Handling v-model modifiers<script setup>
defineProps({
  firstName: String,
  lastName: String
})
defineEmits(['update:firstName', 'update:lastName'])
</script>
<template>
  <input
    type="text"
    :value="firstName"
    @input="$emit('update:firstName', $event.target.value)"
  />
  <input
    type="text"
    :value="lastName"
    @input="$emit('update:lastName', $event.target.value)"
  />
</template>
<MyComponent v-model.capitalize="myText" />vu
templaNotice the component's modelModifiers prop contains capitalize and its value is
true - due to it being set on the v-model binding v-model.capitalize="myText".
Now that we have our prop set up, we can check the modelModifiers object keys and
write a handler to change the emitted value. In the code below we will capitalize the string
whenever the <input /> element fires an input event.<script setup>
const props = defineProps({
  modelValue: String,
  modelModifiers: { default: () => ({}) }
})
defineEmits(['update:modelValue'])
console.log(props.modelModifiers) // { capitalize: true }
</script>
<template>
  <input
    type="text"
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>vuTry it in the Playground
For v-model bindings with both argument and modifiers, the generated prop name will be
arg + "Modifiers". For example:
The corresponding declarations should be:▶<script setup>
const props = defineProps({
  modelValue: String,
  modelModifiers: { default: () => ({}) }
})
const emit = defineEmits(['update:modelValue'])
function emitValue(e) {
  let value = e.target.value
  if (props.modelModifiers.capitalize) {
    value = value.charAt(0).toUpperCase() + value.slice(1)
  }
  emit('update:modelValue', value)
}
</script>
<template>
  <input type="text" :value="modelValue" @input="emitValue" />
</template>
<MyComponent v-model:title.capitalize="myText">
const props = defineProps(['title', 'titleModifiers'])
defineEmits(['update:title'])
console.log(props.titleModifiers) // { capitalize: true }vu
templaThis page assumes you've already read the Components Basics. Read that first if you are
new to components.
A "fallthrough attribute" is an attribute or v-on event listener that is passed to a
component, but is not explicitly declared in the receiving component's props or emits.
Common examples of this include class, style, and id attributes.
When a component renders a single root element, fallthrough attributes will be automatically
added to the root element's attributes. For example, given a <MyButton> component with
the following template:
And a parent using this component with:
The final rendered DOM would be:
Here, <MyButton> did not declare class as an accepted prop. Therefore, class is
treated as a fallthrough attribute and automatically added to <MyButton>'s root element.Fallthrough Attributes
Attribute Inheritance
class and style Merging<!-- template of <MyButton> -->
<button>click me</button>
<MyButton class="large" />
<button class="large">click me</button>templa
templa
htmIf the child component's root element already has existing class or style attributes, it
will be merged with the class and style values that are inherited from the parent.
Suppose we change the template of <MyButton> in the previous example to:
Then the final rendered DOM would now become:
The same rule applies to v-on event listeners:
The click listener will be added to the root element of <MyButton>, i.e. the native
<button> element. When the native <button> is clicked, it will trigger the onClick
method of the parent component. If the native <button> already has a click listener
bound with v-on, then both listeners will trigger.
If a component renders another component as its root node, for example, we refactored
<MyButton> to render a <BaseButton> as its root:
Then the fallthrough attributes received by <MyButton> will be automatically forwarded to
<BaseButton>.v-on Listener Inheritance
Nested Component Inheritance<!-- template of <MyButton> -->
<button class="btn">click me</button>
<button class="btn large">click me</button>
<MyButton @click="onClick" />
<!-- template of <MyButton/> that simply renders another component -->
<BaseButton />templa
htm
templa
templaNote that:
If you do not want a component to automatically inherit attributes, you can set
inheritAttrs: false in the component's options.
If using <script setup>, you will need to declare this option using a separate, normal
<script> block:
The common scenario for disabling attribute inheritance is when attributes need to be
applied to other elements besides the root node. By setting the inheritAttrs option to
false, you can take full control over where the fallthrough attributes should be applied.
These fallthrough attributes can be accessed directly in template expressions as $attrs:Forwarded attributes do not include any attributes that are declared as props, or v-on
listeners of declared events by <MyButton> - in other words, the declared props and
listeners have been "consumed" by <MyButton>.1.
Forwarded attributes may be accepted as props by <BaseButton>, if declared by it. 2.
Disabling Attribute Inheritance
<script>
// use normal <script> to declare options
export default {
  inheritAttrs: false
}
</script>
<script setup>
// ...setup logic
</script>
<span>Fallthrough attributes: {{ $attrs }}</span>vu
templaThe $attrs object includes all attributes that are not declared by the component's props
or emits options (e.g., class, style, v-on listeners, etc.).
Some notes:
Using our <MyButton> component example from the previous section - sometimes we
may need to wrap the actual <button> element with an extra <div> for styling purposes:
We want all fallthrough attributes like class and v-on listeners to be applied to the inner
<button>, not the outer <div>. We can achieve this with inheritAttrs: false and v-
bind="$attrs":
Remember that v-bind without an argument binds all the properties of an object as
attributes of the target element.
Unlike components with a single root node, components with multiple root nodes do not
have an automatic attribute fallthrough behavior. If $attrs are not bound explicitly, a
runtime warning will be issued.Unlike props, fallthrough attributes preserve their original casing in JavaScript, so an
attribute like foo-bar needs to be accessed as $attrs['foo-bar'].
A v-on event listener like @click will be exposed on the object as a function under
$attrs.onClick.
Attribute Inheritance on Multiple Root Nodes<div class="btn-wrapper">
  <button class="btn">click me</button>
</div>
<div class="btn-wrapper">
  <button class="btn" v-bind="$attrs">click me</button>
</div>templa
templaIf <CustomLayout> has the following multi-root template, there will be a warning because
Vue cannot be sure where to apply the fallthrough attributes:
The warning will be suppressed if $attrs is explicitly bound:
If needed, you can access a component's fallthrough attributes in <script setup> using
the useAttrs() API:
If not using <script setup>, attrs will be exposed as a property of the setup()
context:Accessing Fallthrough Attributes in JavaScript<CustomLayout id="custom-layout" @click="changeValue" />
<header>...</header>
<main>...</main>
<footer>...</footer>
<header>...</header>
<main v-bind="$attrs">...</main>
<footer>...</footer>
<script setup>
import { useAttrs } from 'vue'
const attrs = useAttrs()
</script>templa
templa
templa
vuNote that although the attrs object here always reflects the latest fallthrough attributes, it
isn't reactive (for performance reasons). You cannot use watchers to observe its changes. If
you need reactivity, use a prop. Alternatively, you can use onUpdated() to perform side
effects with the latest attrs on each update.export default {
  setup(props, ctx) {
    // fallthrough attributes are exposed as ctx.attrs
    console.log(ctx.attrs)
  }
}This page assumes you've already read the Components Basics. Read that first if you are
new to components.
We have learned that components can accept props, which can be JavaScript values of any
type. But how about template content? In some cases, we may want to pass a template
fragment to a child component, and let the child component render the fragment within its
own template.
For example, we may have a <FancyButton> component that supports usage like this:
The template of <FancyButton> looks like this:
The <slot> element is a slot outlet that indicates where the parent-provided slot content
should be rendered.Slots
Slot Content and Outlet
<FancyButton>
  Click me! <!-- slot content -->
</FancyButton>
<button class="fancy-btn">
  <slot></slot> <!-- slot outlet -->
</button>templa
templaAnd the final rendered DOM:
Try it in the Playground
With slots, the <FancyButton> is responsible for rendering the outer <button> (and its
fancy styling), while the inner content is provided by the parent component.
Another way to understand slots is by comparing them to JavaScript functions:
Slot content is not just limited to text. It can be any valid template content. For example, we
can pass in multiple elements, or even other components:▶<button class="fancy-btn">Click me!</button>
// parent component passing slot content
FancyButton('Click me!')
// FancyButton renders slot content in its own template
function FancyButton(slotContent) {
  return `<button class="fancy-btn">
      ${slotContent}
    </button>`
}htmTry it in the Playground
By using slots, our <FancyButton> is more flexible and reusable. We can now use it in
different places with different inner content, but all with the same fancy styling.
Vue components' slot mechanism is inspired by the native Web Component <slot>
element, but with additional capabilities that we will see later.
Slot content has access to the data scope of the parent component, because it is defined in
the parent. For example:
Here both {{ message }} interpolations will render the same content.
Slot content does not have access to the child component's data. Expressions in Vue
templates can only access the scope it is defined in, consistent with JavaScript's lexical
scoping. In other words:
Expressions in the parent template only have access to the parent scope; expressions in
the child template only have access to the child scope.▶
Render Scope
Fallback Content<FancyButton>
  <span style="color:red">Click me!</span>
  <AwesomeIcon name="plus" />
</FancyButton>
<span>{{ message }}</span>
<FancyButton>{{ message }}</FancyButton>templa
templaThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be
rendered only when no content is provided. For example, in a <SubmitButton> component:
We might want the text "Submit" to be rendered inside the <button> if the parent didn't
provide any slot content. To make "Submit" the fallback content, we can place it in between
the <slot> tags:
Now when we use <SubmitButton> in a parent component, providing no content for the
slot:
This will render the fallback content, "Submit":
But if we provide content:
Then the provided content will be rendered instead:<button type="submit">
  <slot></slot>
</button>
<button type="submit">
  <slot>
    Submit <!-- fallback content -->
  </slot>
</button>
<SubmitButton />
<button type="submit">Submit</button>
<SubmitButton>Save</SubmitButton>
<button type="submit">Save</button>templa
templa
templa
htm
templa
htmTry it in the Playground
There are times when it's useful to have multiple slot outlets in a single component. For
example, in a <BaseLayout> component with the following template:
For these cases, the <slot> element has a special attribute, name, which can be used to
assign a unique ID to different slots so you can determine where content should be
rendered:
A <slot> outlet without name implicitly has the name "default".▶
Named Slots
<div class="container">
  <header>
    <!-- We want header content here -->
  </header>
  <main>
    <!-- We want main content here -->
  </main>
  <footer>
    <!-- We want footer content here -->
  </footer>
</div>
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>templa
templaIn a parent component using <BaseLayout>, we need a way to pass multiple slot content
fragments, each targeting a different slot outlet. This is where named slots come in.
To pass a named slot, we need to use a <template> element with the v-slot directive,
and then pass the name of the slot as an argument to v-slot:
v-slot has a dedicated shorthand #, so <template v-slot:header> can be shortened
to just <template #header>. Think of it as "render this template fragment in the child
component's 'header' slot".
Here's the code passing content for all three slots to <BaseLayout> using the shorthand
syntax:<BaseLayout>
  <template v-slot:header>
    <!-- content for the header slot -->
  </template>
</BaseLayout>templaWhen a component accepts both a default slot and named slots, all top-level non-
<template> nodes are implicitly treated as content for the default slot. So the above can
also be written as:
Now everything inside the <template> elements will be passed to the corresponding slots.
The final rendered HTML will be:<BaseLayout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>
  <template #default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>
  <template #footer>
    <p>Here's some contact info</p>
  </template>
</BaseLayout>
<BaseLayout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>
  <!-- implicit default slot -->
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>
  <template #footer>
    <p>Here's some contact info</p>
  </template>
</BaseLayout>templa
templaTry it in the Playground
Again, it may help you understand named slots better using the JavaScript function analogy:
Dynamic directive arguments also work on v-slot, allowing the definition of dynamic slot
names:▶
Dynamic Slot Names<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
// passing multiple slot fragments with different names
BaseLayout({
  header: `...`,
  default: `...`,
  footer: `...`
})
// <BaseLayout> renders them in different places
function BaseLayout(slots) {
  return `<div class="container">
      <header>${slots.header}</header>
      <main>${slots.default}</main>
      <footer>${slots.footer}</footer>
    </div>`
}htmDo note the expression is subject to the syntax constraints of dynamic directive arguments.
As discussed in Render Scope, slot content does not have access to state in the child
component.
However, there are cases where it could be useful if a slot's content can make use of data
from both the parent scope and the child scope. To achieve that, we need a way for the child
to pass data to a slot when rendering it.
In fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props
to a component:
Receiving the slot props is a bit different when using a single default slot vs. using named
slots. We are going to show how to receive props using a single default slot first, by using
v-slot directly on the child component tag:Scoped Slots<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
  <!-- with shorthand -->
  <template #[dynamicSlotName]>
    ...
  </template>
</base-layout>
<!-- <MyComponent> template -->
<div>
  <slot :text="greetingMessage" :count="1"></slot>
</div>templa
templaTry it in the Playground
The props passed to the slot by the child are available as the value of the corresponding v-
slot directive, which can be accessed by expressions inside the slot.
You can think of a scoped slot as a function being passed into the child component. The
child component then calls it, passing props as arguments:▶<MyComponent v-slot="slotProps">
  {{ slotProps.text }} {{ slotProps.count }}
</MyComponent>templaIn fact, this is very close to how scoped slots are compiled, and how you would use scoped
slots in manual render functions.
Notice how v-slot="slotProps" matches the slot function signature. Just like with
function arguments, we can use destructuring in v-slot:
Named scoped slots work similarly - slot props are accessible as the value of the v-slot
directive: v-slot:name="slotProps". When using the shorthand, it looks like this:Named Scoped SlotsMyComponent({
  // passing the default slot, but as a function
  default: (slotProps) => {
    return `${slotProps.text} ${slotProps.count}`
  }
})
function MyComponent(slots) {
  const greetingMessage = 'hello'
  return `<div>${
    // call the slot function with props!
    slots.default({ text: greetingMessage, count: 1 })
  }</div>`
}
<MyComponent v-slot="{ text, count }">
  {{ text }} {{ count }}
</MyComponent>templaPassing props to a named slot:
Note the name of a slot won't be included in the props because it is reserved - so the
resulting headerProps would be { message: 'hello' }.
If you are mixing named slots with the default scoped slot, you need to use an explicit
<template> tag for the default slot. Attempting to place the v-slot directive directly on
the component will result in a compilation error. This is to avoid any ambiguity about the
scope of the props of the default slot. For example:
Using an explicit <template> tag for the default slot helps to make it clear that the
message prop is not available inside the other slot:<MyComponent>
  <template #header="headerProps">
    {{ headerProps }}
  </template>
  <template #default="defaultProps">
    {{ defaultProps }}
  </template>
  <template #footer="footerProps">
    {{ footerProps }}
  </template>
</MyComponent>
<slot name="header" message="hello"></slot>
<!-- This template won't compile -->
<template>
  <MyComponent v-slot="{ message }">
    <p>{{ message }}</p>
    <template #footer>
      <!-- message belongs to the default slot, and is not available here -->
      <p>{{ message }}</p>
    </template>
  </MyComponent>
</template>templa
templa
templaYou may be wondering what would be a good use case for scoped slots. Here's an example:
imagine a <FancyList> component that renders a list of items - it may encapsulate the
logic for loading remote data, using the data to display a list, or even advanced features like
pagination or infinite scrolling. However, we want it to be flexible with how each item looks
and leave the styling of each item to the parent component consuming it. So the desired
usage may look like this:
Inside <FancyList>, we can render the same <slot> multiple times with different item
data (notice we are using v-bind to pass an object as slot props):Fancy List Example<template>
  <MyComponent>
    <!-- Use explicit default slot -->
    <template #default="{ message }">
      <p>{{ message }}</p>
    </template>
    <template #footer>
      <p>Here's some contact info</p>
    </template>
  </MyComponent>
</template>
<FancyList :api-url="url" :per-page="10">
  <template #item="{ body, username, likes }">
    <div class="item">
      <p>{{ body }}</p>
      <p>by {{ username }} | {{ likes }} likes</p>
    </div>
  </template>
</FancyList>
<ul>
  <li v-for="item in items">
    <slot name="item" v-bind="item"></slot>
  </li>
</ul>templa
templa
templaTry it in the Playground
The <FancyList> use case we discussed above encapsulates both reusable logic (data
fetching, pagination etc.) and visual output, while delegating part of the visual output to the
consumer component via scoped slots.
If we push this concept a bit further, we can come up with components that only
encapsulate logic and do not render anything by themselves - visual output is fully
delegated to the consumer component with scoped slots. We call this type of component a
Renderless Component.
An example renderless component could be one that encapsulates the logic of tracking the
current mouse position:
Try it in the Playground
While an interesting pattern, most of what can be achieved with Renderless Components
can be achieved in a more efficient fashion with Composition API, without incurring the
overhead of extra component nesting. Later, we will see how we can implement the same
mouse tracking functionality as a Composable.
That said, scoped slots are still useful in cases where we need to both encapsulate logic and
compose visual output, like in the <FancyList> example.▶
Renderless Components
▶<MouseTracker v-slot="{ x, y }">
  Mouse is at: {{ x }}, {{ y }}
</MouseTracker>templaThis page assumes you've already read the Components Basics. Read that first if you are
new to components.
Usually, when we need to pass data from the parent to a child component, we use props.
However, imagine the case where we have a large component tree, and a deeply nested
component needs something from a distant ancestor component. With only props, we would
have to pass the same prop across the entire parent chain:
Notice although the <Footer> component may not care about these props at all, it still
needs to declare and pass them along just so <DeepChild> can access them. If there is a
longer parent chain, more components would be affected along the way. This is called
"props drilling" and definitely isn't fun to deal with.
We can solve props drilling with provide and inject. A parent component can serve as a
dependency provider for all its descendants. Any component in the descendant tree,
regardless of how deep it is, can inject dependencies provided by components up in its
parent chain.Provide / Inject
Prop DrillingTo provide data to a component's descendants, use the provide() function:
If not using <script setup>, make sure provide() is called synchronously inside
setup():Provide
<script setup>
import { provide } from 'vue'
provide(/* key */ 'message', /* value */ 'hello!')
</script>
import { provide } from 'vue'
export default {
  setup() {
    provide(/* key */ 'message', /* value */ 'hello!')
  }
}vuThe provide() function accepts two arguments. The first argument is called the injection
key, which can be a string or a Symbol. The injection key is used by descendant
components to lookup the desired value to inject. A single component can call provide()
multiple times with different injection keys to provide different values.
The second argument is the provided value. The value can be of any type, including reactive
state such as refs:
Providing reactive values allows the descendant components using the provided value to
establish a reactive connection to the provider component.
In addition to providing data in a component, we can also provide at the app level:
App-level provides are available to all components rendered in the app. This is especially
useful when writing plugins, as plugins typically wouldn't be able to provide values using
components.App-level Provide
Injectimport { ref, provide } from 'vue'
const count = ref(0)
provide('key', count)
import { createApp } from 'vue'
const app = createApp({})
app.provide(/* key */ 'message', /* value */ 'hello!')To inject data provided by an ancestor component, use the inject() function:
If the provided value is a ref, it will be injected as-is and will not be automatically
unwrapped. This allows the injector component to retain the reactivity connection to the
provider component.
Full provide + inject Example with Reactivity
Again, if not using <script setup>, inject() should only be called synchronously inside
setup():
By default, inject assumes that the injected key is provided somewhere in the parent
chain. In the case where the key is not provided, there will be a runtime warning.
If we want to make an injected property work with optional providers, we need to declare a
default value, similar to props:▶
Injection Default Values<script setup>
import { inject } from 'vue'
const message = inject('message')
</script>
import { inject } from 'vue'
export default {
  setup() {
    const message = inject('message')
    return { message }
  }
}
// `value` will be "default value"
// if no data matching "message" was provided
const value = inject('message', 'default value')vuIn some cases, the default value may need to be created by calling a function or instantiating
a new class. To avoid unnecessary computation or side effects in case the optional value is
not used, we can use a factory function for creating the default value:
When using reactive provide / inject values, it is recommended to keep any mutations to
reactive state inside of the provider whenever possible. This ensures that the provided
state and its possible mutations are co-located in the same component, making it easier to
maintain in the future.
There may be times when we need to update the data from an injector component. In such
cases, we recommend providing a function that is responsible for mutating the state:Working with Reactivityconst value = inject('key', () => new ExpensiveClass())
<!-- inside provider component -->
<script setup>
import { provide, ref } from 'vue'
const location = ref('North Pole')
function updateLocation() {
  location.value = 'South Pole'
}
provide('location', {
  location,
  updateLocation
})
</script>vuFinally, you can wrap the provided value with readonly() if you want to ensure that the
data passed through provide cannot be mutated by the injector component.
So far, we have been using string injection keys in the examples. If you are working in a large
application with many dependency providers, or you are authoring components that are
going to be used by other developers, it is best to use Symbol injection keys to avoid
potential collisions.
It's recommended to export the Symbols in a dedicated file:Working with Symbol Keys<!-- in injector component -->
<script setup>
import { inject } from 'vue'
const { location, updateLocation } = inject('location')
</script>
<template>
  <button @click="updateLocation">{{ location }}</button>
</template>
<script setup>
import { ref, provide, readonly } from 'vue'
const count = ref(0)
provide('read-only-count', readonly(count))
</script>
// keys.js
export const myInjectionKey = Symbol()vu
vuSee also: Typing Provide / InjectTS// in provider component
import { provide } from 'vue'
import { myInjectionKey } from './keys.js'
provide(myInjectionKey, {
  /* data to provide */
})
// in injector component
import { inject } from 'vue'
import { myInjectionKey } from './keys.js'
const injected = inject(myInjectionKey)In large applications, we may need to divide the app into smaller chunks and only load a
component from the server when it's needed. To make that possible, Vue has a
defineAsyncComponent function:
As you can see, defineAsyncComponent accepts a loader function that returns a Promise.
The Promise's resolve callback should be called when you have retrieved your component
definition from the server. You can also call reject(reason) to indicate the load has failed.
ES module dynamic import also returns a Promise, so most of the time we will use it in
combination with defineAsyncComponent. Bundlers like Vite and webpack also support the
syntax (and will use it as bundle split points), so we can use it to import Vue SFCs:
The resulting AsyncComp is a wrapper component that only calls the loader function when it
is actually rendered on the page. In addition, it will pass along any props and slots to theAsync Components
Basic Usage
import { defineAsyncComponent } from 'vue'
const AsyncComp = defineAsyncComponent(() => {
  return new Promise((resolve, reject) => {
    // ...load component from server
    resolve(/* loaded component */)
  })
})
// ... use `AsyncComp` like a normal component
import { defineAsyncComponent } from 'vue'
const AsyncComp = defineAsyncComponent(() =>
  import('./components/MyComponent.vue')
)inner component, so you can use the async wrapper to seamlessly replace the original
component while achieving lazy loading.
As with normal components, async components can be registered globally using
app.component():
They can also be defined directly inside their parent component:
Asynchronous operations inevitably involve loading and error states -
defineAsyncComponent() supports handling these states via advanced options:Loading and Error Statesapp.component('MyComponent', defineAsyncComponent(() =>
  import('./components/MyComponent.vue')
))
<script setup>
import { defineAsyncComponent } from 'vue'
const AdminPage = defineAsyncComponent(() =>
  import('./components/AdminPageComponent.vue')
)
</script>
<template>
  <AdminPage />
</template>vuIf a loading component is provided, it will be displayed first while the inner component is
being loaded. There is a default 200ms delay before the loading component is shown - this
is because on fast networks, an instant loading state may get replaced too fast and end up
looking like a flicker.
If an error component is provided, it will be displayed when the Promise returned by the
loader function is rejected. You can also specify a timeout to show the error component
when the request is taking too long.
Async components can be used with the <Suspense> built-in component. The interaction
between <Suspense> and async components is documented in the dedicated chapter for
<Suspense>.Using with Suspenseconst AsyncComp = defineAsyncComponent({
  // the loader function
  loader: () => import('./Foo.vue'),
  // A component to use while the async component is loading
  loadingComponent: LoadingComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // A component to use if the load fails
  errorComponent: ErrorComponent,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000
})In the context of Vue applications, a "composable" is a function that leverages Vue's
Composition API to encapsulate and reuse stateful logic.
When building frontend applications, we often need to reuse logic for common tasks. For
example, we may need to format dates in many places, so we extract a reusable function for
that. This formatter function encapsulates stateless logic: it takes some input and
immediately returns expected output. There are many libraries out there for reusing
stateless logic - for example lodash and date-fns, which you may have heard of.
By contrast, stateful logic involves managing state that changes over time. A simple example
would be tracking the current position of the mouse on a page. In real-world scenarios, it
could also be more complex logic such as touch gestures or connection status to a
database.
If we were to implement the mouse tracking functionality using the Composition API directly
inside a component, it would look like this:Composables
TIP
This section assumes basic knowledge of Composition API. If you have been learning Vue
with Options API only, you can set the API Preference to Composition API (using the
toggle at the top of the left sidebar) and re-read the Reactivity Fundamentals and
Lifecycle Hooks chapters.ⓘ
What is a "Composable"?
Mouse Tracker ExampleBut what if we want to reuse the same logic in multiple components? We can extract the
logic into an external file, as a composable function:<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
const x = ref(0)
const y = ref(0)
function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}
onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
</script>
<template>Mouse position is at: {{ x }}, {{ y }}</template>
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'
// by convention, composable function names start with "use"
export function useMouse() {
  // state encapsulated and managed by the composable
  const x = ref(0)
  const y = ref(0)
  // a composable can update its managed state over time.
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }
  // a composable can also hook into its owner component's
  // lifecycle to setup and teardown side effects.
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))
  // expose managed state as return value
  return { x, y }
}vuAnd this is how it can be used in components:
Mouse position is at: 0, 0
Try it in the Playground
As we can see, the core logic remains identical - all we had to do was move it into an
external function and return the state that should be exposed. Just like inside a component,
you can use the full range of Composition API functions in composables. The same
useMouse() functionality can now be used in any component.
The cooler part about composables though, is that you can also nest them: one composable
function can call one or more other composable functions. This enables us to compose
complex logic using small, isolated units, similar to how we compose an entire application
using components. In fact, this is why we decided to call the collection of APIs that make
this pattern possible Composition API.
For example, we can extract the logic of adding and removing a DOM event listener into its
own composable:▶<script setup>
import { useMouse } from './mouse.js'
const { x, y } = useMouse()
</script>
<template>Mouse position is at: {{ x }}, {{ y }}</template>
// event.js
import { onMounted, onUnmounted } from 'vue'
export function useEventListener(target, event, callback) {
  // if you want, you can also make this
  // support selector strings as target
  onMounted(() => target.addEventListener(event, callback))
  onUnmounted(() => target.removeEventListener(event, callback))
}vuAnd now our useMouse() composable can be simplified to:
The useMouse() composable doesn't take any arguments, so let's take a look at another
example that makes use of one. When doing async data fetching, we often need to handle
different states: loading, success, and error:TIP
Each component instance calling useMouse() will create its own copies of x and y
state so they won't interfere with one another. If you want to manage shared state
between components, read the State Management chapter.ⓘ
Async State Example// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'
export function useMouse() {
  const x = ref(0)
  const y = ref(0)
  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })
  return { x, y }
}It would be tedious to have to repeat this pattern in every component that needs to fetch
data. Let's extract it into a composable:
Now in our component we can just do:<script setup>
import { ref } from 'vue'
const data = ref(null)
const error = ref(null)
fetch('...')
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err))
</script>
<template>
  <div v-if="error">Oops! Error encountered: {{ error.message }}</div>
  <div v-else-if="data">
    Data loaded:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Loading...</div>
</template>
// fetch.js
import { ref } from 'vue'
export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))
  return { data, error }
}vuuseFetch() takes a static URL string as input - so it performs the fetch only once and is
then done. What if we want it to re-fetch whenever the URL changes? We can achieve that
by also accepting refs as an argument:
This version of useFetch() now accepts both static URL strings and refs of URL strings.
When it detects that the URL is a dynamic ref using isRef(), it sets up a reactive effect<script setup>
import { useFetch } from './fetch.js'
const { data, error } = useFetch('...')
</script>
// fetch.js
import { ref, isRef, unref, watchEffect } from 'vue'
export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  function doFetch() {
    // reset state before fetching..
    data.value = null
    error.value = null
    // unref() unwraps potential refs
    fetch(unref(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err))
  }
  if (isRef(url)) {
    // setup reactive re-fetch if input URL is a ref
    watchEffect(doFetch)
  } else {
    // otherwise, just fetch once
    // and avoid the overhead of a watcher
    doFetch()
  }
  return { data, error }
}vuusing watchEffect(). The effect will run immediately and will also track the URL ref as a
dependency. Whenever the URL ref changes, the data will be reset and fetched again.
Here's the updated version of useFetch(), with an artificial delay and randomized
error for demo purposes.
It is a convention to name composable functions with camelCase names that start with
"use".
A composable can accept ref arguments even if it doesn't rely on them for reactivity. If you
are writing a composable that may be used by other developers, it's a good idea to handle
the case of input arguments being refs instead of raw values. The unref() utility function
will come in handy for this purpose:
If your composable creates reactive effects when the input is a ref, make sure to either
explicitly watch the ref with watch(), or call unref() inside a watchEffect() so that it
is properly tracked.▶
Conventions and Best Practices
Naming
Input Arguments
Return Valuesimport { unref } from 'vue'
function useFeature(maybeRef) {
  // if maybeRef is indeed a ref, its .value will be returned
  // otherwise, maybeRef is returned as-is
  const value = unref(maybeRef)
}You have probably noticed that we have been exclusively using ref() instead of
reactive() in composables. The recommended convention is for composables to always
return a plain, non-reactive object containing multiple refs. This allows it to be destructured
in components while retaining reactivity:
Returning a reactive object from a composable will cause such destructures to lose the
reactivity connection to the state inside the composable, while the refs will retain that
connection.
If you prefer to use returned state from composables as object properties, you can wrap the
returned object with reactive() so that the refs are unwrapped. For example:
It is OK to perform side effects (e.g. adding DOM event listeners or fetching data) in
composables, but pay attention to the following rules:Side Effects
If you are working on an application that uses Server-Side Rendering (SSR), make sure
to perform DOM-specific side effects in post-mount lifecycle hooks, e.g. onMounted().
These hooks are only called in the browser, so you can be sure that code inside them has
access to the DOM.
Remember to clean up side effects in onUnmounted(). For example, if a composable
sets up a DOM event listener, it should remove that listener in onUnmounted() as we
have seen in the useMouse() example. It can be a good idea to use a composable that
automatically does this for you, like the useEventListener() example.// x and y are refs
const { x, y } = useMouse()
const mouse = reactive(useMouse())
// mouse.x is linked to original ref
console.log(mouse.x)
Mouse position is at: {{ mouse.x }}, {{ mouse.y }}templaComposables should only be called synchronously in <script setup> or the setup()
hook. In some cases, you can also call them in lifecycle hooks like onMounted().
These are the contexts where Vue is able to determine the current active component
instance. Access to an active component instance is necessary so that:
Composables can be extracted not only for reuse, but also for code organization. As the
complexity of your components grow, you may end up with components that are too large to
navigate and reason about. Composition API gives you the full flexibility to organize your
component code into smaller functions based on logical concerns:Usage Restrictions
Lifecycle hooks can be registered to it. 1.
Computed properties and watchers can be linked to it, so that they can be disposed
when the instance is unmounted to prevent memory leaks.2.
TIP
<script setup> is the only place where you can call composables after using await.
The compiler automatically restores the active instance context for you after the async
operation.ⓘ
Extracting Composables for Code Organization
<script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'
const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
</script>vuTo some extent, you can think of these extracted composables as component-scoped
services that can talk to one another.
If you are using Options API, composables must be called inside setup(), and the returned
bindings must be returned from setup() so that they are exposed to this and the
template:
Users coming from Vue 2 may be familiar with the mixins option, which also allows us to
extract component logic into reusable units. There are three primary drawbacks to mixins:Using Composables in Options API
Comparisons with Other Techniques
vs. Mixins
Unclear source of properties: when using many mixins, it becomes unclear which
instance property is injected by which mixin, making it difficult to trace the1.import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'
export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('...')
    return { x, y, data, error }
  },
  mounted() {
    // setup() exposed properties can be accessed on `this`
    console.log(this.x)
  }
  // ...other options
}For the above reasons, we no longer recommend using mixins in Vue 3. The feature is kept
only for migration and familiarity reasons.
In the component slots chapter, we discussed the Renderless Component pattern based on
scoped slots. We even implemented the same mouse tracking demo using renderless
components.
The main advantage of composables over renderless components is that composables do
not incur the extra component instance overhead. When used across an entire application,
the amount of extra component instances created by the renderless component pattern can
become a noticeable performance overhead.
The recommendation is to use composables when reusing pure logic, and use components
when reusing both logic and visual layout.
If you have experience with React, you may notice that this looks very similar to custom
React hooks. Composition API was in part inspired by React hooks, and Vue composables
are indeed similar to React hooks in terms of logic composition capabilities. However, Vue
composables are based on Vue's fine-grained reactivity system, which is fundamentally
different from React hooks' execution model. This is discussed in more detail in the
Composition API FAQ.implementation and understand the component's behavior. This is also why we
recommend using the refs + destructure pattern for composables: it makes the property
source clear in consuming components.
Namespace collisions: multiple mixins from different authors can potentially register the
same property keys, causing namespace collisions. With composables, you can rename
the destructured variables if there are conflicting keys from different composables.2.
Implicit cross-mixin communication: multiple mixins that need to interact with one
another have to rely on shared property keys, making them implicitly coupled. With
composables, values returned from one composable can be passed into another as
arguments, just like normal functions.3.
vs. Renderless Components
vs. React HooksFurther Reading
Reactivity In Depth: for a low-level understanding of how Vue's reactivity system works.
State Management: for patterns of managing state shared by multiple components.
Testing Composables: tips on unit testing composables.
VueUse: an ever-growing collection of Vue composables. The source code is also a great
learning resource.In addition to the default set of directives shipped in core (like v-model or v-show), Vue
also allows you to register your own custom directives.
We have introduced two forms of code reuse in Vue: components and composables.
Components are the main building blocks, while composables are focused on reusing
stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic
that involves low-level DOM access on plain elements.
A custom directive is defined as an object containing lifecycle hooks similar to those of a
component. The hooks receive the element the directive is bound to. Here is an example of a
directive that focuses an input when the element is inserted into the DOM by Vue:
This should be focused
Assuming you haven't clicked elsewhere on the page, the input above should be auto-
focused. This directive is more useful than the autofocus attribute because it works not
just on page load - it also works when the element is dynamically inserted by Vue.Custom Directives
Introduction
<script setup>
// enables v-focus in templates
const vFocus = {
  mounted: (el) => el.focus()
}
</script>
<template>
  <input v-focus />
</template>vuIn <script setup>, any camelCase variable that starts with the v prefix can be used as a
custom directive. In the example above, vFocus can be used in the template as v-focus.
If not using <script setup>, custom directives can be registered using the directives
option:
It is also common to globally register custom directives at the app level:
TIP
Custom directives should only be used when the desired functionality can only be
achieved via direct DOM manipulation. Prefer declarative templating using built-in
directives such as v-bind when possible because they are more efficient and server-
rendering friendly.ⓘ
Directive Hooksexport default {
  setup() {
    /*...*/
  },
  directives: {
    // enables v-focus in template
    focus: {
      /* ... */
    }
  }
}
const app = createApp({})
// make v-focus usable in all components
app.directive('focus', {
  /* ... */
})A directive definition object can provide several hook functions (all optional):
Directive hooks are passed these arguments:Hook Arguments
el: the element the directive is bound to. This can be used to directly manipulate the
DOM.
binding: an object containing the following properties.
value: The value passed to the directive. For example in v-my-directive="1 + 1",
the value would be 2.
oldValue: The previous value, only available in beforeUpdate and updated. It is
available whether or not the value has changed.
arg: The argument passed to the directive, if any. For example in v-my-
directive:foo, the arg would be "foo".
modifiers: An object containing modifiers, if any. For example in v-my-
directive.foo.bar, the modifiers object would be { foo: true, bar: true }.const myDirective = {
  // called before bound element's attributes
  // or event listeners are applied
  created(el, binding, vnode, prevVnode) {
    // see below for details on arguments
  },
  // called right before the element is inserted into the DOM.
  beforeMount(el, binding, vnode, prevVnode) {},
  // called when the bound element's parent component
  // and all its children are mounted.
  mounted(el, binding, vnode, prevVnode) {},
  // called before the parent component is updated
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // called after the parent component and
  // all of its children have updated
  updated(el, binding, vnode, prevVnode) {},
  // called before the parent component is unmounted
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // called when the parent component is unmounted
  unmounted(el, binding, vnode, prevVnode) {}
}As an example, consider the following directive usage:
The binding argument would be an object in the shape of:
Similar to built-in directives, custom directive arguments can be dynamic. For example:
Here the directive argument will be reactively updated based on arg property in our
component state.instance: The instance of the component where the directive is used.
dir: the directive definition object.
vnode: the underlying VNode representing the bound element.
prevNode: the VNode representing the bound element from the previous render. Only
available in the beforeUpdate and updated hooks.
Note
Apart from el, you should treat these arguments as read-only and never modify them. If
you need to share information across hooks, it is recommended to do so through
element's dataset.ⓘ<div v-example:foo.bar="baz">
{
  arg: 'foo',
  modifiers: { bar: true },
  value: /* value of `baz` */,
  oldValue: /* value of `baz` from previous update */
}
<div v-example:[arg]="value"></div>templa
templaIt's common for a custom directive to have the same behavior for mounted and updated,
with no need for the other hooks. In such cases we can define the directive as a function:
If your directive needs multiple values, you can also pass in a JavaScript object literal.
Remember, directives can take any valid JavaScript expression.
When used on components, custom directives will always apply to a component's root node,
similar to Fallthrough Attributes.Function Shorthand
Object Literals
Usage on Components<div v-color="color"></div>
app.directive('color', (el, binding) => {
  // this will be called for both `mounted` and `updated`
  el.style.color = binding.value
})
<div v-demo="{ color: 'white', text: 'hello!' }"></div>
app.directive('demo', (el, binding) => {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text) // => "hello!"
})templa
templaNote that components can potentially have more than one root node. When applied to a
multi-root component, a directive will be ignored and a warning will be thrown. Unlike
attributes, directives can't be passed to a different element with v-bind="$attrs". In
general, it is not recommended to use custom directives on components.<MyComponent v-demo="test" />
<!-- template of MyComponent -->
<div> <!-- v-demo directive will be applied here -->
  <span>My component content</span>
</div>templa
templaPlugins are self-contained code that usually add app-level functionality to Vue. This is how
we install a plugin:
A plugin is defined as either an object that exposes an install() method, or simply a
function that acts as the install function itself. The install function receives the app instance
along with additional options passed to app.use(), if any:
There is no strictly defined scope for a plugin, but common scenarios where plugins are
useful include:Plugins
Introduction
Register one or more global components or custom directives with app.component()
and app.directive().1.
Make a resource injectable throughout the app by calling app.provide(). 2.
Add some global instance properties or methods by attaching them to
app.config.globalProperties.3.import { createApp } from 'vue'
const app = createApp({})
app.use(myPlugin, {
  /* optional options */
})
const myPlugin = {
  install(app, options) {
    // configure the app
  }
}In order to better understand how to create your own Vue.js plugins, we will create a very
simplified version of a plugin that displays i18n (short for Internationalization) strings.
Let's begin by setting up the plugin object. It is recommended to create it in a separate file
and export it, as shown below to keep the logic contained and separate.
We want to create a translation function. This function will receive a dot-delimited key
string, which we will use to look up the translated string in the user-provided options. This is
the intended usage in templates:
Since this function should be globally available in all templates, we will make it so by
attaching it to app.config.globalProperties in our plugin:A library that needs to perform some combination of the above (e.g. vue-router). 4.
Writing a Plugin
// plugins/i18n.js
export default {
  install: (app, options) => {
    // Plugin code goes here
  }
}
<h1>{{ $translate('greetings.hello') }}</h1>templaOur $translate function will take a string such as greetings.hello, look inside the user
provided configuration and return the translated value.
The object containing the translated keys should be passed to the plugin during installation
via additional parameters to app.use():
Now, our initial expression $translate('greetings.hello') will be replaced by
Bonjour! at runtime.
See also: Augmenting Global PropertiesTS
TIP
Use global properties scarcely, since it can quickly become confusing if too many global
properties injected by different plugins are used throughout an app.ⓘ// plugins/i18n.js
export default {
  install: (app, options) => {
    // inject a globally available $translate() method
    app.config.globalProperties.$translate = (key) => {
      // retrieve a nested property in `options`
      // using `key` as the path
      return key.split('.').reduce((o, i) => {
        if (o) return o[i]
      }, options)
    }
  }
}
import i18nPlugin from './plugins/i18n'
app.use(i18nPlugin, {
  greetings: {
    hello: 'Bonjour!'
  }
})Plugins also allow us to use inject to provide a function or attribute to the plugin's users.
For example, we can allow the application to have access to the options parameter to be
able to use the translations object.
Plugin users will now be able to inject the plugin options into their components using the
i18n key:Provide / Inject with Plugins
// plugins/i18n.js
export default {
  install: (app, options) => {
    app.config.globalProperties.$translate = (key) => {
      return key.split('.').reduce((o, i) => {
        if (o) return o[i]
      }, options)
    }
    app.provide('i18n', options)
  }
}
<script setup>
import { inject } from 'vue'
const i18n = inject('i18n')
console.log(i18n.greetings.hello)
</script>vuVue offers two built-in components that can help work with transitions and animations in
response to changing state:
Aside from these two components, we can also apply animations in Vue using other
techniques such as toggling CSS classes or state-driven animations via style bindings.
These additional techniques are covered in the Animation Techniques chapter.
<Transition> is a built-in component: this means it is available in any component's
template without having to register it. It can be used to apply enter and leave animations on
elements or components passed to it via its default slot. The enter or leave can be triggered
by one of the following:
This is an example of the most basic usage:Transition
<Transition> for applying animations when an element or component is entering and
leaving the DOM. This is covered on this page.
<TransitionGroup> for applying animations when an element or component is inserted
into, removed from, or moved within a v-for list. This is covered in the next chapter.
The <Transition> Component
Conditional rendering via v-if
Conditional display via v-show
Dynamic components toggling via the <component> special element
<button @click="show = !show">Toggle</button>
<Transition>
  <p v-if="show">hello</p>
</Transition>templaToggle Fade
hello
Try it in the Playground
When an element in a <Transition> component is inserted or removed, this is what
happens:▶
TIP
<Transition> only supports a single element or component as its slot content. If the
content is a component, the component must also have only one single root element.ⓘ
Vue will automatically sniff whether the target element has CSS transitions or animations
applied. If it does, a number of CSS transition classes will be added / removed at
appropriate timings.1.
If there are listeners for JavaScript hooks, these hooks will be called at appropriate
timings.2.
If no CSS transitions / animations are detected and no JavaScript hooks are provided, the
DOM operations for insertion and/or removal will be executed on the browser's next
animation frame.3./* we will explain what these classes do next! */
.v-enter-active,
.v-leave-active {
  transition: opacity 0.5s ease;
}
.v-enter-from,
.v-leave-to {
  opacity: 0;
}cThere are six classes applied for enter / leave transitions.
CSS-Based Transitions
Transition Classes
v-enter-from: Starting state for enter. Added before the element is inserted, removed
one frame after the element is inserted.1.
v-enter-active: Active state for enter. Applied during the entire entering phase.
Added before the element is inserted, removed when the transition/animation finishes.
This class can be used to define the duration, delay and easing curve for the entering
transition.2.
v-enter-to: Ending state for enter. Added one frame after the element is inserted (at
the same time v-enter-from is removed), removed when the transition/animation
finishes.3.
v-leave-from: Starting state for leave. Added immediately when a leaving transition is
triggered, removed after one frame.4.
v-leave-active: Active state for leave. Applied during the entire leaving phase. Added
immediately when a leaving transition is triggered, removed when the5.v-enter-active and v-leave-active give us the ability to specify different easing
curves for enter / leave transitions, which we'll see an example of in the following sections.
A transition can be named via the name prop:
For a named transition, its transition classes will be prefixed with its name instead of v. For
example, the applied class for the above transition will be fade-enter-active instead of
v-enter-active. The CSS for the fade transition should look like this:
<Transition> is most commonly used in combination with native CSS transitions, as
seen in the basic example above. The transition CSS property is a shorthand that allowstransition/animation finishes. This class can be used to define the duration, delay and
easing curve for the leaving transition.
v-leave-to: Ending state for leave. Added one frame after a leaving transition is
triggered (at the same time v-leave-from is removed), removed when the
transition/animation finishes.6.
Named Transitions
CSS Transitions<Transition name="fade">
  ...
</Transition>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.5s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}templa
cus to specify multiple aspects of a transition, including properties that should be animated,
duration of the transition, and easing curves.
Here is a more advanced example that transitions multiple properties, with different
durations and easing curves for enter and leave:
Toggle Slide + Fade
hello
Try it in the Playground
Native CSS animations are applied in the same way as CSS transitions, with the difference
being that *-enter-from is not removed immediately after the element is inserted, but on▶
CSS Animations<Transition name="slide-fade">
  <p v-if="show">hello</p>
</Transition>
/*
  Enter and leave animations can use different
  durations and timing functions.
*/
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}
.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}
.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(20px);
  opacity: 0;
}templa
can animationend event.
For most CSS animations, we can simply declare them under the *-enter-active and *-
leave-active classes. Here's an example:
Toggle
Hello here is some bouncy text!
Try it in the Playground▶
Custom Transition Classes<Transition name="bounce">
  <p v-if="show" style="text-align: center;">
    Hello here is some bouncy text!
  </p>
</Transition>
.bounce-enter-active {
  animation: bounce-in 0.5s;
}
.bounce-leave-active {
  animation: bounce-in 0.5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.25);
  }
  100% {
    transform: scale(1);
  }
}templa
cYou can also specify custom transition classes by passing the following props to
<Transition>:
These will override the conventional class names. This is especially useful when you want to
combine Vue's transition system with an existing CSS animation library, such as
Animate.css:
Try it in the Playground
Vue needs to attach event listeners in order to know when a transition has ended. It can
either be transitionend or animationend, depending on the type of CSS rules applied.
If you are only using one or the other, Vue can automatically detect the correct type.
However, in some cases you may want to have both on the same element, for example
having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In
these cases, you will have to explicitly declare the type you want Vue to care about by
passing the type prop, with a value of either animation or transition:enter-from-class
enter-active-class
enter-to-class
leave-from-class
leave-active-class
leave-to-class
▶
Using Transitions and Animations Together<!-- assuming Animate.css is included on the page -->
<Transition
  name="custom-classes"
  enter-active-class="animate__animated animate__tada"
  leave-active-class="animate__animated animate__bounceOutRight"
>
  <p v-if="show">hello</p>
</Transition>
<Transition type="animation">...</Transition>templa
templaAlthough the transition classes are only applied to the direct child element in
<Transition>, we can transition nested elements using nested CSS selectors:
We can even add a transition delay to the nested element on enter, which creates a
staggered enter animation sequence:
However, this creates a small issue. By default, the <Transition> component attempts to
automatically figure out when the transition has finished by listening to the first
transitionend or animationend event on the root transition element. With a nested
transition, the desired behavior should be waiting until the transitions of all inner elements
have finished.Nested Transitions and Explicit Transition Durations
<Transition name="nested">
  <div v-if="show" class="outer">
    <div class="inner">
      Hello
    </div>
  </div>
</Transition>
/* rules that target nested elements */
.nested-enter-active .inner,
.nested-leave-active .inner {
  transition: all 0.3s ease-in-out;
}
.nested-enter-from .inner,
.nested-leave-to .inner {
  transform: translateX(30px);
  opacity: 0;
}
/* ... other necessary CSS omitted */
/* delay enter of nested element for staggered effect */
.nested-enter-active .inner {
  transition-delay: 0.25s;
}templa
c
cIn such cases you can specify an explicit transition duration (in milliseconds) using the
duration prop on the <transition> component. The total duration should match the
delay plus transition duration of the inner element:
Toggle
Hello
Try it in the Playground
If necessary, you can also specify separate values for enter and leave durations using an
object:
You may notice that the animations shown above are mostly using properties like
transform and opacity. These properties are efficient to animate because:▶
Performance Considerations
They do not affect the document layout during the animation, so they do not trigger
expensive CSS layout calculation on every animation frame.1.
Most modern browsers can leverage GPU hardware acceleration when animating
transform.2.<Transition :duration="550">...</Transition>
<Transition :duration="{ enter: 500, leave: 800 }">...</Transition>templa
templaIn comparison, properties like height or margin will trigger CSS layout, so they are much
more expensive to animate, and should be used with caution. We can check resources like
CSS-Triggers to see which properties will trigger layout if we animate them.
You can hook into the transition process with JavaScript by listening to events on the
<Transition> component:JavaScript Hooks
<Transition
  @before-enter="onBeforeEnter"
  @enter="onEnter"
  @after-enter="onAfterEnter"
  @enter-cancelled="onEnterCancelled"
  @before-leave="onBeforeLeave"
  @leave="onLeave"
  @after-leave="onAfterLeave"
  @leave-cancelled="onLeaveCancelled"
>
  <!-- ... -->
</Transition>htmThese hooks can be used in combination with CSS transitions / animations or on their own.
When using JavaScript-only transitions, it is usually a good idea to add the :css="false"
prop. This explicitly tells Vue to skip auto CSS transition detection. Aside from being slightly
more performant, this also prevents CSS rules from accidentally interfering with the
transition:// called before the element is inserted into the DOM.
// use this to set the "enter-from" state of the element
function onBeforeEnter(el) {}
// called one frame after the element is inserted.
// use this to start the entering animation.
function onEnter(el, done) {
  // call the done callback to indicate transition end
  // optional if used in combination with CSS
  done()
}
// called when the enter transition has finished.
function onAfterEnter(el) {}
function onEnterCancelled(el) {}
// called before the leave hook.
// Most of the time, you should just use the leave hook
function onBeforeLeave(el) {}
// called when the leave transition starts.
// use this to start the leaving animation.
function onLeave(el, done) {
  // call the done callback to indicate transition end
  // optional if used in combination with CSS
  done()
}
// called when the leave transition has finished and the
// element has been removed from the DOM.
function onAfterLeave(el) {}
// only available with v-show transitions
function onLeaveCancelled(el) {}With :css="false", we are also fully responsible for controlling when the transition ends.
In this case, the done callbacks are required for the @enter and @leave hooks.
Otherwise, the hooks will be called synchronously and the transition will finish immediately.
Here's a demo using the GreenSock library to perform the animations. You can, of course,
use any other animation library you want, for example Anime.js or Motion One.
Toggle
Try it in the Playground
Transitions can be reused through Vue's component system. To create a reusable transition,
we can create a component that wraps the <Transition> component and passes down
the slot content:▶
Reusable Transitions<Transition
  ...
  :css="false"
>
  ...
</Transition>templaNow MyTransition can be imported and used just like the built-in version:
If you also want to apply a transition on the initial render of a node, you can add the appear
prop:Transition on Appear<!-- MyTransition.vue -->
<script>
// JavaScript hooks logic...
</script>
<template>
  <!-- wrap the built-in Transition component -->
  <Transition
    name="my-transition"
    @enter="onEnter"
    @leave="onLeave">
    <slot></slot> <!-- pass down slot content -->
  </Transition>
</template>
<style>
/*
  Necessary CSS...
  Note: avoid using <style scoped> here since it
  does not apply to slot content.
*/
</style>
<MyTransition>
  <div v-if="show">Hello</div>
</MyTransition>
<Transition appear>
  ...
</Transition>vu
templa
templaIn addition to toggling an element with v-if / v-show, we can also transition between two
elements using v-if / v-else / v-else-if, as long as we make sure that there is only
one element being shown at any given moment:
Click to cycle through states:
Try it in the Playground
In the previous example, the entering and leaving elements are animated at the same time,
and we had to make them position: absolute to avoid the layout issue when both
elements are present in the DOM.
However, in some cases this isn't an option, or simply isn't the desired behavior. We may
want the leaving element to be animated out first, and for the entering element to only be
inserted after the leaving animation has finished. Orchestrating such animations manually
would be very complicated - luckily, we can enable this behavior by passing <Transition>
a mode prop:Transition Between Elements
Edit
▶
Transition Modes<Transition>
  <button v-if="docState === 'saved'">Edit</button>
  <button v-else-if="docState === 'edited'">Save</button>
  <button v-else-if="docState === 'editing'">Cancel</button>
</Transition>
<Transition mode="out-in">
  ...
</Transition>templa
templaHere's the previous demo with mode="out-in":
Click to cycle through states:
<Transition> also supports mode="in-out", although it's much less frequently used.
<Transition> can also be used around dynamic components:
 A  B
Component A
Try it in the Playground
<Transition> props like name can also be dynamic! It allows us to dynamically apply
different transitions based on state change:
Edit
Transition Between Components
▶
Dynamic Transitions<Transition name="fade" mode="out-in">
  <component :is="activeComponent"></component>
</Transition>
<Transition :name="transitionName">
  <!-- ... -->
</Transition>templa
templaThis can be useful when you've defined CSS transitions / animations using Vue's transition
class conventions and want to switch between them.
You can also apply different behavior in JavaScript transition hooks based on the current
state of your component. Finally, the ultimate way of creating dynamic transitions is through
reusable transition components that accept props to change the nature of the transition(s)
to be used. It may sound cheesy, but the only limit really is your imagination.
Related
<Transition> API reference<TransitionGroup> is a built-in component designed for animating the insertion, removal,
and order change of elements or components that are rendered in a list.
<TransitionGroup> supports the same props, CSS transition classes, and JavaScript hook
listeners as <Transition>, with the following differences:
Here is an example of applying enter / leave transitions to a v-for list using
<TransitionGroup>:TransitionGroup
Differences from <Transition>
By default, it doesn't render a wrapper element. But you can specify an element to be
rendered with the tag prop.
Transition modes are not available, because we are no longer alternating between
mutually exclusive elements.
Elements inside are always required to have a unique key attribute.
CSS transition classes will be applied to individual elements in the list, not to the group /
container itself.
TIP
When used in DOM templates, it should be referenced as <transition-group>.ⓘ
Enter / Leave TransitionsAdd at random index
Remove at random index
The above demo has some obvious flaws: when an item is inserted or removed, its
surrounding items instantly "jump" into place instead of moving smoothly. We can fix this by
adding a few additional CSS rules:1
2
3
4
5
Move Transitions<TransitionGroup name="list" tag="ul">
  <li v-for="item in items" :key="item">
    {{ item }}
  </li>
</TransitionGroup>
.list-enter-active,
.list-leave-active {
  transition: all 0.5s ease;
}
.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}templa
cNow it looks much better - even animating smoothly when the whole list is shuffled:
Add
Remove
Shuffle
Full Example
By communicating with JavaScript transitions through data attributes, it's also possible to
stagger transitions in a list. First, we render the index of an item as a data attribute on the
DOM element:1
2
3
4
5
Staggering List Transitions.list-move, /* apply transition to moving elements */
.list-enter-active,
.list-leave-active {
  transition: all 0.5s ease;
}
.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
/* ensure leaving items are taken out of layout flow so that moving
   animations can be calculated correctly. */
.list-leave-active {
  position: absolute;
}cThen, in JavaScript hooks, we animate the element with a delay based on the data attribute.
This example is using the GreenSock library to perform the animation:
Full Example in the PlaygroundBruce Lee
Jackie Chan
Chuck Norris
Jet Li
Kung Fury
▶<TransitionGroup
  tag="ul"
  :css="false"
  @before-enter="onBeforeEnter"
  @enter="onEnter"
  @leave="onLeave"
>
  <li
    v-for="(item, index) in computedList"
    :key="item.msg"
    :data-index="index"
  >
    {{ item.msg }}
  </li>
</TransitionGroup>
function onEnter(el, done) {
  gsap.to(el, {
    opacity: 1,
    height: '1.6em',
    delay: el.dataset.index * 0.15,
    onComplete: done
  })
}templaRelated
<TransitionGroup> API reference<KeepAlive> is a built-in component that allows us to conditionally cache component
instances when dynamically switching between multiple components.
In the Component Basics chapter, we introduced the syntax for Dynamic Components,
using the <component> special element:
By default, an active component instance will be unmounted when switching away from it.
This will cause any changed state it holds to be lost. When this component is displayed
again, a new instance will be created with only the initial state.
In the example below, we have two stateful components - A contains a counter, while B
contains a message synced with an input via v-model. Try updating the state of one of
them, switch away, and then switch back to it:
 A B
Current component: A
count: 0
+
You'll notice that when switched back, the previous changed state would have been reset.
Creating fresh component instance on switch is normally useful behavior, but in this case,
we'd really like the two component instances to be preserved even when they are inactive.
To solve this problem, we can wrap our dynamic component with the <KeepAlive> built-in
component:KeepAlive
Basic Usage
<component :is="activeComponent" />templaNow, the state will be persisted across component switches:
 A B
Current component: A
count: 0
+
Try it in the Playground
By default, <KeepAlive> will cache any component instance inside. We can customize this
behavior via the include and exclude props. Both props can be a comma-delimited
string, a RegExp, or an array containing either types:▶
TIP
When used in DOM templates, it should be referenced as <keep-alive>.ⓘ
Include / Exclude<!-- Inactive components will be cached! -->
<KeepAlive>
  <component :is="activeComponent" />
</KeepAlive>templaThe match is checked against the component's name option, so components that need to
be conditionally cached by KeepAlive must explicitly declare a name option.
We can limit the maximum number of component instances that can be cached via the
max prop. When max is specified, <KeepAlive> behaves like an LRU cache: if the
number of cached instances is about to exceed the specified max count, the least recently
accessed cached instance will be destroyed to make room for the new one.TIP
Since version 3.2.34, a single-file component using <script setup> will automatically
infer its name option based on the filename, removing the need to manually declare the
name.ⓘ
Max Cached Instances<!-- comma-delimited string -->
<KeepAlive include="a,b">
  <component :is="view" />
</KeepAlive>
<!-- regex (use `v-bind`) -->
<KeepAlive :include="/a|b/">
  <component :is="view" />
</KeepAlive>
<!-- Array (use `v-bind`) -->
<KeepAlive :include="['a', 'b']">
  <component :is="view" />
</KeepAlive>
<KeepAlive :max="10">
  <component :is="activeComponent" />
</KeepAlive>templa
templaWhen a component instance is removed from the DOM but is part of a component tree
cached by <KeepAlive>, it goes into a deactivated state instead of being unmounted.
When a component instance is inserted into the DOM as part of a cached tree, it is
activated.
A kept-alive component can register lifecycle hooks for these two states using
onActivated() and onDeactivated():
Note that:
RelatedLifecycle of Cached Instance
onActivated is also called on mount, and onDeactivated on unmount.
Both hooks work for not only the root component cached by <KeepAlive>, but also
descendant components in the cached tree.
<KeepAlive> API reference<script setup>
import { onActivated, onDeactivated } from 'vue'
onActivated(() => {
  // called on initial mount
  // and every time it is re-inserted from the cache
})
onDeactivated(() => {
  // called when removed from the DOM into the cache
  // and also when unmounted
})
</script>v<Teleport> is a built-in component that allows us to "teleport" a part of a component's
template into a DOM node that exists outside the DOM hierarchy of that component.
Sometimes we may run into the following scenario: a part of a component's template
belongs to it logically, but from a visual standpoint, it should be displayed somewhere else
in the DOM, outside of the Vue application.
The most common example of this is when building a full-screen modal. Ideally, we want the
modal's button and the modal itself to live within the same component, since they are both
related to the open / close state of the modal. But that means the modal will be rendered
alongside the button, deeply nested in the application's DOM hierarchy. This can create
some tricky issues when positioning the modal via CSS.
Consider the following HTML structure.
And here is the implementation of <MyModal>:Teleport
Basic Usage
<div class="outer">
  <h3>Vue Teleport Example</h3>
  <div>
    <MyModal />
  </div>
</div>templaThe component contains a <button> to trigger the opening of the modal, and a <div>
with a class of .modal, which will contain the modal's content and a button to self-close.
When using this component inside the initial HTML structure, there are a number of
potential issues:
position: fixed only places the element relative to the viewport when no ancestor
element has transform, perspective or filter property set. If, for example, we
intend to animate the ancestor <div class="outer"> with a CSS transform, it would
break the modal layout!
The modal's z-index is constrained by its containing elements. If there is another
element that overlaps with <div class="outer"> and has a higher z-index, it would
cover our modal.<script setup>
import { ref } from 'vue'
const open = ref(false)
</script>
<template>
  <button @click="open = true">Open Modal</button>
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</template>
<style scoped>
.modal {
  position: fixed;
  z-index: 999;
  top: 20%;
  left: 50%;
  width: 300px;
  margin-left: -150px;
}
</style>v<Teleport> provides a clean way to work around these, by allowing us to break out of the
nested DOM structure. Let's modify <MyModal> to use <Teleport>:
The to target of <Teleport> expects a CSS selector string or an actual DOM node.
Here, we are essentially telling Vue to "teleport this template fragment to the body tag".
You can click the button below and inspect the <body> tag via your browser's devtools:
Open Modal
You can combine <Teleport> with <Transition> to create animated modals - see
Example here.
<Teleport> only alters the rendered DOM structure - it does not affect the logical
hierarchy of the components. That is to say, if <Teleport> contains a component, thatTIP
The teleport to target must be already in the DOM when the <Teleport> component
is mounted. Ideally, this should be an element outside the entire Vue application. If
targeting another element rendered by Vue, you need to make sure that element is
mounted before the <Teleport>.ⓘ
Using with Components<button @click="open = true">Open Modal</button>
<Teleport to="body">
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</Teleport>templacomponent will remain a logical child of the parent component containing the <Teleport>.
Props passing and event emitting will continue to work the same way.
This also means that injections from a parent component work as expected, and that the
child component will be nested below the parent component in the Vue Devtools, instead of
being placed where the actual content moved to.
In some cases, we may want to conditionally disable <Teleport>. For example, we may
want to render a component as an overlay for desktop, but inline on mobile. <Teleport>
supports the disabled prop which can be dynamically toggled:
Where the isMobile state can be dynamically updated by detecting media query
changes.
A common use case would be a reusable <Modal> component, with the potential for
multiple instances to be active at the same time. For this kind of scenario, multiple
<Teleport> components can mount their content to the same target element. The order
will be a simple append - later mounts will be located after earlier ones within the target
element.
Given the following usage:Disabling Teleport
Multiple Teleports on the Same Target<Teleport :disabled="isMobile">
  ...
</Teleport>templaThe rendered result would be:
Related
<Teleport> API reference
Handling Teleports in SSR<Teleport to="#modals">
  <div>A</div>
</Teleport>
<Teleport to="#modals">
  <div>B</div>
</Teleport>
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>templa
ht<Suspense> is a built-in component for orchestrating async dependencies in a component
tree. It can render a loading state while waiting for multiple nested async dependencies
down the component tree to be resolved.
To explain the problem <Suspense> is trying to solve and how it interacts with these async
dependencies, let's imagine a component hierarchy like the following:
In the component tree there are multiple nested components whose rendering depends on
some async resource to be resolved first. Without <Suspense>, each of them will need to
handle its own loading / error and loaded states. In the worst case scenario, we may see
three loading spinners on the page, with content displayed at different times.
The <Suspense> component gives us the ability to display top-level loading / error states
while we wait on these nested async dependencies to be resolved.
There are two types of async dependencies that <Suspense> can wait on:Suspense
Experimental Feature
<Suspense> is an experimental feature. It is not guaranteed to reach stable status and
the API may change before it does.⚠
Async Dependencies
<Suspense>
└─ <Dashboard>
   ├─ <Profile>
   │  └─ <FriendStatus> (component with async setup())
   └─ <Content>
      ├─ <ActivityFeed> (async component)
      └─ <Stats> (async component)A Composition API component's setup() hook can be async:
If using <script setup>, the presence of top-level await expressions automatically
makes the component an async dependency:
Async components are "suspensible" by default. This means that if it has a <Suspense> in
the parent chain, it will be treated as an async dependency of that <Suspense>. In this
case, the loading state will be controlled by the <Suspense>, and the component's own
loading, error, delay and timeout options will be ignored.Components with an async setup() hook. This includes components using <script
setup> with top-level await expressions.1.
Async Components. 2.
async setup()
Async Componentsexport default {
  async setup() {
    const res = await fetch(...)
    const posts = await res.json()
    return {
      posts
    }
  }
}
<script setup>
const res = await fetch(...)
const posts = await res.json()
</script>
<template>
  {{ posts }}
</template>vuThe async component can opt-out of Suspense control and let the component always
control its own loading state by specifying suspensible: false in its options.
The <Suspense> component has two slots: #default and #fallback. Both slots only
allow for one immediate child node. The node in the default slot is shown if possible. If not,
the node in the fallback slot will be shown instead.
On initial render, <Suspense> will render its default slot content in memory. If any async
dependencies are encountered during the process, it will enter a pending state. During the
pending state, the fallback content will be displayed. When all encountered async
dependencies have been resolved, <Suspense> enters a resolved state and the resolved
default slot content is displayed.
If no async dependencies were encountered during the initial render, <Suspense> will
directly go into a resolved state.
Once in a resolved state, <Suspense> will only revert to a pending state if the root node of
the #default slot is replaced. New async dependencies nested deeper in the tree will not
cause the <Suspense> to revert to a pending state.
When a revert happens, fallback content will not be immediately displayed. Instead,
<Suspense> will display the previous #default content while waiting for the new content
and its async dependencies to be resolved. This behavior can be configured with the
timeout prop: <Suspense> will switch to fallback content if it takes longer than timeoutLoading State
<Suspense>
  <!-- component with nested async dependencies -->
  <Dashboard />
  <!-- loading state via #fallback slot -->
  <template #fallback>
    Loading...
  </template>
</Suspense>templato render the new default content. A timeout value of 0 will cause the fallback content to
be displayed immediately when default content is replaced.
The <Suspense> component emits 3 events: pending, resolve and fallback. The
pending event occurs when entering a pending state. The resolve event is emitted when
new content has finished resolving in the default slot. The fallback event is fired when
the contents of the fallback slot are shown.
The events could be used, for example, to show a loading indicator in front of the old DOM
while new components are loading.
<Suspense> currently does not provide error handling via the component itself - however,
you can use the errorCaptured option or the onErrorCaptured() hook to capture and
handle async errors in the parent component of <Suspense>.
It is common to want to use <Suspense> in combination with the <Transition> and
<KeepAlive> components. The nesting order of these components is important to get
them all working correctly.
In addition, these components are often used in conjunction with the <RouterView>
component from Vue Router.Events
Error Handling
Combining with Other ComponentsThe following example shows how to nest these components so that they all behave as
expected. For simpler combinations you can remove the components that you don't need:
Vue Router has built-in support for lazily loading components using dynamic imports.
These are distinct from async components and currently they will not trigger <Suspense>.
However, they can still have async components as descendants and those can trigger
<Suspense> in the usual way.<RouterView v-slot="{ Component }">
  <template v-if="Component">
    <Transition mode="out-in">
      <KeepAlive>
        <Suspense>
          <!-- main content -->
          <component :is="Component"></component>
          <!-- loading state -->
          <template #fallback>
            Loading...
          </template>
        </Suspense>
      </KeepAlive>
    </Transition>
  </template>
</RouterView>templaVue Single-File Components (a.k.a. *.vue files, abbreviated as SFC) is a special file format
that allows us to encapsulate the template, logic, and styling of a Vue component in a single
file. Here's an example SFC:
As we can see, Vue SFC is a natural extension of the classic trio of HTML, CSS and
JavaScript. The <template>, <script>, and <style> blocks encapsulate and colocate
the view, logic and styling of a component in the same file. The full syntax is defined in the
SFC Syntax Specification.
While SFCs require a build step, there are numerous benefits in return:Single-File Components
Introduction
Why SFC
Author modularized components using familiar HTML, CSS and JavaScript syntax<script setup>
import { ref } from 'vue'
const greeting = ref('Hello World!')
</script>
<template>
  <p class="greeting">{{ greeting }}</p>
</template>
<style>
.greeting {
  color: red;
  font-weight: bold;
}
</style>vuSFC is a defining feature of Vue as a framework, and is the recommended approach for
using Vue in the following scenarios:
That said, we do realize there are scenarios where SFCs can feel like overkill. This is why
Vue can still be used via plain JavaScript without a build step. If you are just looking for
enhancing largely static HTML with light interactions, you can also check out petite-vue, a 6
kB subset of Vue optimized for progressive enhancement.
Vue SFC is a framework-specific file format and must be pre-compiled by @vue/compiler-
sfc into standard JavaScript and CSS. A compiled SFC is a standard JavaScript (ES) module
- which means with proper build setup you can import an SFC like a module:Colocation of inherently coupled concerns
Pre-compiled templates without runtime compilation cost
Component-scoped CSS
More ergonomic syntax when working with Composition API
More compile-time optimizations by cross-analyzing template and script
IDE support with auto-completion and type-checking for template expressions
Out-of-the-box Hot-Module Replacement (HMR) support
Single-Page Applications (SPA)
Static Site Generation (SSG)
Any non-trivial frontend where a build step can be justified for better development
experience (DX).
How It Works
import MyComponent from './MyComponent.vue'
export default {
  components: {
    MyComponent
  }
}<style> tags inside SFCs are typically injected as native <style> tags during
development to support hot updates. For production they can be extracted and merged into
a single CSS file.
You can play with SFCs and explore how they are compiled in the Vue SFC Playground.
In actual projects, we typically integrate the SFC compiler with a build tool such as Vite or
Vue CLI (which is based on webpack), and Vue provides official scaffolding tools to get you
started with SFCs as fast as possible. Check out more details in the SFC Tooling section.
Some users coming from a traditional web development background may have the concern
that SFCs are mixing different concerns in the same place - which HTML/CSS/JS were
supposed to separate!
To answer this question, it is important for us to agree that separation of concerns is not
equal to the separation of file types. The ultimate goal of engineering principles is to
improve the maintainability of codebases. Separation of concerns, when applied
dogmatically as separation of file types, does not help us reach that goal in the context of
increasingly complex frontend applications.
In modern UI development, we have found that instead of dividing the codebase into three
huge layers that interweave with one another, it makes much more sense to divide them into
loosely-coupled components and compose them. Inside a component, its template, logic,
and styles are inherently coupled, and colocating them actually makes the component more
cohesive and maintainable.
Note even if you don't like the idea of Single-File Components, you can still leverage its hot-
reloading and pre-compilation features by separating your JavaScript and CSS into separate
files using Src Imports.▶
What About Separation of Concerns?You don't need to install anything on your machine to try out Vue SFCs - there are online
playgrounds that allow you to do so right in the browser:
It is also recommended to use these online playgrounds to provide reproductions when
reporting bugs.
Vite is a lightweight and fast build tool with first-class Vue SFC support. It is created by
Evan You, who is also the author of Vue!
To get started with Vite + Vue, simply run:
This command will install and execute create-vue, the official Vue project scaffolding tool.Tooling
Try It Online
Vue SFC Playground ▶
Always deployed from latest commit
Designed for inspecting component compilation results
Vue + Vite on StackBlitz
IDE-like environment running actual Vite dev server in the browser
Closest to local setup
Project Scaffolding
Vite
To learn more about Vite, check out the Vite docs.$ npm init vue@latestBoth online playgrounds mentioned above also support downloading files as a Vite project.
Vue CLI is the official webpack-based toolchain for Vue. It is now in maintenance mode and
we recommend starting new projects with Vite unless you rely on specific webpack-only
features. Vite will provide superior developer experience in most cases.
For information on migrating from Vue CLI to Vite:
When using Vue without a build step, component templates are written either directly in the
page's HTML or as inlined JavaScript strings. In such cases, Vue needs to ship the template
compiler to the browser in order to perform on-the-fly template compilation. On the other
hand, the compiler would be unnecessary if we pre-compile the templates with a build step.
To reduce client bundle size, Vue provides different "builds" optimized for different use
cases.
Our default tooling setups use the runtime-only build since all templates in SFCs are pre-
compiled. If, for some reason, you need in-browser template compilation even with a build
step, you can do so by configuring the build tool to alias vue to vue/dist/vue.esm-
bundler.js instead.To configure Vue-specific behavior in a Vite project, for example passing options to the
Vue compiler, check out the docs for @vitejs/plugin-vue.
Vue CLI
Vue CLI -> Vite Migration Guide from VueSchool.io
Tools / Plugins that help with auto migration
Note on In-Browser Template Compilation
Build files that start with vue.runtime.* are runtime-only builds: they do not include
the compiler. When using these builds, all templates must be pre-compiled via a build
step.
Build files that do not include .runtime are full builds: they include the compiler and
support compiling templates directly in the browser. However, they will increase the
payload by ~14kb.If you are looking for a lighter-weight alternative for no-build-step usage, check out petite-
vue.
The Vue browser devtools extension allows you to explore a Vue app's component tree,
inspect the state of individual components, track state management events, and profile
performance.IDE Support
The recommended IDE setup is VSCode + the Vue Language Features (Volar)
extension. The extension provides syntax highlighting, TypeScript support, and
intellisense for template expressions and component props.
TIP
Volar replaces Vetur, our previous official VSCode extension for Vue 2. If you have
Vetur currently installed, make sure to disable it in Vue 3 projects.ⓘ
WebStorm also provides great built-in support for Vue SFCs.
Other IDEs that support the Language Service Protocol (LSP) can also leverage Volar's
core functionalities via LSP:
Sublime Text support via LSP-Volar.
vim / Neovim support via coc-volar.
emacs support via lsp-mode
Browser DevtoolsMain article: Using Vue with TypeScript.
Main article: Testing Guide.Documentation
Chrome Extension
Firefox Addon
Standalone Electron app
TypeScript
Volar provides type checking for SFCs using <script lang="ts"> blocks, including
template expressions and cross-component props validation.
Use vue-tsc for performing the same type checking from the command line, or for
generating d.ts files for SFCs.
TestingThe Vue team maintains eslint-plugin-vue, an ESLint plugin that supports SFC-specific
linting rules.
Users previously using Vue CLI may be used to having linters configured via webpack
loaders. However when using a Vite-based build setup, our general recommendation is:Cypress is recommended for E2E tests. It can also be used for component testing for
Vue SFCs via the Cypress Component Test Runner.
Vitest is a test runner created by Vue / Vite team members that focuses on speed. It is
specifically designed for Vite-based applications to provide the same instant feedback
loop for unit / component testing.
Jest can be made to work with Vite via vite-jest. However, this is only recommended if
you have existing Jest-based test suites that you need to migrate over to a Vite-based
setup, as Vitest provides similar functionalities with a much more efficient integration.
Linting
npm install -D eslint eslint-plugin-vue, then follow eslint-plugin-vue's
configuration guide.1.
Setup ESLint IDE extensions, for example ESLint for VSCode, so you get linter feedback
right in your editor during development. This also avoids unnecessary linting cost when
starting the dev server.2.
Run ESLint as part of the production build command, so you get full linter feedback
before shipping to production.3.
(Optional) Setup tools like lint-staged to automatically lint modified files on git commit. 4.
FormattingCustom blocks are compiled into imports to the same Vue file with different request queries.
It is up to the underlying build tool to handle these import requests.
This package is part of the Vue core monorepo and is always published with the same
version as the main vue package. It is included as a dependency of the main vue
package and proxied under vue/compiler-sfc so you don't need to install it individually.
The package itself provides lower-level utilities for processing Vue SFCs and is only meant
for tooling authors that need to support Vue SFCs in custom tools.The Volar VSCode extension provides formatting for Vue SFCs out of the box.
Alternatively, Prettier provides built-in Vue SFC formatting support.
SFC Custom Block Integrations
If using Vite, a custom Vite plugin should be used to transform matched custom blocks
into executable JavaScript. Example
If using Vue CLI or plain webpack, a webpack loader should be configured to transform
the matched blocks. Example
Lower-Level Packages
@vue/compiler-sfc
Docs
TIP
Always prefer using this package via the vue/compiler-sfc deep import since this
ensures its version is in sync with the Vue runtime.ⓘOfficial plugin that provides Vue SFC support in Vite.
The official loader that provides Vue SFC support in webpack. If you are using Vue CLI, also
see docs on modifying vue-loader options in Vue CLI.@vitejs/plugin-vue
Docs
vue-loader
Docs
Other Online Playgrounds
VueUse Playground
Vue + Vite on Repl.it
Vue on CodeSandbox
Vue on Codepen
Vue on Components.studio
Vue on WebComponents.devRouting on the server side means the server sending a response based on the URL path
that the user is visiting. When we click on a link in a traditional server-rendered web app,
the browser receives an HTML response from the server and reloads the entire page with
the new HTML.
In a Single-Page Application (SPA), however, the client-side JavaScript can intercept the
navigation, dynamically fetch new data, and update the current page without full page
reloads. This typically results in a more snappy user experience, especially for use cases
that are more like actual "applications", where the user is expected to perform many
interactions over a long period of time.
In such SPAs, the "routing" is done on the client side, in the browser. A client-side router is
responsible for managing the application's rendered view using browser APIs such as
History API or the hashchange event.
Vue is well-suited for building SPAs. For most SPAs, it's recommended to use the officially-
supported Vue Router library. For more details, see Vue Router's documentation.
If you only need very simple routing and do not wish to involve a full-featured router library,
you can do so with Dynamic Components and update the current component state by
listening to browser hashchange events or using the History API.Routing
Client-Side vs. Server-Side Routing
Official Router
Simple Routing from ScratchHere's a bare-bone example:
Try it in the Playground ▶<script setup>
import { ref, computed } from 'vue'
import Home from './Home.vue'
import About from './About.vue'
import NotFound from './NotFound.vue'
const routes = {
  '/': Home,
  '/about': About
}
const currentPath = ref(window.location.hash)
window.addEventListener('hashchange', () => {
  currentPath.value = window.location.hash
})
const currentView = computed(() => {
  return routes[currentPath.value.slice(1) || '/'] || NotFound
})
</script>
<template>
  <a href="#/">Home</a> |
  <a href="#/about">About</a> |
  <a href="#/non-existent-path">Broken Link</a>
  <component :is="currentView" />
</template>vTechnically, every Vue component instance already "manages" its own reactive state. Take a
simple counter component as an example:
It is a self-contained unit with the following parts:
This is a simple representation of the concept of "one-way data flow":State Management
What is State Management?
The state, the source of truth that drives our app;
The view, a declarative mapping of the state;
The actions, the possible ways the state could change in reaction to user inputs from the
view.<script setup>
import { ref } from 'vue'
// state
const count = ref(0)
// actions
function increment() {
  count.value++
}
</script>
<!-- view -->
<template>{{ count }}</template>vuHowever, the simplicity starts to break down when we have multiple components that
share a common state:
For case one, a possible workaround is by "lifting" the shared state up to a common
ancestor component, and then pass it down as props. However, this quickly gets tedious in
component trees with deep hierarchies, leading to another problem known as Prop Drilling.
For case two, we often find ourselves resorting to solutions such as reaching for direct
parent / child instances via template refs, or trying to mutate and synchronize multiple
copies of the state via emitted events. Both of these patterns are brittle and quickly lead to
unmaintainable code.
A simpler and more straightforward solution is to extract the shared state out of the
components, and manage it in a global singleton. With this, our component tree becomes a
big "view", and any component can access the state or trigger actions, no matter where they
are in the tree!Multiple views may depend on the same piece of state. 1.
Actions from different views may need to mutate the same piece of state. 2.
Simple State Management with Reactivity APIIf you have a piece of state that should be shared by multiple instances, you can use
reactive() to create a reactive object, and then import it into multiple components:
Now whenever the store object is mutated, both <ComponentA> and <ComponentB> will
update their views automatically - we have a single source of truth now.
However, this also means any component importing store can mutate it however they
want:
While this works in simple cases, global state that can be arbitrarily mutated by any
component is not going to be very maintainable in the long run. To ensure the state-// store.js
import { reactive } from 'vue'
export const store = reactive({
  count: 0
})
<!-- ComponentA.vue -->
<script setup>
import { store } from './store.js'
</script>
<template>From A: {{ store.count }}</template>
<!-- ComponentB.vue -->
<script setup>
import { store } from './store.js'
</script>
<template>From B: {{ store.count }}</template>
<template>
  <button @click="store.count++">
    From B: {{ store.count }}
  </button>
</template>vu
vu
templamutating logic is centralized like the state itself, it is recommended to define methods on the
store with names that express the intention of the actions:
Try it in the Playground
Although here we are using a single reactive object as a store, you can also share reactive
state created using other Reactivity APIs such as ref() or computed(), or even return
global state from a Composable:▶
TIP
Note the click handler uses store.increment() with parentheses - this is necessary to
call the method with the proper this context since it's not a component method.ⓘ// store.js
import { reactive } from 'vue'
export const store = reactive({
  count: 0,
  increment() {
    this.count++
  }
})
<template>
  <button @click="store.increment()">
    From B: {{ store.count }}
  </button>
</template>templaThe fact that Vue's reactivity system is decoupled from the component model makes it
extremely flexible.
If you are building an application that leverages Server-Side Rendering (SSR), the above
pattern can lead to issues due to the store being a singleton shared across multiple
requests. This is discussed in more details in the SSR guide.
While our hand-rolled state management solution will suffice in simple scenarios, there are
many more things to consider in large-scale production applications:SSR Considerations
Pinia
Stronger conventions for team collaboration
Integrating with the Vue DevTools, including timeline, in-component inspection, and time-
travel debugging
Hot Module Replacementimport { ref } from 'vue'
// global state, created in module scope
const globalCount = ref(1)
export function useCount() {
  // local state, created per-component
  const localCount = ref(1)
  return {
    globalCount,
    localCount
  }
}Pinia is a state management library that implements all of the above. It is maintained by the
Vue core team, and works with both Vue 2 and Vue 3.
Existing users may be familiar with Vuex, the previous official state management library for
Vue. With Pinia serving the same role in the ecosystem, Vuex is now in maintenance mode. It
still works, but will no longer receive new features. It is recommended to use Pinia for new
applications.
Pinia started out as an exploration of what the next iteration of Vuex could look like,
incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that
Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new
recommendation instead.
Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-
style APIs, and most importantly, has solid type inference support when used with
TypeScript.Server-Side Rendering supportAutomated tests help you and your team build complex Vue applications quickly and
confidently by preventing regressions and encouraging you to break apart your application
into testable functions, modules, classes, and components. As with any application, your
new Vue app can break in many ways, and it's important that you can catch these issues and
fix them before releasing.
In this guide, we'll cover basic terminology and provide our recommendations on which tools
to choose for your Vue 3 application.
There is one Vue-specific section covering composables. See Testing Composables below
for more details.
Start testing early! We recommend you begin writing tests as soon as you can. The longer
you wait to add tests to your application, the more dependencies your application will have,
and the harder it will be to start.
When designing your Vue application's testing strategy, you should leverage the following
testing types:Testing
Why Test?
When to Test
Testing Types
Unit: Checks that inputs to a given function, class, or composable are producing the
expected output or side effects.Each testing type plays a role in your application's testing strategy and each will protect you
against different types of issues.
We will briefly discuss what each of these are, how they can be implemented for Vue
applications, and provide some general recommendations.
Unit tests are written to verify that small, isolated units of code are working as expected. A
unit test usually covers a single function, class, composable, or module. Unit tests focus on
logical correctness and only concern themselves with a small portion of the application's
overall functionality. They may mock large parts of your application's environment (e.g. initial
state, complex classes, 3rd party modules, and network requests).
In general, unit tests will catch issues with a function's business logic and logical
correctness.
Take for example this increment function:Component: Checks that your component mounts, renders, can be interacted with, and
behaves as expected. These tests import more code than unit tests, are more complex,
and require more time to execute.
End-to-end: Checks features that span multiple pages and make real network requests
against your production-built Vue application. These tests often involve standing up a
database or other backend.
Overview
Unit TestingBecause it's very self-contained, it'll be easy to invoke the increment function and assert
that it returns what it's supposed to, so we'll write a Unit Test.
If any of these assertions fail, it's clear that the issue is contained within the increment
function.
As mentioned previously, unit testing is typically applied to self-contained business logic,
components, classes, modules, or functions that do not involve UI rendering, network
requests, or other environmental concerns.
These are typically plain JavaScript / TypeScript modules unrelated to Vue. In general,
writing unit tests for business logic in Vue applications does not differ significantly from
applications using other frameworks.
There are two instances where you DO unit test Vue-specific features:// helpers.js
export function increment (current, max = 10) {
  if (current < max) {
    return current + 1
  }
  return current
}
// helpers.spec.js
import { increment } from './helpers'
describe('increment', () => {
  test('increments the current number by 1', () => {
    expect(increment(0, 10)).toBe(1)
  })
  test('does not increment the current number over the max', () => {
    expect(increment(10, 10)).toBe(10)
  })
  test('has a default max of 10', () => {
    expect(increment(10)).toBe(10)
  })
})One category of functions specific to Vue applications are Composables, which may require
special handling during tests. See Testing Composables below for more details.
A component can be tested in two ways:Composables 1.
Components 2.
Composables
Unit Testing Components
Whitebox: Unit Testing
Tests that are "Whitebox tests" are aware of the implementation details and
dependencies of a component. They are focused on isolating the component under test.
These tests will usually involve mocking some, if not all of your component's children, as
well as setting up plugin state and dependencies (e.g. Vuex).1.
Blackbox: Component Testing
Tests that are "Blackbox tests" are unaware of the implementation details of a
component. These tests mock as little as possible to test the integration of your
component and the entire system. They usually render all child components and are
considered more of an "integration test". See the Component Testing
recommendations below.2.
Recommendation
Vitest
Since the official setup created by create-vue is based on Vite, we recommend using a
unit testing framework that can leverage the same configuration and transform pipeline
directly from Vite. Vitest is a unit testing framework designed specifically for this
purpose, created and maintained by Vue / Vite team members. It integrates with Vite-
based projects with minimal effort, and is blazing fast.In Vue applications, components are the main building blocks of the UI. Components are
therefore the natural unit of isolation when it comes to validating your application's behavior.
From a granularity perspective, component testing sits somewhere above unit testing and
can be considered a form of integration testing. Much of your Vue Application should be
covered by a component test and we recommend that each Vue component has its own
spec file.
Component tests should catch issues relating to your component's props, events, slots that
it provides, styles, classes, lifecycle hooks, and more.
Component tests should not mock child components, but instead test the interactions
between your component and its children by interacting with the components as a user
would. For example, a component test should click on an element like a user would instead
of programmatically interacting with the component.
Component tests should focus on the component's public interfaces rather than internal
implementation details. For most components, the public interface is limited to: events
emitted, props, and slots. When testing, remember to test what a component does, not
how it does it.
DOOther Options
Peeky is another fast unit test runner with first-class Vite integration. It is also created by
a Vue core team member and offers a GUI-based testing interface.
Jest is a popular unit testing framework, and can be made to work with Vite via the vite-
jest package. However, we only recommend Jest if you have an existing Jest test suite
that needs to be migrated over to a Vite-based project, as Vitest offers a more seamless
integration and better performance.
Component Testing
For Visual logic: assert correct render output based on inputted props and slots.Vue Test UtilsCypress
Testing LibraryFor Behavioral logic: assert correct render updates or emitted events in response to user
input events.
In the below example, we demonstrate a Stepper component that has a DOM element
labeled "increment" and can be clicked. We pass a prop called max that prevents the
Stepper from being incremented past 2, so if we click the button 3 times, the UI should
still say 2.
We know nothing about the implementation of Stepper, only that the "input" is the max
prop and the "output" is the state of the DOM as the user will see it.
DON'T
Don't assert the private state of a component instance or test the private methods of a
component. Testing implementation details makes the tests brittle, as they are more likely
to break and require updates when the implementation changes.
The component's ultimate job is rendering the correct DOM output, so tests focusing on
the DOM output provide the same level of correctness assurance (if not more) while
being more robust and resilient to change.
Don't rely exclusively on snapshot tests. Asserting HTML strings does not describe
correctness. Write tests with intentionality.const valueSelector = '[data-testid=stepper-value]'
const buttonSelector = '[data-testid=increment]'
const wrapper = mount(Stepper, {
  props: {
    max: 1
  }
})
expect(wrapper.find(valueSelector).text()).toContain('0')
await wrapper.find(buttonSelector).trigger('click')
expect(wrapper.find(valueSelector).text()).toContain('1')The main differences between Vitest and browser-based runners are speed and execution
context. In short, browser-based runners, like Cypress, can catch issues that node-based
runners, like Vitest, cannot (e.g. style issues, real native DOM events, cookies, local storage,
and network failures), but browser-based runners are orders of magnitude slower than
Vitest because they do open a browser, compile your stylesheets, and more. Cypress is a
browser-based runner that supports component testing. Please read Vitest's comparison
page for the latest information comparing Vitest and Cypress.
Component testing often involves mounting the component being tested in isolation,
triggering simulated user input events, and asserting on the rendered DOM output. There
are dedicated utility libraries that make these tasks simpler.If a method needs to be tested thoroughly, consider extracting it into a standalone utility
function and write a dedicated unit test for it. If it cannot be extracted cleanly, it may be
tested as a part of a component, integration, or end-to-end test that covers it.
Recommendation
Vitest for components or composables that render headlessly (e.g. the useFavicon
function in VueUse). Components and DOM can be tested using @testing-library/vue.
Cypress Component Testing for components whose expected behavior depends on
properly rendering styles or triggering native DOM events. Can be used with Testing
Library via @testing-library/cypress.
Mounting Libraries
@testing-library/vue is a Vue testing library focused on testing components without
relying on implementation details. Built with accessibility in mind, its approach also makes
refactoring a breeze. Its guiding principle is that the more tests resemble the way
software is used, the more confidence they can provide.
@vue/test-utils is the official low-level component testing library that was written to
provide users access to Vue specific APIs. It's also the lower-level library @testing-
library/vue is built on top of.We recommend using @testing-library/vue for testing components in applications, as
its focus aligns better with the testing priorities of applications. Use @vue/test-utils only
if you are building advanced components that require testing Vue-specific internals.
While unit tests provide developers with some degree of confidence, unit and component
tests are limited in their abilities to provide holistic coverage of an application when
deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is
arguably the most important aspect of an application: what happens when users actually
use your applications.
End-to-end tests focus on multi-page application behavior that makes network requests
against your production-built Vue application. They often involve standing up a database or
other backend and may even be run against a live staging environment.
End-to-end tests will often catch issues with your router, state management library, top-
level components (e.g. an App or Layout), public assets, or any request handling. As stated
above, they catch critical issues that may be impossible to catch with unit tests or
component tests.
End-to-end tests do not import any of your Vue application's code, but instead rely
completely on testing your application by navigating through entire pages in a real browser.
End-to-end tests validate many of the layers in your application. They can either target your
locally built application, or even a live Staging environment. Testing against your Staging
environment not only includes your frontend code and static server, but all associated
backend services and infrastructure.Other Options
Nightwatch is an E2E test runner with Vue Component Testing support. (Example
Project in Nightwatch v2)
E2E TestingThe more your tests resemble the way your software is used, the more confidence they
can give you. - Kent C. Dodds - Author of the Testing Library
By testing how user actions impact your application, E2E tests are often the key to higher
confidence in whether an application is functioning properly or not.
While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable
(flaky) tests and slowing down development processes, modern E2E tools have made strides
forward to create more reliable, interactive, and useful tests. When choosing an E2E testing
framework, the following sections provide some guidance on things to keep in mind when
choosing a testing framework for your application.
One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test
your application across multiple browsers. While it may seem desirable to have 100% cross-
browser coverage, it is important to note that cross browser testing has diminishing returns
on a team's resources due the additional time and machine power required to run them
consistently. As a result, it is important to be mindful of this trade-off when choosing the
amount of cross-browser testing your application needs.
One of the primary problems with end-to-end (E2E) tests and development is that running
the entire suite takes a long time. Typically, this is only done in continuous integration and
deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by
adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes
faster than before. In addition, when developing locally, the ability to selectively run a single
test for the page you are working on while also providing hot reloading of tests can help to
boost a developer's workflow and productivity.
While developers have traditionally relied on scanning logs in a terminal window to help
determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow
developers to leverage tools that they are already familiar with, e.g. browser developer tools.Choosing an E2E Testing Solution
Cross-browser testing
Faster feedback loops
First-class debugging experienceWhen end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they
are often run in headless browsers (i.e., no visible browser is opened for the user to watch).
A critical feature of modern E2E testing frameworks is the ability to see snapshots and/or
videos of the application during testing, providing some insight into why errors are
happening. Historically, it was tedious to maintain these integrations.
In a Vite-based Vue project, run:Visibility in headless mode
Recommendation
Cypress
Overall, we believe Cypress provides the most complete E2E solution with features like an
informative graphical interface, excellent debuggability, built-in assertions and stubs,
flake-resistance, parallelization, and snapshots. As mentioned above, it also provides
support for Component Testing. However, it only supports Chromium-based browsers
and Firefox.
Other Options
Playwright is also a great E2E testing solution with a wider range of browser support
(mainly WebKit). See Why Playwright for more details.
Nightwatch v2 is an E2E testing solution based on Selenium WebDriver. This gives it the
widest browser support range.
Recipes
Adding Vitest to a Project
> npm install -D vitest happy-dom @testing-library/vuesNext, update the Vite configuration to add the test option block:
Then create a file ending in *.test.js in your project. You can place all test files in a test
directory in project root, or in test directories next to your source files. Vitest will
automatically search for them using the naming convention.TIP
If you are using TypeScript, add vitest/globals to the types field in your
tsconfig.json.ⓘ// vite.config.js
import { defineConfig } from 'vite'
export default defineConfig({
  // ...
  test: {
    // enable jest-like global test APIs
    globals: true,
    // simulate DOM with happy-dom
    // (requires installing happy-dom as a peer dependency)
    environment: 'happy-dom'
  }
})
// tsconfig.json
{
 "compilerOptions": {
    "types": ["vitest/globals"]
  }
}jsonFinally, update package.json to add the test script and run it:
This section assumes you have read the Composables section.
When it comes to testing composables, we can divide them into two categories:
composables that do not rely on a host component instance, and composables that do.
A composable depends on a host component instance when it uses the following APIs:
If a composable only uses Reactivity APIs, then it can be tested by directly invoking it and
asserting its returned state / methods:Testing Composables
Lifecycle hooks
Provide / Inject// MyComponent.test.js
import { render } from '@testing-library/vue'
import MyComponent from './MyComponent.vue'
test('it should work', () => {
  const { getByText } = render(MyComponent, {
    props: {
      /* ... */
    }
  })
  // assert output
  getByText('...')
})
{
  // ...
  "scripts": {
    "test": "vitest"
  }
}
> npm testjso
sA composable that relies on lifecycle hooks or Provide / Inject needs to be wrapped in a host
component to be tested. We can create a helper like the following:// counter.js
import { ref } from 'vue'
export function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  return {
    count,
    increment
  }
}
// counter.test.js
import { useCounter } from './counter.js'
test('useCounter', () => {
  const { count, increment } = useCounter()
  expect(count.value).toBe(0)
  increment()
  expect(count.value).toBe(1)
})For more complex composables, it could also be easier to test it by writing tests against the
wrapper component using Component Testing techniques.// test-utils.js
import { createApp } from 'vue'
export function withSetup(composable) {
  let result
  const app = createApp({
    setup() {
      result = composable()
      // suppress missing template warning
      return () => {}
    }
  })
  app.mount(document.createElement('div'))
  // return the result and the app instance
  // for testing provide / unmount
  return [result, app]
}
import { withSetup } from './test-utils'
import { useFoo } from './foo'
test('useFoo', () => {
  const [result, app] = withSetup(() => useFoo(123))
  // mock provide for testing injections
  app.provide(...)
  // run assertions
  expect(result.foo.value).toBe(1)
  // trigger onUnmounted hook if needed
  app.unmount()
})Vue.js is a framework for building client-side applications. By default, Vue components
produce and manipulate DOM in the browser as output. However, it is also possible to render
the same components into HTML strings on the server, send them directly to the browser,
and finally "hydrate" the static markup into a fully interactive app on the client.
A server-rendered Vue.js app can also be considered "isomorphic" or "universal", in the
sense that the majority of your app's code runs on both the server and the client.
Compared to a client-side Single-Page Application (SPA), the advantage of SSR primarily
lies in:Server-Side Rendering (SSR)
Overview
What is SSR?
Why SSR?
Faster time-to-content: this is more prominent on slow internet or slow devices. Server-
rendered markup doesn't need to wait until all JavaScript has been downloaded and
executed to be displayed, so your user will see a fully-rendered page sooner. In addition,
data fetching is done on the server-side for the initial visit, which likely has a faster
connection to your database than the client. This generally results in improved Core Web
Vitals metrics, better user experience, and can be critical for applications where time-to-
content is directly associated with conversion rate.
Unified mental model: you get to use the same language and the same declarative,
component-oriented mental model for developing your entire app, instead of jumping
back and forth between a backend templating system and a frontend framework.
Better SEO: the search engine crawlers will directly see the fully rendered page.There are also some trade-offs to consider when using SSR:
Before using SSR for your app, the first question you should ask is whether you actually
need it. It mostly depends on how important time-to-content is for your app. For example, if
you are building an internal dashboard where an extra few hundred milliseconds on initial
load doesn't matter that much, SSR would be an overkill. However, in cases where time-to-
content is absolutely critical, SSR can help you achieve the best possible initial load
performance.
Static Site Generation (SSG), also referred to as pre-rendering, is another popular
technique for building fast websites. If the data needed to server-render a page is the same
for every user, then instead of rendering the page every time a request comes in, we can
render it only once, ahead of time, during the build process. Pre-rendered pages are
generated and served as static HTML files.TIP
As of now, Google and Bing can index synchronous JavaScript applications just fine.
Synchronous being the key word there. If your app starts with a loading spinner, then
fetches content via Ajax, the crawler will not wait for you to finish. This means if you
have content fetched asynchronously on pages where SEO is important, SSR might be
necessary.ⓘ
Development constraints. Browser-specific code can only be used inside certain lifecycle
hooks; some external libraries may need special treatment to be able to run in a server-
rendered app.
More involved build setup and deployment requirements. Unlike a fully static SPA that can
be deployed on any static file server, a server-rendered app requires an environment
where a Node.js server can run.
More server-side load. Rendering a full app in Node.js is going to be more CPU-intensive
than just serving static files, so if you expect high traffic, be prepared for corresponding
server load and wisely employ caching strategies.
SSR vs. SSGSSG retains the same performance characteristics of SSR apps: it provides great time-to-
content performance. At the same time, it is cheaper and easier to deploy than SSR apps
because the output is static HTML and assets. The keyword here is static: SSG can only be
applied to pages consuming static data, i.e. data that is known at build time and does not
change between deploys. Every time the data changes, a new deployment is needed.
If you're only investigating SSR to improve the SEO of a handful of marketing pages (e.g. /,
/about, /contact, etc.), then you probably want SSG instead of SSR. SSG is also great
for content-based websites such as documentation sites or blogs. In fact, this website you
are reading right now is statically generated using VitePress, a Vue-powered static site
generator.
Let's take a look at the most bare-bones example of Vue SSR in action.Basic Tutorial
Rendering an App
Create a new directory and cd into it 1.
Run npm init -y 2.
Add "type": "module" in package.json so that Node.js runs in ES modules mode. 3.
Run npm install vue 4.
Create an example.js file: 5.Then run:
It should print the following to the command line:
renderToString() takes a Vue app instance and returns a Promise that resolves to the
rendered HTML of the app. It is also possible to stream rendering using the Node.js Stream
API or Web Streams API. Check out the SSR API Reference for full details.
We can then move the Vue SSR code into a server request handler, which wraps the
application markup with the full page HTML. We will be using express for the next steps:
Run npm install express
Create the following server.js file:// this runs in Node.js on the server.
import { createSSRApp } from 'vue'
// Vue's server-rendering API is exposed under `vue/server-renderer`.
import { renderToString } from 'vue/server-renderer'
const app = createSSRApp({
  data: () => ({ count: 1 }),
  template: `<button @click="count++">{{ count }}</button>`
})
renderToString(app).then((html) => {
  console.log(html)
})
> node example.js
<button>1</button>sFinally, run node server.js and visit http://localhost:3000. You should see the page
working with the button.
Try it on StackBlitz
If you click the button, you'll notice the number doesn't change. The HTML is completely
static on the client since we are not loading Vue in the browser.Client Hydrationimport express from 'express'
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'
const server = express()
server.get('/', (req, res) => {
  const app = createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
  renderToString(app).then((html) => {
    res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>Vue SSR Example</title>
      </head>
      <body>
        <div id="app">${html}</div>
      </body>
    </html>
    `)
  })
})
server.listen(3000, () => {
  console.log('ready')
})To make the client-side app interactive, Vue needs to perform the hydration step. During
hydration, it creates the same Vue application that was run on the server, matches each
component to the DOM nodes it should control, and attaches DOM event listeners.
To mount an app in hydration mode, we need to use createSSRApp() instead of
createApp():
Notice how we need to reuse the same app implementation as on the server. This is where
we need to start thinking about code structure in an SSR app - how do we share the same
application code between the server and the client?
Here we will demonstrate the most bare-bones setup. First, let's split the app creation logic
into a dedicated file, app.js:Code Structure// this runs in the browser.
import { createSSRApp } from 'vue'
const app = createSSRApp({
  // ...same app as on server
})
// mounting an SSR app on the client assumes
// the HTML was pre-rendered and will perform
// hydration instead of mounting new DOM nodes.
app.mount('#app')
// app.js (shared between server and client)
import { createSSRApp } from 'vue'
export function createApp() {
  return createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
}This file and its dependencies are shared between the server and the client - we call them
universal code. There are a number of things you need to pay attention to when writing
universal code, as we will discuss below.
Our client entry imports the universal code, creates the app, and performs the mount:
And the server uses the same app creation logic in the request handler:
In addition, in order to load the client files in the browser, we also need to:
Try the completed example on StackBlitz. The button is now interactive!Serve client files by adding server.use(express.static('.')) in server.js. 1.
Load the client entry by adding <script type="module" src="/client.js"></script>
to the HTML shell.2.
Support usage like import * from 'vue' in the browser by adding an Import Map to
the HTML shell.3.
Higher Level Solutions// client.js
import { createApp } from './app.js'
createApp().mount('#app')
// server.js (irrelevant code omitted)
import { createApp } from './app.js'
server.get('/', (req, res) => {
  const app = createApp()
  renderToString(app).then(html => {
    // ...
  })
})Moving from the example to a production-ready SSR app involves a lot more. We will need
to:
A complete implementation would be quite complex and depends on the build toolchain you
have chosen to work with. Therefore, we highly recommend going with a higher-level,
opinionated solution that abstracts away the complexity for you. Below we will introduce a
few recommended SSR solutions in the Vue ecosystem.
Nuxt is a higher-level framework built on top of the Vue ecosystem which provides a
streamlined development experience for writing universal Vue applications. Better yet, you
can also use it as a static site generator! We highly recommend giving it a try.
Quasar is a complete Vue-based solution that allows you to target SPA, SSR, PWA, mobile
app, desktop app, and browser extension all using one codebase. It not only handles the
build setup, but also provides a full collection of Material Design compliant UI components.Support Vue SFCs and other build step requirements. In fact, we will need to coordinate
two builds for the same app: one for the client, and one for the server.
TIP
Vue components are compiled differently when used for SSR - templates are compiled
into string concatenations instead of Virtual DOM render functions for more efficient
rendering performance.ⓘ
In the server request handler, render the HTML with the correct client-side asset links and
optimal resource hints. We may also need to switch between SSR and SSG mode, or even
mix both in the same app.
Manage routing, data fetching, and state management stores in a universal manner.
Nuxt
QuasarVite provides built-in support for Vue server-side rendering, but it is intentionally low-
level. If you wish to go directly with Vite, check out vite-plugin-ssr, a community plugin that
abstracts away many challenging details for you.
You can also find an example Vue + Vite SSR project using manual setup here, which can
serve as a base to build upon. Note this is only recommended if you are experienced with
SSR / build tools and really want to have complete control over the higher-level architecture.
Regardless of your build setup or higher-level framework choice, there are some principles
that apply in all Vue SSR applications.
During SSR, each request URL maps to a desired state of our application. There is no user
interaction and no DOM updates, so reactivity is unnecessary on the server. By default,
reactivity is disabled during SSR for better performance.
Since there are no dynamic updates, lifecycle hooks such as onMounted or onUpdated will
NOT be called during SSR and will only be executed on the client.
You should avoid code that produces side effects that need cleanup in setup() or the root
scope of <script setup>. An example of such side effects is setting up timers with
setInterval. In client-side only code we may setup a timer and then tear it down in
onBeforeUnmount or onUnmounted. However, because the unmount hooks will never be
called during SSR, the timers will stay around forever. To avoid this, move your side-effect
code into onMounted instead.Vite SSR
Writing SSR-friendly Code
Reactivity on the Server
Component Lifecycle HooksUniversal code cannot assume access to platform-specific APIs, so if your code directly
uses browser-only globals like window or document, they will throw errors when executed
in Node.js, and vice-versa.
For tasks that are shared between server and client but with different platform APIs, it's
recommended to wrap the platform-specific implementations inside a universal API, or use
libraries that do this for you. For example, you can use node-fetch to use the same fetch
API on both server and client.
For browser-only APIs, the common approach is to lazily access them inside client-only
lifecycle hooks such as onMounted.
Note that if a third-party library is not written with universal usage in mind, it could be tricky
to integrate it into a server-rendered app. You might be able to get it working by mocking
some of the globals, but it would be hacky and may interfere with the environment detection
code of other libraries.
In the State Management chapter, we introduced a simple state management pattern
using Reactivity APIs. In an SSR context, this pattern requires some additional adjustments.
The pattern declares shared state in a JavaScript module's root scope. This makes them
singletons - i.e. there is only one instance of the reactive object throughout the entire
lifecycle of our application. This works as expected in a pure client-side Vue application,
since the modules in our application are initialized fresh for each browser page visit.
However, in an SSR context, the application modules are typically initialized only once on the
server, when the server boots up. The same module instances will be reused across multiple
server requests, and so will our singleton state objects. If we mutate the shared singleton
state with data specific to one user, it can be accidentally leaked to a request from another
user. We call this cross-request state pollution.
We can technically re-initialize all the JavaScript modules on each request, just like we do in
browsers. However, initializing JavaScript modules can be costly, so this would significantly
affect server performance.Access to Platform-Specific APIs
Cross-Request State PollutionThe recommended solution is to create a new instance of the entire application - including
the router and global stores - on each request. Then, instead of directly importing it in our
components, we provide the shared state using app-level provide and inject it in
components that need it:
State Management libraries like Pinia are designed with this in mind. Consult Pinia's SSR
guide for more details.
If the DOM structure of the pre-rendered HTML does not match the expected output of the
client-side app, there will be a hydration mismatch error. Hydration mismatch is most
commonly introduced by the following causes:Hydration Mismatch
The template contains invalid HTML nesting structure, and the rendered HTML got
"corrected" by the browser's native HTML parsing behavior. For example, a common
gotcha is that <div> cannot be placed inside <p>:
If we produce this in our server-rendered HTML, the browser will terminate the first <p>
when <div> is encountered and parse it into the following DOM structure:1.// app.js (shared between server and client)
import { createSSRApp } from 'vue'
import { createStore } from './store.js'
// called on each request
export function createApp() {
  const app = createSSRApp(/* ... */)
  // create new instance of store per request
  const store = createStore(/* ... */)
  // provide store at the app level
  app.provide('store', store)
  // also expose store for hydration purposes
  return { app, store }
}
<p><div>hi</div></p>htmWhen Vue encounters a hydration mismatch, it will attempt to automatically recover and
adjust the pre-rendered DOM to match the client-side state. This will lead to some rendering
performance loss due to incorrect nodes being discarded and new nodes being mounted,
but in most cases, the app should continue to work as expected. That said, it is still best to
eliminate hydration mismatches during development.
Since most custom directives involve direct DOM manipulation, they are ignored during SSR.
However, if you want to specify how a custom directive should be rendered (i.e. what
attributes it should add to the rendered element), you can use the getSSRProps directive
hook:The data used during render contains randomly generated values. Since the same
application will run twice - once on the server, and once on the client - the random values
are not guaranteed to be the same between the two runs. There are two ways to avoid
random-value-induced mismatches:2.
Use v-if + onMounted to render the part that depends on random values only on
the client. Your framework may also have built-in features to make this easier, for
example the <ClientOnly> component in VitePress.1.
Use a random number generator library that supports generating with seeds, and
guarantee the server run and the client run are using the same seed (e.g. by including
the seed in serialized state and retrieving it on the client).2.
The server and the client are in different time zones. Sometimes, we may want to convert
a timestamp into the user's local time. However, the timezone during the server run and
the timezone during the client run are not always the same, and we may not reliably know
the user's timezone during the server run. In such cases, the local time conversion
should also be performed as a client-only operation.3.
Custom Directives<p></p>
<div>hi</div>
<p></p>htmTeleports require special handling during SSR. If the rendered app contains Teleports, the
teleported content will not be part of the rendered string. An easier solution is to
conditionally render the Teleport on mount.
If you do need to hydrate teleported content, they are exposed under the teleports
property of the ssr context object:
You need to inject the teleport markup into the correct location in your final page HTML
similar to how you need to inject the main app markup.Teleportsconst myDirective = {
  mounted(el, binding) {
    // client-side implementation:
    // directly update the DOM
    el.id = binding.value
  },
  getSSRProps(binding) {
    // server-side implementation:
    // return the props to be rendered.
    // getSSRProps only receives the directive binding.
    return {
      id: binding.value
    }
  }
}
const ctx = {}
const html = await renderToString(app, ctx)
console.log(ctx.teleports) // { '#teleported': 'teleported content' }TIP
Avoid targeting body when using Teleports and SSR together - usually, <body> will
contain other server-rendered content which makes it impossible for Teleports to
determine the correct starting location for hydration.
Instead, prefer a dedicated container, e.g. <div id="teleported"></div> which
contains only teleported content.ⓘDuring development, Vue provides a number of features to improve the development
experience:
However, these features become useless in production. Some of the warning checks can
also incur a small amount of performance overhead. When deploying to production, we
should drop all the unused, development-only code branches for smaller payload size and
better performance.
If you are using Vue without a build tool by loading it from a CDN or self-hosted script, make
sure to use the production build (dist files that end in .prod.js) when deploying to
production. Production builds are pre-minified with all development-only code branches
removed.
Consult the dist file guide for more details.Production Deployment
Development vs. Production
Warning for common errors and pitfalls
Props / events validation
Reactivity debugging hooks
Devtools integration
Without Build Tools
If using global build (accessing via the Vue global): use vue.global.prod.js.
If using ESM build (accessing via native ESM imports): use vue.esm-browser.prod.js.
With Build ToolsProjects scaffolded via create-vue (based on Vite) or Vue CLI (based on webpack) are
pre-configured for production builds.
If using a custom setup, make sure that:
Additional references:
The app-level error handler can be used to report errors to tracking services:
Services such as Sentry and Bugsnag also provide official integrations for Vue.vue resolves to vue.runtime.esm-bundler.js. 1.
The compile time feature flags are properly configured. 2.
process.env.NODE_ENV is replaced with "production" during build. 3.
Vite production build guide
Vite deployment guide
Vue CLI deployment guide
Tracking Runtime Errors
import { createApp } from 'vue'
const app = createApp(...)
app.config.errorHandler = (err, instance, info) => {
  // report error to tracking services
}Vue is designed to be performant for most common use cases without much need for
manual optimizations. However, there are always challenging scenarios where extra fine-
tuning is needed. In this section, we will discuss what you should pay attention to when it
comes to performance in a Vue application.
First, let's discuss the two major aspects of web performance:
While it would be ideal to maximize both, different frontend architectures tend to affect how
easy it is to attain desired performance in these aspects. In addition, the type of application
you are building greatly influences what you should prioritize in terms of performance.
Therefore, the first step of ensuring optimal performance is picking the right architecture for
the type of application you are building:Performance
Overview
Page Load Performance: how fast the application shows content and becomes
interactive on the initial visit. This is usually measured using web vital metrics like Largest
Contentful Paint (LCP) and First Input Delay (FID).
Update Performance: how fast the application updates in response to user input. For
example, how fast a list updates when the user types in a search box, or how fast the
page switches when the user clicks a navigation link in a Single-Page Application (SPA).
Consult Ways of Using Vue to see how you can leverage Vue in different ways.
Jason Miller discusses the types of web applications and their respective ideal
implementation / delivery in Application Holotypes.
Profiling OptionsTo improve performance, we need to first know how to measure it. There are a number of
great tools that can help in this regard:
For profiling load performance of production deployments:
For profiling performance during local development:
There are many framework-agnostic aspects for optimizing page load performance - check
out this web.dev guide for a comprehensive round up. Here, we will primarily focus on
techniques that are specific to Vue.
If your use case is sensitive to page load performance, avoid shipping it as a pure client-side
SPA. You want your server to be directly sending HTML containing the content the users
want to see. Pure client-side rendering suffers from slow time-to-content. This can be
mitigated with Server-Side Rendering (SSR) or Static Site Generation (SSG). Check out
the SSR Guide to learn about performing SSR with Vue. If your app doesn't have rich
interactivity requirements, you can also use a traditional backend server to render the HTML
and enhance it with Vue on the client.
If your main application has to be an SPA, but has marketing pages (landing, about, blog),
ship them separately! Your marketing pages should ideally be deployed as static HTML with
minimal JS, by using SSG.PageSpeed Insights
WebPageTest
Chrome DevTools Performance Panel
app.config.performance enables Vue-specific performance markers in Chrome
DevTools' performance timeline.
Vue DevTools Extension also provides a performance profiling feature.
Page Load Optimizations
Choosing the Right ArchitectureOne of the most effective ways to improve page load performance is shipping smaller
JavaScript bundles. Here are a few ways to reduce bundle size when using Vue:
Code splitting is where a build tool splits the application bundle into multiple smaller chunks,
which can then be loaded on demand or in parallel. With proper code splitting, features
required at page load can be downloaded immediately, with additional chunks being lazy
loaded only when needed, thus improving performance.Bundle Size and Tree-shaking
Use a build step if possible.
Many of Vue's APIs are "tree-shakable" if bundled via a modern build tool. For
example, if you don't use the built-in <Transition> component, it won't be included
in the final production bundle. Tree-shaking can also remove other unused modules in
your source code.
When using a build step, templates are pre-compiled so we don't need to ship the Vue
compiler to the browser. This saves 14kb min+gzipped JavaScript and avoids the
runtime compilation cost.
Be cautious of size when introducing new dependencies! In real-world applications,
bloated bundles are most often a result of introducing heavy dependencies without
realizing it.
If using a build step, prefer dependencies that offer ES module formats and are tree-
shaking friendly. For example, prefer lodash-es over lodash.
Check a dependency's size and evaluate whether it is worth the functionality it
provides. Note if the dependency is tree-shaking friendly, the actual size increase will
depend on the APIs you actually import from it. Tools like bundlejs.com can be used
for quick checks, but measuring with your actual build setup will always be the most
accurate.
If you are using Vue primarily for progressive enhancement and prefer to avoid a build
step, consider using petite-vue (only 6kb) instead.
Code SplittingBundlers like Rollup (which Vite is based upon) or webpack can automatically create split
chunks by detecting the ESM dynamic import syntax:
Lazy loading is best used on features that are not immediately needed after initial page load.
In Vue applications, this can be used in combination with Vue's Async Component feature
to create split chunks for component trees:
For applications using Vue Router, it is strongly recommended to use lazy loading for route
components. Vue Router has explicit support for lazy loading, separate from
defineAsyncComponent. See Lazy Loading Routes for more details.
In Vue, a child component only updates when at least one of its received props has
changed. Consider the following example:Update Optimizations
Props Stability// lazy.js and its dependencies will be split into a separate chunk
// and only loaded when `loadLazy()` is called.
function loadLazy() {
  return import('./lazy.js')
}
import { defineAsyncComponent } from 'vue'
// a separate chunk is created for Foo.vue and its dependencies.
// it is only fetched on demand when the async component is
// rendered on the page.
const Foo = defineAsyncComponent(() => import('./Foo.vue'))Inside the <ListItem> component, it uses its id and activeId props to determine
whether it is the currently active item. While this works, the problem is that whenever
activeId changes, every<ListItem> in the list has to update!
Ideally, only the items whose active status changed should update. We can achieve that by
moving the active status computation into the parent, and make <ListItem> directly
accept an active prop instead:
Now, for most components the active prop will remain the same when activeId
changes, so they no longer need to update. In general, the idea is keeping the props passed
to child components as stable as possible.
v-once is a built-in directive that can be used to render content that relies on runtime data
but never needs to update. The entire sub-tree it is used on will be skipped for all future
updates. Consult its API reference for more details.
v-memo is a built-in directive that can be used to conditionally skip the update of large sub-
trees or v-for lists. Consult its API reference for more details.v-once
v-memo<ListItem
  v-for="item in list"
  :id="item.id"
  :active-id="activeId" />
<ListItem
  v-for="item in list"
  :id="item.id"
  :active="item.id === activeId" />templa
templaThe following tips affect both page load and update performance.
One of the most common performance issues in all frontend applications is rendering large
lists. No matter how performant a framework is, rendering a list with thousands of items will
be slow due to the sheer number of DOM nodes that the browser needs to handle.
However, we don't necessarily have to render all these nodes upfront. In most cases, the
user's screen size can display only a small subset of our large list. We can greatly improve
the performance with list virtualization, the technique of only rendering the items that are
currently in or close to the viewport in a large list.
Implementing list virtualization isn't easy, luckily there are existing community libraries that
you can directly use:
Vue's reactivity system is deep by default. While this makes state management intuitive, it
does create a certain level of overhead when the data size is large, because every property
access triggers proxy traps that perform dependency tracking. This typically becomes
noticeable when dealing with large arrays of deeply nested objects, where a single render
needs to access 100,000+ properties, so it should only affect very specific use cases.
Vue does provide an escape hatch to opt-out of deep reactivity by using shallowRef()
and shallowReactive(). Shallow APIs create state that is reactive only at the root level,
and exposes all nested objects untouched. This keeps nested property access fast, with the
trade-off being that we must now treat all nested objects as immutable, and updates can
only be triggered by replacing the root state:General Optimizations
Virtualize Large Lists
vue-virtual-scroller
vue-virtual-scroll-grid
vueuc/VVirtualList
Reduce Reactivity Overhead for Large Immutable StructuresSometimes we may create renderless components or higher-order components (i.e.
components that render other components with extra props) for better abstraction or code
organization. While there is nothing wrong with this, do keep in mind that component
instances are much more expensive than plain DOM nodes, and creating too many of them
due to abstraction patterns will incur performance costs.
Note that reducing only a few instances won't have noticeable effect, so don't sweat it if the
component is rendered only a few times in the app. The best scenario to consider this
optimization is again in large lists. Imagine a list of 100 items where each item component
contains many child components. Removing one unnecessary component abstraction here
could result in a reduction of hundreds of component instances.Avoid Unnecessary Component Abstractionsconst shallowArray = shallowRef([
  /* big list of deep objects */
])
// this won't trigger updates...
shallowArray.value.push(newObject)
// this does:
shallowArray.value = [...shallowArray.value, newObject]
// this won't trigger updates...
shallowArray.value[0].foo = 1
// this does:
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]Web accessibility (also known as a11y) refers to the practice of creating websites that can
be used by anyone — be that a person with a disability, a slow connection, outdated or
broken hardware or simply someone in an unfavorable environment. For example, adding
subtitles to a video would help both your deaf and hard-of-hearing users and your users
who are in a loud environment and can't hear their phone. Similarly, making sure your text
isn't too low contrast will help both your low-vision users and your users who are trying to
use their phone in bright sunlight.
Ready to start but arenʼt sure where?
Checkout the Planning and managing web accessibility guide provided by World Wide
Web Consortium (W3C)
You should add a link at the top of each page that goes directly to the main content area so
users can skip content that is repeated on multiple Web pages.
Typically this is done on the top of App.vue as it will be the first focusable element on all
your pages:
To hide the link unless it is focused, you can add the following style:Accessibility
Skip link
<ul class="skip-links">
  <li>
    <a href="#main" ref="skipLink" class="skip-link">Skip to main content</a>
  </li>
</ul>templaOnce a user changes route, bring focus back to the skip link. This can be achieved by
calling focus on the skip link's template ref (assuming usage of vue-router):
Read documentation on skip link to main content
Content Structure.skip-link {
  white-space: nowrap;
  margin: 1em auto;
  top: 0;
  position: fixed;
  left: 50%;
  margin-left: -72px;
  opacity: 0;
}
.skip-link:focus {
  opacity: 1;
  background-color: white;
  padding: 0.5em;
  border: 1px solid black;
}
<script setup>
import { ref, watch } from 'vue'
import { useRoute } from 'vue-router'
const route = useRoute()
const skipLink = ref()
watch(
  () => route.path,
  () => {
    skipLink.value.focus()
  }
)
</script>c
vOne of the most important pieces of accessibility is making sure that design can support
accessible implementation. Design should consider not only color contrast, font selection,
text sizing, and language, but also how the content is structured in the application.
Users can navigate an application through headings. Having descriptive headings for every
section of your application makes it easier for users to predict the content of each section.
When it comes to headings, there are a couple of recommended accessibility practices:
Read more about headings
Landmarks provide programmatic access to sections within an application. Users who rely
on assistive technology can navigate to each section of the application and skip over
content. You can use ARIA roles to help you achieve this.Headings
Nest headings in their ranking order: <h1> - <h6>
Donʼt skip headings within a section
Use actual heading tags instead of styling text to give the visual appearance of headings
Landmarks<main role="main" aria-labelledby="main-title">
  <h1 id="main-title">Main title</h1>
  <section aria-labelledby="section-title-1">
    <h2 id="section-title-1"> Section Title </h2>
    <h3>Section Subtitle</h3>
    <!-- Content -->
  </section>
  <section aria-labelledby="section-title-2">
    <h2 id="section-title-2"> Section Title </h2>
    <h3>Section Subtitle</h3>
    <!-- Content -->
    <h3>Section Subtitle</h3>
    <!-- Content -->
  </section>
</main>templaHTMLARIA Role Landmark Purpose
headerrole="banner" Prime heading: title of the page
nav role="navigation"Collection of links suitable for use when
navigating the document or related
documents
main role="main" The main or central content of the document.
footerrole="contentinfo"Information about the parent document:
footnotes/copyrights/links to privacy
statement
aside role="complementary"Supports the main content, yet is separated
and meaningful on its own content
Not
availablerole="search"This section contains the search functionality
for the application
form role="form" Collection of form-associated elements
sectionrole="region"Content that is relevant and that users will
likely want to navigate to. Label must be
provided for this element
Read more about landmarksTip:
It is recommended to use landmark HTML elements with redundant landmark role
attributes in order to maximize compatibility with legacy browsers that don’t support
HTML5 semantic elements.ⓘ
Semantic FormsWhen creating a form, you can use the following elements: <form>, <label>, <input>,
<textarea>, and <button>
Labels are typically placed on top or to the left of the form fields:
Notice how you can include autocomplete='on' on the form element and it will apply to all
inputs in your form. You can also set different values for autocomplete attribute for each
input.
Provide labels to describe the purpose of all form control; linking for and id:
If you inspect this element in your chrome developer tools and open the Accessibility tab
inside the Elements tab, you will see how the input gets its name from the label:Labels<form action="/dataCollectionLocation" method="post" autocomplete="on">
  <div v-for="item in formItems" :key="item.id" class="form-item">
    <label :for="item.id">{{ item.label }}: </label>
    <input
      :type="item.type"
      :id="item.id"
      :name="item.id"
      v-model="item.value"
    />
  </div>
  <button type="submit">Submit</button>
</form>
<label for="name">Name</label>
<input type="text" name="name" id="name" v-model="name" />templa
templaYou can also give the input an accessible name with aria-label.Warning:
Though you might have seen labels wrapping the input fields like this:
Explicitly setting the labels with a matching id is better supported by assistive
technology.⚠
aria-label<label>
  Name:
  <input type="text" name="name" id="name" v-model="name" />
</label>templateFeel free to inspect this element in Chrome DevTools to see how the accessible name has
changed:
Using aria-labelledby is similar to aria-label except it is used if the label text is
visible on screen. It is paired to other elements by their id and you can link multiple ids:aria-labelledby<label for="name">Name</label>
<input
  type="text"
  name="name"
  id="name"
  v-model="name"
  :aria-label="nameLabel"
/>templaaria-describedby is used the same way as aria-labelledby except provides a
description with additional information that the user might need. This can be used toaria-describedby<form
  class="demo"
  action="/dataCollectionLocation"
  method="post"
  autocomplete="on"
>
  <h1 id="billing">Billing</h1>
  <div class="form-item">
    <label for="name">Name:</label>
    <input
      type="text"
      name="name"
      id="name"
      v-model="name"
      aria-labelledby="billing name"
    />
  </div>
  <button type="submit">Submit</button>
</form>templadescribe the criteria for any input:
You can see the description by inspecting Chrome DevTools:<form
  class="demo"
  action="/dataCollectionLocation"
  method="post"
  autocomplete="on"
>
  <h1 id="billing">Billing</h1>
  <div class="form-item">
    <label for="name">Full Name:</label>
    <input
      type="text"
      name="name"
      id="name"
      v-model="name"
      aria-labelledby="billing name"
      aria-describedby="nameDescription"
    />
    <p id="nameDescription">Please provide first and last name.</p>
  </div>
  <button type="submit">Submit</button>
</form>templaAvoid using placeholders as they can confuse many users.
One of the issues with placeholders is that they don't meet the color contrast criteria by
default; fixing the color contrast makes the placeholder look like pre-populated data in the
input fields. Looking at the following example, you can see that the Last Name placeholder
which meets the color contrast criteria looks like pre-populated data:Placeholder<form
  class="demo"
  action="/dataCollectionLocation"
  method="post"
  autocomplete="on"
>
  <div v-for="item in formItems" :key="item.id" class="form-item">
    <label :for="item.id">{{ item.label }}: </label>
    <input
      type="text"
      :id="item.id"
      :name="item.id"
      v-model="item.value"
      :placeholder="item.placeholder"
    />
  </div>
  <button type="submit">Submit</button>
</form>templaIt is best to provide all the information the user needs to fill out forms outside any inputs.
When adding instructions for your input fields, make sure to link it correctly to the input.
You can provide additional instructions and bind multiple ids inside an aria-labelledby.
This allows for more flexible design.
Alternatively, you can attach the instructions to the input with aria-describedby:Instructions/* https://www.w3schools.com/howto/howto_css_placeholder.asp */
#lastName::placeholder {
  /* Chrome, Firefox, Opera, Safari 10.1+ */
  color: black;
  opacity: 1; /* Firefox */
}
#lastName:-ms-input-placeholder {
  /* Internet Explorer 10-11 */
  color: black;
}
#lastName::-ms-input-placeholder {
  /* Microsoft Edge */
  color: black;
}
<fieldset>
  <legend>Using aria-labelledby</legend>
  <label id="date-label" for="date">Current Date:</label>
  <input
    type="date"
    name="date"
    id="date"
    aria-labelledby="date-label date-instructions"
  />
  <p id="date-instructions">MM/DD/YYYY</p>
</fieldset>c
templaUsually it is not recommended to visually hide labels, even if the input has an accessible
name. However, if the functionality of the input can be understood with surrounding
content, then we can hide the visual label.
Let's look at this search field:
We can do this because the search button will help visual users identify the purpose of the
input field.
We can use CSS to visually hide elements but keep them available for assistive technology:Hiding Content<fieldset>
  <legend>Using aria-describedby</legend>
  <label id="dob" for="dob">Date of Birth:</label>
  <input type="date" name="dob" id="dob" aria-describedby="dob-instructions" 
  <p id="dob-instructions">MM/DD/YYYY</p>
</fieldset>
<form role="search">
  <label for="search" class="hidden-visually">Search: </label>
  <input type="text" name="search" id="search" v-model="search" />
  <button type="submit">Search</button>
</form>
.hidden-visually {
  position: absolute;
  overflow: hidden;
  white-space: nowrap;
  margin: 0;
  padding: 0;
  height: 1px;
  width: 1px;
  clip: rect(0 0 0 0);
  clip-path: inset(100%);
}templa
templa
cAdding aria-hidden="true" will hide the element from assistive technology but leave it
visually available for other users. Do not use it on focusable elements, purely on decorative,
duplicated or offscreen content.
When using buttons inside a form, you must set the type to prevent submitting the form.
You can also use an input to create buttons:
You can use this technique to create functional images.aria-hidden="true"
Buttons
Functional Images
Input fields
These images will act as a submit type button on forms<p>This is not hidden from screen readers.</p>
<p aria-hidden="true">This is hidden from screen readers.</p>
<form action="/dataCollectionLocation" method="post" autocomplete="on">
  <!-- Buttons -->
  <button type="button">Cancel</button>
  <button type="submit">Submit</button>
  <!-- Input buttons -->
  <input type="button" value="Cancel" />
  <input type="submit" value="Submit" />
</form>templa
templaThe World Wide Web Consortium (W3C) Web Accessibility Initiative (WAI) develops web
accessibility standards for the different components:Icons
Standards
User Agent Accessibility Guidelines (UAAG)
web browsers and media players, including some aspects of assistive technologies
Authoring Tool Accessibility Guidelines (ATAG)
authoring tools
Web Content Accessibility Guidelines (WCAG)
web content - used by developers, authoring tools, and accessibility evaluation tools<form role="search">
  <label for="search" class="hidden-visually">Search: </label>
  <input type="text" name="search" id="search" v-model="search" />
  <input
    type="image"
    class="btnImg"
    src="https://img.icons8.com/search"
    alt="Search"
  />
</form>
<form role="search">
  <label for="searchIcon" class="hidden-visually">Search: </label>
  <input type="text" name="searchIcon" id="searchIcon" v-model="searchIcon" /
  <button type="submit">
    <i class="fas fa-search" aria-hidden="true"></i>
    <span class="hidden-visually">Search</span>
  </button>
</form>templa
templaWCAG 2.1 extends on WCAG 2.0 and allows implementation of new technologies by
addressing changes to the web. The W3C encourages use of the most current version of
WCAG when developing or updating Web accessibility policies.
W3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user
interface controls.Web Content Accessibility Guidelines (WCAG)
WCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):
Perceivable
Users must be able to perceive the information being presented
Operable
Interface forms, controls, and navigation are operable
Understandable
Information and the operation of user interface must be understandable to all users
Robust
Users must be able to access the content as technologies advance
Web Accessibility Initiative – Accessible Rich Internet Applications (WAI-ARIA)
Accessible Rich Internet Applications (WAI-ARIA) 1.2
WAI-ARIA Authoring Practices 1.2
Resources
Documentation
WCAG 2.0
WCAG 2.1
Accessible Rich Internet Applications (WAI-ARIA) 1.2
WAI-ARIA Authoring Practices 1.2The World Health Organization estimates that 15% of the world's population has some form
of disability, 2-4% of them severely so. That is an estimated 1 billion people worldwide;Assistive Technologies
Screen Readers
NVDA
VoiceOver
JAWS
ChromeVox
Zooming Tools
MAGic
ZoomText
Magnifier
Testing
Automated Tools
Lighthouse
WAVE
ARC Toolkit
Color Tools
WebAim Color Contrast
WebAim Link Color Contrast
Other Helpful Tools
HeadingMap
Color Oracle
Focus Indicator
NerdeFocus
Visual Aria
Silktide Website Accessibility Simulator
Usersmaking people with disabilities the largest minority group in the world.
There are a huge range of disabilities, which can be divided roughly into four categories:
Check out the following links from WebAim to understand from users:Visual - These users can benefit from the use of screen readers, screen magnification,
controlling screen contrast, or braille display.
Auditory - These users can benefit from captioning, transcripts or sign language video.
Motor - These users can benefit from a range of assistive technologies for motor
impairments: voice recognition software, eye tracking, single-switch access, head wand,
sip and puff switch, oversized trackball mouse, adaptive keyboard or other assistive
technologies.
Cognitive - These users can benefit from supplemental media, structural organization of
content, clear and simple writing.
Web Accessibility Perspectives: Explore the Impact and Benefits for Everyone
Stories of Web UsersWhen a vulnerability is reported, it immediately becomes our top concern, with a full-time
contributor dropping everything to work on it. To report a vulnerability, please email
security@vuejs.org.
While the discovery of new vulnerabilities is rare, we also recommend always using the latest
versions of Vue and its official companion libraries to ensure your application remains as
secure as possible.
The most fundamental security rule when using Vue is never use non-trusted content as
your component template. Doing so is equivalent to allowing arbitrary JavaScript execution
in your application - and worse, could lead to server breaches if the code is executed during
server-side rendering. An example of such usage:
Vue templates are compiled into JavaScript, and expressions inside templates will be
executed as part of the rendering process. Although the expressions are evaluated against a
specific rendering context, due to the complexity of potential global execution environments,
it is impractical for a framework like Vue to completely shield you from potential malicious
code execution without incurring unrealistic performance overhead. The most
straightforward way to avoid this category of problems altogether is to make sure the
contents of your Vue templates are always trusted and entirely controlled by you.Security
Reporting Vulnerabilities
Rule No.1: Never Use Non-trusted Templates
Vue.createApp({
  template: `<div>` + userProvidedString + `</div>` // NEVER DO THIS
}).mount('#app')Whether using templates or render functions, content is automatically escaped. That means
in this template:
if userProvidedString contained:
then it would be escaped to the following HTML:
thus preventing the script injection. This escaping is done using native browser APIs, like
textContent, so a vulnerability can only exist if the browser itself is vulnerable.
Similarly, dynamic attribute bindings are also automatically escaped. That means in this
template:
if userProvidedString contained:What Vue Does to Protect You
HTML content
Attribute bindings<h1>{{ userProvidedString }}</h1>
'<script>alert("hi")</script>'
&lt;script&gt;alert(&quot;hi&quot;)&lt;/script&gt;
<h1 :title="userProvidedString">
  hello
</h1>templa
templa
templathen it would be escaped to the following HTML:
thus preventing the close of the title attribute to inject new, arbitrary HTML. This
escaping is done using native browser APIs, like setAttribute, so a vulnerability can only
exist if the browser itself is vulnerable.
In any web application, allowing unsanitized, user-provided content to be executed as
HTML, CSS, or JavaScript is potentially dangerous, so it should be avoided wherever
possible. There are times when some risk may be acceptable, though.
For example, services like CodePen and JSFiddle allow user-provided content to be
executed, but it's in a context where this is expected and sandboxed to some extent inside
iframes. In the cases when an important feature inherently requires some level of
vulnerability, it's up to your team to weigh the importance of the feature against the worst-
case scenarios the vulnerability enables.
As you learned earlier, Vue automatically escapes HTML content, preventing you from
accidentally injecting executable HTML into your application. However, in cases where you
know the HTML is safe, you can explicitly render HTML content:Potential Dangers
HTML Injection
Using a template:'" onclick="alert(\'hi\')'
&quot; onclick=&quot;alert('hi')
<div v-html="userProvidedHtml"></div>templa
templaIn a URL like this:
There's a potential security issue if the URL has not been "sanitized" to prevent JavaScript
execution using javascript:. There are libraries such as sanitize-url to help with this, but
note: if you're ever doing URL sanitization on the frontend, you already have a security issue.
User-provided URLs should always be sanitized by your backend before even being
saved to a database. Then the problem is avoided for every client connecting to your API,
including native mobile apps. Also note that even with sanitized URLs, Vue cannot help you
guarantee that they lead to safe destinations.Using a render function:
Using a render function with JSX:
WARNING
User-provided HTML can never be considered 100% safe unless it's in a sandboxed iframe
or in a part of the app where only the user who wrote that HTML can ever be exposed to
it. Additionally, allowing users to write their own Vue templates brings similar dangers.⚠
URL Injection
Style Injectionh('div', {
  innerHTML: this.userProvidedHtml
})
<div innerHTML={this.userProvidedHtml}></div>
<a :href="userProvidedUrl">
  click me
</a>j
templaLooking at this example:
Let's assume that sanitizedUrl has been sanitized, so that it's definitely a real URL and
not JavaScript. With the userProvidedStyles, malicious users could still provide CSS to
"click jack", e.g. styling the link into a transparent box over the "Log in" button. Then if
https://user-controlled-website.com/ is built to resemble the login page of your
application, they might have just captured a user's real login information.
You may be able to imagine how allowing user-provided content for a <style> element
would create an even greater vulnerability, giving that user full control over how to style the
entire page. That's why Vue prevents rendering of style tags inside templates, such as:
To keep your users fully safe from clickjacking, we recommend only allowing full control over
CSS inside a sandboxed iframe. Alternatively, when providing user control through a style
binding, we recommend using its object syntax and only allowing users to provide values
for specific properties it's safe for them to control, like this:<a
  :href="sanitizedUrl"
  :style="userProvidedStyles"
>
  click me
</a>
<style>{{ userProvidedStyles }}</style>
<a
  :href="sanitizedUrl"
  :style="{
    color: userProvidedColor,
    background: userProvidedBackground
  }"
>
  click me
</a>templa
templa
templaWe strongly discourage ever rendering a <script> element with Vue, since templates and
render functions should never have side effects. However, this isn't the only way to include
strings that would be evaluated as JavaScript at runtime.
Every HTML element has attributes with values accepting strings of JavaScript, such as
onclick, onfocus, and onmouseenter. Binding user-provided JavaScript to any of these
event attributes is a potential security risk, so it should be avoided.
Sometimes we receive vulnerability reports on how it's possible to do cross-site scripting
(XSS) in Vue templates. In general, we do not consider such cases to be actual
vulnerabilities because there's no practical way to protect developers from the two
scenarios that would allow XSS:
The general rule is that if you allow unsanitized, user-provided content to be executed (as
either HTML, JavaScript, or even CSS), you might open yourself up to attacks. This adviceJavaScript Injection
WARNING
User-provided JavaScript can never be considered 100% safe unless it's in a sandboxed
iframe or in a part of the app where only the user who wrote that JavaScript can ever be
exposed to it.⚠
The developer is explicitly asking Vue to render user-provided, unsanitized content as
Vue templates. This is inherently unsafe, and there's no way for Vue to know the origin.1.
The developer is mounting Vue to an entire HTML page which happens to contain server-
rendered and user-provided content. This is fundamentally the same problem as #1, but
sometimes devs may do it without realizing it. This can lead to possible vulnerabilities
where the attacker provides HTML which is safe as plain HTML but unsafe as a Vue
template. The best practice is to never mount Vue on nodes that may contain server-
rendered and user-provided content.2.
Best Practicesactually holds true whether using Vue, another framework, or even no framework.
Beyond the recommendations made above for Potential Dangers, we also recommend
familiarizing yourself with these resources:
Then use what you learn to also review the source code of your dependencies for potentially
dangerous patterns, if any of them include 3rd-party components or otherwise influence
what's rendered to the DOM.
HTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-
site script inclusion (XSSI), are primarily addressed on the backend, so they aren't a concern
of Vue's. However, it's still a good idea to communicate with your backend team to learn
how to best interact with their API, e.g., by submitting CSRF tokens with form submissions.
There are some additional security concerns when using SSR, so make sure to follow the
best practices outlined throughout our SSR documentation to avoid vulnerabilities.HTML5 Security Cheat Sheet
OWASP's Cross Site Scripting (XSS) Prevention Cheat Sheet
Backend Coordination
Server-Side Rendering (SSR)A type system like TypeScript can detect many common errors via static analysis at build
time. This reduces the chance of runtime errors in production, and also allows us to more
confidently refactor code in large-scale applications. TypeScript also improves developer
ergonomics via type-based auto-completion in IDEs.
Vue is written in TypeScript itself and provides first-class TypeScript support. All official Vue
packages come with bundled type declarations that should work out-of-the-box.
create-vue, the official project scaffolding tool, offers the options to scaffold a Vite-
powered, TypeScript-ready Vue project.
With a Vite-based setup, the dev server and the bundler are transpilation-only and do not
perform any type-checking. This ensures the Vite dev server stays blazing fast even when
using TypeScript.Using Vue with TypeScript
Project Setup
Overview
During development, we recommend relying on a good IDE setup for instant feedback on
type errors.
If using SFCs, use the vue-tsc utility for command line type checking and type
declaration generation. vue-tsc is a wrapper around tsc, TypeScript's own command
line interface. It works largely the same as tsc except that it supports Vue SFCs in
addition to TypeScript files. You can run vue-tsc in watch mode in parallel to the Vite
dev server, or use a Vite plugin like vite-plugin-checker which runs the checks in a
separate worker thread.
Vue CLI also provides TypeScript support, but is no longer recommended. See notes
below.Projects scaffolded via create-vue include pre-configured tsconfig.json. The base
config is abstracted in the @vue/tsconfig package. Inside the project, we use Project
References to ensure correct types for code running in different environments (e.g. app
code and test code should have different global variables).
When configuring tsconfig.json manually, some notable options include:IDE Support
Visual Studio Code (VSCode) is strongly recommended for its great out-of-the-box
support for TypeScript.
Volar is the official VSCode extension that provides TypeScript support inside Vue
SFCs, along with many other great features.
TIP
Volar replaces Vetur, our previous official VSCode extension for Vue 2. If you have
Vetur currently installed, make sure to disable it in Vue 3 projects.ⓘ
TypeScript Vue Plugin is also needed to get type support for *.vue imports in TS
files.
WebStorm also provides out-of-the-box support for both TypeScript and Vue. Other
JetBrains IDEs support them too, either out of the box or via a free plugin.
Configuring tsconfig.json
compilerOptions.isolatedModules is set to true because Vite uses esbuild for
transpiling TypeScript and is subject to single-file transpile limitations.
If you're using Options API, you need to set compilerOptions.strict to true (or at
least enable compilerOptions.noImplicitThis, which is a part of the strict flag) to
leverage type checking of this in component options. Otherwise this will be treated
as any.
If you have configured resolver aliases in your build tool, for example the @/* alias
configured by default in a create-vue project, you need to also configure it forSee also:
This section only applies for VSCode + Volar.
To get Vue SFCs and TypeScript working together, Volar creates a separate TS language
service instance patched with Vue-specific support, and uses it in Vue SFCs. At the same
time, plain TS files are still handled by VSCode's built-in TS language service, which is why
we need TypeScript Vue Plugin to support Vue SFC imports in TS files. This default setup
works, but for each project we are running two TS language service instances: one from
Volar, one from VSCode's built-in service. This is a bit inefficient and can lead to
performance issues in large projects.
Volar provides a feature called "Takeover Mode" to improve performance. In takeover mode,
Volar provides support for both Vue and TS files using a single TS language service
instance.
To enable Takeover Mode, you need to disable VSCode's built-in TS language service in
your project's workspace only by following these steps:TypeScript via compilerOptions.paths.
Official TypeScript compiler options docs
esbuild TypeScript compilation caveats
Volar Takeover Mode
In your project workspace, bring up the command palette with Ctrl + Shift + P
(macOS: Cmd + Shift + P).1.
Type built and select "Extensions: Show Built-in Extensions". 2.
Type typescript in the extension search box (do not remove @builtin prefix). 3.
Click the little gear icon of "TypeScript and JavaScript Language Features", and select
"Disable (Workspace)".4.
Reload the workspace. Takeover mode will be enabled when you open a Vue or TS file. 5.In webpack-based setups such as Vue CLI, it is common to perform type checking as part of
the module transform pipeline, for example with ts-loader. This, however, isn't a clean
solution because the type system needs knowledge of the entire module graph to perform
type checks. Individual module's transform step simply is not the right place for the task. It
leads to the following problems:
If you are currently using Vue 3 + TypeScript via Vue CLI, we strongly recommend migrating
over to Vite. We are also working on CLI options to enable transpile-only TS support, so that
you can switch to vue-tsc for type checking.Note on Vue CLI and ts-loader
ts-loader can only type check post-transform code. This doesn't align with the errors
we see in IDEs or from vue-tsc, which map directly back to the source code.
Type checking can be slow. When it is performed in the same thread / process with code
transformations, it significantly affects the build speed of the entire application.
We already have type checking running right in our IDE in a separate process, so the cost
of dev experience slow down simply isn't a good trade-off.To let TypeScript properly infer types inside component options, we need to define
components with defineComponent():
defineComponent() also supports inferring the props passed to setup() when using
Composition API without <script setup>:General Usage Notes
defineComponent()
import { defineComponent } from 'vue'
export default defineComponent({
  // type inference enabled
  props: {
    name: String,
    msg: { type: String, required: true }
  },
  data() {
    return {
      count: 1
    }
  },
  mounted() {
    this.name // type: string | undefined
    this.msg // type: string
    this.count // type: number
  }
})See also:
To use TypeScript in SFCs, add the lang="ts" attribute to <script> tags. When
lang="ts" is present, all template expressions also enjoy stricter type checking.Note on webpack Treeshaking
type tests for defineComponent
TIP
defineComponent() also enables type inference for components defined in plain
JavaScript.ⓘ
Usage in Single-File Componentsimport { defineComponent } from 'vue'
export default defineComponent({
  // type inference enabled
  props: {
    message: String
  },
  setup(props) {
    props.message // type: string | undefined
  }
})lang="ts" can also be used with <script setup>:
The <template> also supports TypeScript in binding expressions when <script
lang="ts"> or <script setup lang="ts"> is used. This is useful in cases where you
need to perform type casting in template expressions.
Here's a contrived example:TypeScript in Templates<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  data() {
    return {
      count: 1
    }
  }
})
</script>
<template>
  <!-- type checking and auto-completion enabled -->
  {{ count.toFixed(2) }}
</template>
<script setup lang="ts">
// TypeScript enabled
import { ref } from 'vue'
const count = ref(1)
</script>
<template>
  <!-- type checking and auto-completion enabled -->
  {{ count.toFixed(2) }}
</template>v
vThis can be worked around with an inline type cast:
TIP
If using Vue CLI or a webpack-based setup, TypeScript in template expressions requires
vue-loader@^16.8.0.ⓘ
API-Specific Recipes
TS with Composition API
TS with Options API<script setup lang="ts">
let x: string | number = 1
</script>
<template>
  <!-- error because x could be a string -->
  {{ x.toFixed(2) }}
</template>
<script setup lang="ts">
let x: string | number = 1
</script>
<template>
  {{ (x as number).toFixed(2) }}
</template>v
vThis page assumes you've already read the overview on Using Vue with TypeScript.
When using <script setup>, the defineProps() macro supports inferring the props
types based on its argument:
This is called "runtime declaration", because the argument passed to defineProps() will
be used as the runtime props option.
However, it is usually more straightforward to define props with pure types via a generic
type argument:TypeScript with Composition API
Typing Component Props
Using <script setup>
<script setup lang="ts">
const props = defineProps({
  foo: { type: String, required: true },
  bar: Number
})
props.foo // string
props.bar // number | undefined
</script>
<script setup lang="ts">
const props = defineProps<{
  foo: string
  bar?: number
}>()
</script>v
vThis is called "type-based declaration". The compiler will try to do its best to infer the
equivalent runtime options based on the type argument. In this case, our second example
compiles into the exact same runtime options as the first example.
You can use either type-based declaration OR runtime declaration, but you cannot use both
at the same time.
We can also move the props types into a separate interface:
In order to generate the correct runtime code, the generic argument for defineProps()
must be one of the following:
The interface or object literal type can contain references to types imported from other files,
however, the generic argument itself passed to definePropscannot be an imported type:Syntax Limitations
An object literal type:
A reference to an interface or object literal type in the same file:<script setup lang="ts">
interface Props {
  foo: string
  bar?: number
}
const props = defineProps<Props>()
</script>
defineProps<{ /*... */ }>()
interface Props {/* ... */}
defineProps<Props>()vThis is because Vue components are compiled in isolation and the compiler currently does
not crawl imported files in order to analyze the source type. This limitation could be removed
in a future release.
When using type-based declaration, we lose the ability to declare default values for the
props. This can be resolved by the withDefaults compiler macro:
This will be compiled to equivalent runtime props default options. In addition, the
withDefaults helper provides type checks for the default values, and ensures the
returned props type has the optional flags removed for properties that do have default
values declared.
Alternatively, you can use the currently experimental Reactivity Transform:Props Default Valuesimport { Props } from './other-file'
// NOT supported
defineProps<Props>()
export interface Props {
  msg?: string
  labels?: string[]
}
const props = withDefaults(defineProps<Props>(), {
  msg: 'hello',
  labels: () => ['one', 'two']
})This behavior currently requires explicit opt-in.
If not using <script setup>, it is necessary to use defineComponent() to enable props
type inference. The type of the props object passed to setup() is inferred from the
props option.
With type-based declaration, a prop can use a complex type much like any other type:Without <script setup>
Complex prop types<script setup lang="ts">
interface Props {
  name: string
  count?: number
}
// reactive destructure for defineProps()
// default value is compiled to equivalent runtime option
const { name, count = 100 } = defineProps<Props>()
</script>
import { defineComponent } from 'vue'
export default defineComponent({
  props: {
    message: String
  },
  setup(props) {
    props.message // <-- type: string
  }
})vFor runtime declaration, we can use the PropType utility type:
This works in much the same way if we're specifying the props option directly:
The props option is more commonly used with the Options API, so you'll find more detailed
examples in the guide to TypeScript with Options API. The techniques shown in those
examples also apply to runtime declarations using defineProps().
Typing Component Emits<script setup lang="ts">
interface Book {
  title: string
  author: string
  year: number
}
const props = defineProps<{
  book: Book
}>()
</script>
import type { PropType } from 'vue'
const props = defineProps({
  book: Object as PropType<Book>
})
import { defineComponent } from 'vue'
import type { PropType } from 'vue'
export default defineComponent({
  props: {
    book: Object as PropType<Book>
  }
})vIn <script setup>, the emit function can also be typed using either runtime declaration
OR type declaration:
The type argument should be a type literal with Call Signatures. The type literal will be used
as the type of the returned emit function. As we can see, the type declaration gives us
much finer-grained control over the type constraints of emitted events.
When not using <script setup>, defineComponent() is able to infer the allowed events
for the emit function exposed on the setup context:
Refs infer the type from the initial value:Typing ref()<script setup lang="ts">
// runtime
const emit = defineEmits(['change', 'update'])
// type-based
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>
import { defineComponent } from 'vue'
export default defineComponent({
  emits: ['change'],
  setup(props, { emit }) {
    emit('change') // <-- type check / auto-completion
  }
})vSometimes we may need to specify complex types for a ref's inner value. We can do that by
using the Ref type:
Or, by passing a generic argument when calling ref() to override the default inference:
If you specify a generic type argument but omit the initial value, the resulting type will be a
union type that includes undefined:
reactive() also implicitly infers the type from its argument:Typing reactive()import { ref } from 'vue'
// inferred type: Ref<number>
const year = ref(2020)
// => TS Error: Type 'string' is not assignable to type 'number'.
year.value = '2020'
import { ref } from 'vue'
import type { Ref } from 'vue'
const year: Ref<string | number> = ref('2020')
year.value = 2020 // ok!
// resulting type: Ref<string | number>
const year = ref<string | number>('2020')
year.value = 2020 // ok!
// inferred type: Ref<number | undefined>
const n = ref<number>()To explicitly type a reactive property, we can use interfaces:
computed() infers its type based on the getter's return value:TIP
It's not recommended to use the generic argument of reactive() because the returned
type, which handles nested ref unwrapping, is different from the generic argument type.ⓘ
Typing computed()import { reactive } from 'vue'
// inferred type: { title: string }
const book = reactive({ title: 'Vue 3 Guide' })
import { reactive } from 'vue'
interface Book {
  title: string
  year?: number
}
const book: Book = reactive({ title: 'Vue 3 Guide' })
import { ref, computed } from 'vue'
const count = ref(0)
// inferred type: ComputedRef<number>
const double = computed(() => count.value * 2)
// => TS Error: Property 'split' does not exist on type 'number'
const result = double.value.split('')You can also specify an explicit type via a generic argument:
When dealing with native DOM events, it might be useful to type the argument we pass to
the handler correctly. Let's take a look at this example:
Without type annotation, the event argument will implicitly have a type of any. This will
also result in a TS error if "strict": true or "noImplicitAny": true are used in
tsconfig.json. It is therefore recommended to explicitly annotate the argument of event
handlers. In addition, you may need to explicitly cast properties on event:Typing Event Handlersconst double = computed<number>(() => {
  // type error if this doesn't return a number
})
<script setup lang="ts">
function handleChange(event) {
  // `event` implicitly has `any` type
  console.log(event.target.value)
}
</script>
<template>
  <input type="text" @change="handleChange" />
</template>
function handleChange(event: Event) {
  console.log((event.target as HTMLInputElement).value)
}vProvide and inject are usually performed in separate components. To properly type injected
values, Vue provides an InjectionKey interface, which is a generic type that extends
Symbol. It can be used to sync the type of the injected value between the provider and the
consumer:
It's recommended to place the injection key in a separate file so that it can be imported in
multiple components.
When using string injection keys, the type of the injected value will be unknown, and needs
to be explicitly declared via a generic type argument:
Notice the injected value can still be undefined, because there is no guarantee that a
provider will provide this value at runtime.
The undefined type can be removed by providing a default value:
If you are sure that the value is always provided, you can also force cast the value:Typing Provide / Inject
import { provide, inject } from 'vue'
import type { InjectionKey } from 'vue'
const key = Symbol() as InjectionKey<string>
provide(key, 'foo') // providing non-string value will result in error
const foo = inject(key) // type of foo: string | undefined
const foo = inject<string>('foo') // type: string | undefined
const foo = inject<string>('foo', 'bar') // type: string
const foo = inject('foo') as stringTemplate refs should be created with an explicit generic type argument and an initial value of
null:
Note that for strict type safety, it is necessary to use optional chaining or type guards when
accessing el.value. This is because the initial ref value is null until the component is
mounted, and it can also be set to null if the referenced element is unmounted by v-if.
Sometimes you might need to annotate a template ref for a child component in order to call
its public method. For example, we have a MyModal child component with a method that
opens the modal:Typing Template Refs
Typing Component Template Refs<script setup lang="ts">
import { ref, onMounted } from 'vue'
const el = ref<HTMLInputElement | null>(null)
onMounted(() => {
  el.value?.focus()
})
</script>
<template>
  <input ref="el" />
</template>vIn order to get the instance type of MyModal, we need to first get its type via typeof, then
use TypeScript's built-in InstanceType utility to extract its instance type:
Note if you want to use this technique in TypeScript files instead of Vue SFCs, you need to
enable Volar's Takeover Mode.<!-- MyModal.vue -->
<script setup lang="ts">
import { ref } from 'vue'
const isContentShown = ref(false)
const open = () => (isContentShown.value = true)
defineExpose({
  open
})
</script>
<!-- App.vue -->
<script setup lang="ts">
import MyModal from './MyModal.vue'
const modal = ref<InstanceType<typeof MyModal> | null>(null)
const openModal = () => {
  modal.value?.open()
}
</script>v
vThis page assumes you've already read the overview on Using Vue with TypeScript.
Type inference for props in Options API requires wrapping the component with
defineComponent(). With it, Vue is able to infer the types for the props based on the
props option, taking additional options such as required: true and default into
account:TypeScript with Options API
TIP
While Vue does support TypeScript usage with Options API, it is recommended to use Vue
with TypeScript via Composition API as it offers simpler, more efficient and more robust
type inference.ⓘ
Typing Component Props
import { defineComponent } from 'vue'
export default defineComponent({
  // type inference enabled
  props: {
    name: String,
    id: [Number, String],
    msg: { type: String, required: true },
    metadata: null
  },
  mounted() {
    this.name // type: string | undefined
    this.id // type: number | string | undefined
    this.msg // type: string
    this.metadata // type: any
  }
})However, the runtime props options only support using constructor functions as a prop's
type - there is no way to specify complex types such as objects with nested properties or
function call signatures.
To annotate complex props types, we can use the PropType utility type:
If your TypeScript version is less than 4.7, you have to be careful when using function
values for validator and default prop options - make sure to use arrow functions:Caveatsimport { defineComponent } from 'vue'
import type { PropType } from 'vue'
interface Book {
  title: string
  author: string
  year: number
}
export default defineComponent({
  props: {
    book: {
      // provide more specific type to `Object`
      type: Object as PropType<Book>,
      required: true
    },
    // can also annotate functions
    callback: Function as PropType<(id: number) => void>
  },
  mounted() {
    this.book.title // string
    this.book.year // number
    // TS Error: argument of type 'string' is not
    // assignable to parameter of type 'number'
    this.callback?.('123')
  }
})This prevents TypeScript from having to infer the type of this inside these functions,
which, unfortunately, can cause the type inference to fail. It was a previous design
limitation, and now has been improved in TypeScript 4.7.
We can declare the expected payload type for an emitted event using the object syntax of
the emits option. Also, all non-declared emitted events will throw a type error when called:Typing Component Emitsimport { defineComponent } from 'vue'
import type { PropType } from 'vue'
interface Book {
  title: string
  year?: number
}
export default defineComponent({
  props: {
    bookA: {
      type: Object as PropType<Book>,
      // Make sure to use arrow functions if your TypeScript version is less 
      default: () => ({
        title: 'Arrow Function Expression'
      }),
      validator: (book: Book) => !!book.title
    }
  }
})A computed property infers its type based on its return value:Typing Computed Propertiesimport { defineComponent } from 'vue'
export default defineComponent({
  emits: {
    addBook(payload: { bookName: string }) {
      // perform runtime validation
      return payload.bookName.length > 0
    }
  },
  methods: {
    onSubmit() {
      this.$emit('addBook', {
        bookName: 123 // Type error!
      })
      this.$emit('non-declared-event') // Type error!
    }
  }
})In some cases, you may want to explicitly annotate the type of a computed property to
ensure its implementation is correct:import { defineComponent } from 'vue'
export default defineComponent({
  data() {
    return {
      message: 'Hello!'
    }
  },
  computed: {
    greeting() {
      return this.message + '!'
    }
  },
  mounted() {
    this.greeting // type: string
  }
})Explicit annotations may also be required in some edge cases where TypeScript fails to infer
the type of a computed property due to circular inference loops.
When dealing with native DOM events, it might be useful to type the argument we pass to
the handler correctly. Let's take a look at this example:Typing Event Handlersimport { defineComponent } from 'vue'
export default defineComponent({
  data() {
    return {
      message: 'Hello!'
    }
  },
  computed: {
    // explicitly annotate return type
    greeting(): string {
      return this.message + '!'
    },
    // annotating a writable computed property
    greetingUppercased: {
      get(): string {
        return this.greeting.toUpperCase()
      },
      set(newValue: string) {
        this.message = newValue.toUpperCase()
      }
    }
  }
})Without type annotation, the event argument will implicitly have a type of any. This will
also result in a TS error if "strict": true or "noImplicitAny": true are used in
tsconfig.json. It is therefore recommended to explicitly annotate the argument of event
handlers. In addition, you may need to explicitly cast properties on event:
Some plugins install globally available properties to all component instances via
app.config.globalProperties. For example, we may install this.$http for data-
fetching or this.$translate for internationalization. To make this play well withAugmenting Global Properties<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  methods: {
    handleChange(event) {
      // `event` implicitly has `any` type
      console.log(event.target.value)
    }
  }
})
</script>
<template>
  <input type="text" @change="handleChange" />
</template>
import { defineComponent } from 'vue'
export default defineComponent({
  methods: {
    handleChange(event: Event) {
      console.log((event.target as HTMLInputElement).value)
    }
  }
})vTypeScript, Vue exposes a ComponentCustomProperties interface designed to be
augmented via TypeScript module augmentation:
See also:
We can put this type augmentation in a .ts file, or in a project-wide *.d.ts file. Either
way, make sure it is included in tsconfig.json. For library / plugin authors, this file should
be specified in the types property in package.json.
In order to take advantage of module augmentation, you will need to ensure the
augmentation is placed in a TypeScript module. That is to say, the file needs to contain at
least one top-level import or export, even if it is just export {}. If the augmentation is
placed outside of a module, it will overwrite the original types rather than augmenting them!TypeScript unit tests for component type extensions
Type Augmentation Placementimport axios from 'axios'
declare module 'vue' {
  interface ComponentCustomProperties {
    $http: typeof axios
    $translate: (key: string) => string
  }
}
// Does not work, overwrites the original types.
declare module 'vue' {
  interface ComponentCustomProperties {
    $translate: (key: string) => string
  }
}Some plugins, for example vue-router, provide support for custom component options
such as beforeRouteEnter:
Without proper type augmentation, the arguments of this hook will implicitly have any
type. We can augment the ComponentCustomOptions interface to support these custom
options:
Now the beforeRouteEnter option will be properly typed. Note this is just an example -
well-typed libraries like vue-router should automatically perform these augmentations inAugmenting Custom Options// Works correctly
export {}
declare module 'vue' {
  interface ComponentCustomProperties {
    $translate: (key: string) => string
  }
}
import { defineComponent } from 'vue'
export default defineComponent({
  beforeRouteEnter(to, from, next) {
    // ...
  }
})
import { Route } from 'vue-router'
declare module 'vue' {
  interface ComponentCustomOptions {
    beforeRouteEnter?(to: Route, from: Route, next: () => void): void
  }
}their own type definitions.
The placement of this augmentation is subject the same restrictions as global property
augmentations.
See also:
TypeScript unit tests for component type extensionsWe believe there is no "one size fits all" story for the web. This is why Vue is designed to be
flexible and incrementally adoptable. Depending on your use case, Vue can be used in
different ways to strike the optimal balance between stack complexity, developer
experience and end performance.
Vue can be used as a standalone script file - no build step required! If you have a backend
framework already rendering most of the HTML, or your frontend logic isn't complex
enough to justify a build step, this is the easiest way to integrate Vue into your stack. You
can think of Vue as a more declarative replacement of jQuery in such cases.
Vue also provides an alternative distribution called petite-vue that is specifically optimized
for progressively enhancing existing HTML. It has a smaller feature set, but is extremely
lightweight and uses an implementation that is more efficient in no-build-step scenarios.
You can use Vue to build standard Web Components that can be embedded in any HTML
page, regardless of how they are rendered. This option allows you to leverage Vue in a
completely consumer-agnostic fashion: the resulting web components can be embedded in
legacy applications, static HTML, or even applications built with other frameworks.Ways of Using Vue
Standalone Script
Embedded Web Components
Single-Page Application (SPA)Some applications require rich interactivity, deep session depth, and non-trivial stateful
logic on the frontend. The best way to build such applications is to use an architecture
where Vue not only controls the entire page, but also handles data updates and navigation
without having to reload the page. This type of application is typically referred to as a
Single-Page Application (SPA).
Vue provides core libraries and comprehensive tooling support with amazing developer
experience for building modern SPAs, including:
SPAs typically require the backend to expose API endpoints - but you can also pair Vue with
solutions like Inertia.js to get the SPA benefits while retaining a server-centric development
model.
Pure client-side SPAs are problematic when the app is sensitive to SEO and time-to-
content. This is because the browser will receive a largely empty HTML page, and has to
wait until the JavaScript is loaded before rendering anything.
Vue provides first-class APIs to "render" a Vue app into HTML strings on the server. This
allows the server to send back already-rendered HTML, allowing end users to see the
content immediately while the JavaScript is being downloaded. Vue will then "hydrate" the
application on the client side to make it interactive. This is called Server-Side Rendering
(SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint
(LCP).
There are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt,
which allow you to develop a fullstack application using Vue and JavaScript.Client-side router
Blazing fast build tool chain
IDE support
Browser devtools
TypeScript integrations
Testing utilities
Fullstack / SSRServer-side rendering can be done ahead of time if the required data is static. This means
we can pre-render an entire application into HTML and serve them as static files. This
improves site performance and makes deployment a lot simpler since we no longer need to
dynamically render pages on each request. Vue can still hydrate such applications to
provide rich interactivity on the client. This technique is commonly referred to as Static-Site
Generation (SSG), also known as JAMStack.
There are two flavors of SSG: single-page and multi-page. Both flavors pre-render the site
into static HTML, the difference is that:
Single-page SSGs are better suited if you expect non-trivial interactivity, deep session
lengths, or persisted elements / state across navigations. Otherwise, multi-page SSG would
be the better choice.
The Vue team also maintains a static-site generator called VitePress, which powers this
website you are reading right now! VitePress supports both flavors of SSG. Nuxt also
supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.
Although Vue is primarily designed for building web applications, it is by no means limited to
just the browser. You can:JAMStack / SSG
After the initial page load, a single-page SSG "hydrates" the page into an SPA. This
requires more upfront JS payload and hydration cost, but subsequent navigations will be
faster, since it only needs to partially update the page content instead of reloading the
entire page.
A multi-page SSG loads a new page on every navigation. The upside is that it can ship
minimal JS - or no JS at all if the page requires no interaction! Some multi-page SSG
frameworks such as Astro also support "partial hydration" - which allows you to use Vue
components to create interactive "islands" inside static HTML.
Beyond the WebBuild desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the
terminal!Composition API is a set of APIs that allows us to author Vue components using imported
functions instead of declaring options. It is an umbrella term that covers the following APIs:
Composition API is a built-in feature of Vue 3 and Vue 2.7. For older Vue 2 versions, use the
officially maintained @vue/composition-api plugin. In Vue 3, it is also primarily used
together with the <script setup> syntax in Single-File Components. Here's a basic
example of a component using Composition API:Composition API FAQ
TIP
This FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while
primarily using Options API.ⓘ
What is Composition API?
Reactivity API, e.g. ref() and reactive(), that allows us to directly create reactive
state, computed state, and watchers.
Lifecycle Hooks, e.g. onMounted() and onUnmounted(), that allow us to
programmatically hook into the component lifecycle.
Dependency Injection, i.e. provide() and inject(), that allow us to leverage Vue's
dependency injection system while using Reactivity APIs.Despite an API style based on function composition, Composition API is NOT functional
programming. Composition API is based on Vue's mutable, fine-grained reactivity
paradigm, whereas functional programming emphasizes immutability.
If you are interested in learning how to use Vue with Composition API, you can set the site-
wide API preference to Composition API using the toggle at the top of the left sidebar, and
then go through the guide from the beginning.
The primary advantage of Composition API is that it enables clean, efficient logic reuse in
the form of Composable functions. It solves all the drawbacks of mixins, the primary
logic reuse mechanism for Options API.Why Composition API?
Better Logic Reuse<script setup>
import { ref, onMounted } from 'vue'
// reactive state
const count = ref(0)
// functions that mutate state and trigger updates
function increment() {
  count.value++
}
// lifecycle hooks
onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>
<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>vComposition API's logic reuse capability has given rise to impressive community projects
such as VueUse, an ever-growing collection of composable utilities. It also serves as a
clean mechanism for easily integrating stateful third-party services or libraries into Vue's
reactivity system, for example immutable data, state machines, and RxJS.
Many users love that we write organized code by default with Options API: everything has
its place based on the option it falls under. However, Options API poses serious limitations
when a single component's logic grows beyond a certain complexity threshold. This
limitation is particularly prominent in components that need to deal with multiple logical
concerns, which we have witnessed first hand in many production Vue 2 apps.
Take the folder explorer component from Vue CLI's GUI as an example: this component is
responsible for the following logical concerns:
The original version of the component was written in Options API. If we give each line of
code a color based on the logical concern it is dealing with, this is how it looks:More Flexible Code Organization
Tracking current folder state and displaying its content
Handling folder navigation (opening, closing, refreshing...)
Handling new folder creation
Toggling show favorite folders only
Toggling show hidden folders
Handling current working directory changesNotice how code dealing with the same logical concern is forced to be split under different
options, located in different parts of the file. In a component that is several hundred lines
long, understanding and navigating a single logical concern requires constantly scrolling up
and down the file, making it much more difficult than it should be. In addition, if we ever
intend to extract a logical concern into a reusable utility, it takes quite a bit of work to find
and extract the right pieces of code from different parts of the file.
Here's the same component, before and after the refactor into Composition API:Notice how the code related to the same logical concern can now be grouped together: we
no longer need to jump between different options blocks while working on a specific logical
concern. Moreover, we can now move a group of code into an external file with minimal
effort, since we no longer need to shuffle the code around in order to extract them. This
reduced friction for refactoring is key to the long-term maintainability in large codebases.
Better Type InferenceIn recent years, more and more frontend developers are adopting TypeScript as it helps us
write more robust code, make changes with more confidence, and provides a great
development experience with IDE support. However, the Options API, originally conceived in
2013, was designed without type inference in mind. We had to implement some absurdly
complex type gymnastics to make type inference work with the Options API. Even with all
this effort, type inference for Options API can still break down for mixins and dependency
injection.
This had led many developers who wanted to use Vue with TS to lean towards Class API
powered by vue-class-component. However, a class-based API heavily relies on ES
decorators, a language feature that was only a stage 2 proposal when Vue 3 was being
developed in 2019. We felt it was too risky to base an official API on an unstable proposal.
Since then, the decorators proposal has gone through yet another complete overhaul, and
finally reached stage 3 in 2022. In addition, class-based API suffers from logic reuse and
organization limitations similar to Options API.
In comparison, Composition API utilizes mostly plain variables and functions, which are
naturally type friendly. Code written in Composition API can enjoy full type inference with
little need for manual type hints. Most of the time, Composition API code will look largely
identical in TypeScript and plain JavaScript. This also makes it possible for plain JavaScript
users to benefit from partial type inference.
Code written in Composition API and <script setup> is also more efficient and
minification-friendly than Options API equivalent. This is because the template in a <script
setup> component is compiled as a function inlined in the same scope of the <script
setup> code. Unlike property access from this, the compiled template code can directly
access variables declared inside <script setup>, without an instance proxy in between.
This also leads to better minification because all the variable names can be safely
shortened.Smaller Production Bundle and Less Overhead
Relationship with Options APISome users moving from Options API found their Composition API code less organized, and
concluded that Composition API is "worse" in terms of code organization. We recommend
users with such opinions to look at that problem from a different perspective.
It is true that Composition API no longer provides the "guard rails" that guide you to put
your code into respective buckets. In return, you get to author component code like how
you would write normal JavaScript. This means you can and should apply any code
organization best practices to your Composition API code as you would when writing
normal JavaScript. If you can write well-organized JavaScript, you should also be able to
write well-organized Composition API code.
Options API does allow you to "think less" when writing component code, which is why
many users love it. However, in reducing the mental overhead, it also locks you into the
prescribed code organization pattern with no escape hatch, which can make it difficult to
refactor or improve code quality in larger scale projects. In this regard, Composition API
provides better long term scalability.
Yes in terms of stateful logic. When using Composition API, there are only a few options that
may still be needed: props, emits, name, and inheritAttrs. If using <script
setup>, then inheritAttrs is typically the only option that may require a separate
normal <script> block.
If you intend to exclusively use Composition API (along with the options listed above), you
can shave a few kbs off your production bundle via a compile-time flag that drops Options
API related code from Vue. Note this also affects Vue components in your dependencies.
Yes. You can use Composition API via the setup() option in an Options API component.
However, we only recommend doing so if you have an existing Options API codebase that
needs to integrate with new features / external libraries written with Composition API.Trade-offs
Does Composition API cover all use cases?
Can I use both APIs together?No, we do not have any plan to do so. Options API is an integral part of Vue and the reason
many developers love it. We also realize that many of the benefits of Composition API only
manifest in larger-scale projects, and Options API remains a solid choice for many low-to-
medium-complexity scenarios.
We no longer recommend using Class API with Vue 3, given that Composition API provides
great TypeScript integration with additional logic reuse and code organization benefits.
Composition API provides the same level of logic composition capabilities as React Hooks,
but with some important differences.
React Hooks are invoked repeatedly every time a component updates. This creates a
number of caveats that can confuse even seasoned React developers. It also leads to
performance optimization issues that can severely affect development experience. Here are
some examples:Will Options API be deprecated?
Relationship with Class API
Comparison with React Hooks
Hooks are call-order sensitive and cannot be conditional.
Variables declared in a React component can be captured by a hook closure and become
"stale" if the developer fails to pass in the correct dependencies array. This leads to
React developers relying on ESLint rules to ensure correct dependencies are passed.
However, the rule is often not smart enough and over-compensates for correctness,
which leads to unnecessary invalidation and headaches when edge cases are
encountered.In comparison, Vue Composition API:
We acknowledge the creativity of React Hooks, and it is a major source of inspiration for
Composition API. However, the issues mentioned above do exist in its design and we
noticed Vue's reactivity model happens to provide a way around them.Expensive computations require the use of useMemo, which again requires manually
passing in the correct dependencies array.
Event handlers passed to child components cause unnecessary child updates by default,
and require explicit useCallback as an optimization. This is almost always needed, and
again requires a correct dependencies array. Neglecting this leads to over-rendering
apps by default and can cause performance issues without realizing it.
The stale closure problem, combined with Concurrent features, makes it difficult to
reason about when a piece of hooks code is run, and makes working with mutable state
that should persist across renders (via useRef) cumbersome.
Invokes setup() or <script setup> code only once. This makes the code align better
with the intuitions of idiomatic JavaScript usage as there are no stale closures to worry
about. Composition API calls are also not sensitive to call order and can be conditional.
Vue's runtime reactivity system automatically collects reactive dependencies used in
computed properties and watchers, so there's no need to manually declare
dependencies.
No need to manually cache callback functions to avoid unnecessary child updates. In
general, Vue's fine-grained reactivity system ensures child components only update
when they need to. Manual child-update optimizations are rarely a concern for Vue
developers.One of Vueʼs most distinctive features is the unobtrusive reactivity system. Component state
consists of reactive JavaScript objects. When you modify them, the view updates. It makes
state management simple and intuitive, but itʼs also important to understand how it works to
avoid some common gotchas. In this section, we are going to dig into some of the lower-
level details of Vueʼs reactivity system.
This term comes up in programming quite a bit these days, but what do people mean when
they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a
declarative manner. The canonical example that people usually show, because itʼs a great
one, is an Excel spreadsheet:
ABC
01
12
23
Here cell A2 is defined via a formula of = A0 + A1 (you can click on A2 to view or edit the
formula), so the spreadsheet gives us 3. No surprises there. But if you update A0 or A1,
you'll notice that A2 automagically updates too.
JavaScript doesnʼt usually work like this. If we were to write something comparable in
JavaScript:Reactivity in Depth
What is Reactivity?
let A0 = 1
let A1 = 2
let A2 = A0 + A1
console.log(A2) // 3
A0 = 2
console.log(A2) // Still 3When we mutate A0, A2 does not change automatically.
So how would we do this in JavaScript? First, in order to re-run the code that updates A2,
let's wrap it in a function:
Then, we need to define a few terms:
What we need is a magic function that can invoke update() (the effect) whenever A0 or
A1 (the dependencies) change:
This whenDepsChange() function has the following tasks:The update() function produces a side effect, or effect for short, because it modifies
the state of the program.
A0 and A1 are considered dependencies of the effect, as their values are used to
perform the effect. The effect is said to be a subscriber to its dependencies.
Track when a variable is read. E.g. when evaluating the expression A0 + A1, both A0
and A1 are read.1.
If a variable is read when there is a currently running effect, make that effect a subscriber
to that variable. E.g. because A0 and A1 are read when update() is being executed,
update() becomes a subscriber to both A0 and A1 after the first call.2.
Detect when a variable is mutated. E.g. when A0 is assigned a new value, notify all its
subscriber effects to re-run.3.let A2
function update() {
  A2 = A0 + A1
}
whenDepsChange(update)We can't really track the reading and writing of local variables like in the example. There's
just no mechanism for doing that in vanilla JavaScript. What we can do though, is intercept
the reading and writing of object properties.
There are two ways of intercepting property access in JavaScript: getter / setters and
Proxies. Vue 2 used getter / setters exclusively due to browser support limitations. In Vue 3,
Proxies are used for reactive objects and getter / setters are used for refs. Here's some
pseudo-code that illustrates how they work:How Reactivity Works in Vue
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key)
    }
  })
}
function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}This explains a few limitations of reactive objects that we have discussed in the
fundamentals section:
Inside track(), we check whether there is a currently running effect. If there is one, we
lookup the subscriber effects (stored in a Set) for the property being tracked, and add the
effect to the Set:
Effect subscriptions are stored in a global WeakMap<target, Map<key, Set<effect>>>
data structure. If no subscribing effects Set was found for a property (tracked for the first
time), it will be created. This is what the getSubscribersForProperty() function does, in
short. For simplicity, we will skip its details.
Inside trigger(), we again lookup the subscriber effects for the property. But this time we
invoke them instead:TIP
Code snippets here and below are meant to explain the core concepts in the simplest
form possible, so many details are omitted, and edge cases ignored.ⓘ
When you assign or destructure a reactive object's property to a local variable, the
reactivity is "disconnected" because access to the local variable no longer triggers the
get / set proxy traps.
The returned proxy from reactive(), although behaving just like the original, has a
different identity if we compare it to the original using the === operator.
// This will be set right before an effect is about
// to be run. We'll deal with this later.
let activeEffect
function track(target, key) {
  if (activeEffect) {
    const effects = getSubscribersForProperty(target, key)
    effects.add(activeEffect)
  }
}Now let's circle back to the whenDepsChange() function:
It wraps the raw update function in an effect that sets itself as the current active effect
before running the actual update. This enables track() calls during the update to locate
the current active effect.
At this point, we have created an effect that automatically tracks its dependencies, and re-
runs whenever a dependency changes. We call this a Reactive Effect.
Vue provides an API that allows you to create reactive effects: watchEffect(). In fact, you
may have noticed that it works pretty similarly to the magical whenDepsChange() in the
example. We can now rework the original example using actual Vue APIs:function trigger(target, key) {
  const effects = getSubscribersForProperty(target, key)
  effects.forEach((effect) => effect())
}
function whenDepsChange(update) {
  const effect = () => {
    activeEffect = effect
    update()
    activeEffect = null
  }
  effect()
}
import { ref, watchEffect } from 'vue'
const A0 = ref(0)
const A1 = ref(1)
const A2 = ref()
watchEffect(() => {
  // tracks A0 and A1
  A2.value = A0.value + A1.value
})
// triggers the effect
A0.value = 2Using a reactive effect to mutate a ref isn't the most interesting use case - in fact, using a
computed property makes it more declarative:
Internally, computed manages its invalidation and re-computation using a reactive effect.
So what's an example of a common and useful reactive effect? Well, updating the DOM! We
can implement simple "reactive rendering" like this:
In fact, this is pretty close to how a Vue component keeps the state and the DOM in sync -
each component instance creates a reactive effect to render and update the DOM. Of
course, Vue components use much more efficient ways to update the DOM than
innerHTML. This is discussed in Rendering Mechanism.
Vue's reactivity system is primarily runtime-based: the tracking and triggering are all
performed while the code is running directly in the browser. The pros of runtime reactivityRuntime vs. Compile-time Reactivityimport { ref, computed } from 'vue'
const A0 = ref(0)
const A1 = ref(1)
const A2 = computed(() => A0.value + A1.value)
A0.value = 2
import { ref, watchEffect } from 'vue'
const count = ref(0)
watchEffect(() => {
  document.body.innerHTML = `count is: ${count.value}`
})
// updates the DOM
count.value++are that it can work without a build step, and there are fewer edge cases. On the other hand,
this makes it constrained by the syntax limitations of JavaScript.
We have already encountered a limitation in the previous example: JavaScript does not
provide a way for us to intercept the reading and writing of local variables, so we have to
always access reactive state as object properties, using either reactive objects or refs.
We have been experimenting with the Reactivity Transform feature to reduce the code
verbosity:
This snippet compiles into exactly what we'd have written without the transform, by
automatically appending .value after references to the variables. With Reactivity
Transform, Vue's reactivity system becomes a hybrid one.
It's great that Vue's reactivity system automatically tracks dependencies, but in some cases
we may want to figure out exactly what is being tracked, or what is causing a component to
re-render.
We can debug what dependencies are used during a component's render and which
dependency is triggering an update using the onRenderTracked and onRenderTriggered
lifecycle hooks. Both hooks will receive a debugger event which contains information on theReactivity Debugging
Component Debugging Hookslet A0 = $ref(0)
let A1 = $ref(1)
// track on variable read
const A2 = $computed(() => A0 + A1)
// trigger on variable write
A0 = 2dependency in question. It is recommended to place a debugger statement in the
callbacks to interactively inspect the dependency:
The debug event objects have the following type:
We can debug computed properties by passing computed() a second options object with
onTrack and onTrigger callbacks:TIP
Component debug hooks only work in development mode.ⓘ
Computed Debugging
onTrack will be called when a reactive property or ref is tracked as a dependency.<script setup>
import { onRenderTracked, onRenderTriggered } from 'vue'
onRenderTracked((event) => {
  debugger
})
onRenderTriggered((event) => {
  debugger
})
</script>
type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type:
    | TrackOpTypes /* 'get' | 'has' | 'iterate' */
    | TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */
  key: any
  newValue?: any
  oldValue?: any
  oldTarget?: Map<any, any> | Set<any>
}vuBoth callbacks will receive debugger events in the same format as component debug
hooks:
Similar to computed(), watchers also support the onTrack and onTrigger options:onTrigger will be called when the watcher callback is triggered by the mutation of a
dependency.
TIP
onTrack and onTrigger computed options only work in development mode.ⓘ
Watcher Debuggingconst plusOne = computed(() => count.value + 1, {
  onTrack(e) {
    // triggered when count.value is tracked as a dependency
    debugger
  },
  onTrigger(e) {
    // triggered when count.value is mutated
    debugger
  }
})
// access plusOne, should trigger onTrack
console.log(plusOne.value)
// mutate count.value, should trigger onTrigger
count.value++Vue's reactivity system works by deeply converting plain JavaScript objects into reactive
proxies. The deep conversion can be unnecessary or sometimes unwanted when integrating
with external state management systems (e.g. if an external solution also uses Proxies).
The general idea of integrating Vue's reactivity system with an external state management
solution is to hold the external state in a shallowRef. A shallow ref is only reactive when its
.value property is accessed - the inner value is left intact. When the external state
changes, replace the ref value to trigger updates.TIP
onTrack and onTrigger watcher options only work in development mode.ⓘ
Integration with External State Systems
Immutable Datawatch(source, callback, {
  onTrack(e) {
    debugger
  },
  onTrigger(e) {
    debugger
  }
})
watchEffect(callback, {
  onTrack(e) {
    debugger
  },
  onTrigger(e) {
    debugger
  }
})If you are implementing an undo / redo feature, you likely want to take a snapshot of the
application's state on every user edit. However, Vue's mutable reactivity system isn't best
suited for this if the state tree is large, because serializing the entire state object on every
update can be expensive in terms of both CPU and memory costs.
Immutable data structures solve this by never mutating the state objects - instead, it
creates new objects that share the same, unchanged parts with old ones. There are different
ways of using immutable data in JavaScript, but we recommend using Immer with Vue
because it allows you to use immutable data while keeping the more ergonomic, mutable
syntax.
We can integrate Immer with Vue via a simple composable:
Try it in the Playground
State Machine is a model for describing all the possible states an application can be in, and
all the possible ways it can transition from one state to another. While it may be overkill for
simple components, it can help make complex state flows more robust and manageable.
One of the most popular state machine implementations in JavaScript is XState. Here's a
composable that integrates with it:▶
State Machinesimport produce from 'immer'
import { shallowRef } from 'vue'
export function useImmer(baseState) {
  const state = shallowRef(baseState)
  const update = (updater) => {
    state.value = produce(state.value, updater)
  }
  return [state, update]
}Try it in the Playground
RxJS is a library for working with asynchronous event streams. The VueUse library provides
the @vueuse/rxjs add-on for connecting RxJS streams with Vue's reactivity system.▶
RxJSimport { createMachine, interpret } from 'xstate'
import { shallowRef } from 'vue'
export function useMachine(options) {
  const machine = createMachine(options)
  const state = shallowRef(machine.initialState)
  const service = interpret(machine)
    .onTransition((newState) => (state.value = newState))
    .start()
  const send = (event) => service.send(event)
  return [state, send]
}How does Vue take a template and turn it into actual DOM nodes? How does Vue update
those DOM nodes efficiently? We will attempt to shed some light on these questions here by
diving into Vue's internal rendering mechanism.
You have probably heard about the term "virtual DOM", which Vue's rendering system is
based upon.
The virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”,
representation of a UI is kept in memory and synced with the “real” DOM. The concept was
pioneered by React, and has been adapted in many other frameworks with different
implementations, including Vue.
Virtual DOM is more of a pattern than a specific technology, so there is no one canonical
implementation. We can illustrate the idea using a simple example:
Here, vnode is a plain JavaScript object (a "virtual node") representing a <div> element.
It contains all the information that we need to create the actual element. It also contains
more children vnodes, which makes it the root of a virtual DOM tree.
A runtime renderer can walk a virtual DOM tree and construct a real DOM tree from it. This
process is called mount.Rendering Mechanism
Virtual DOM
const vnode = {
  type: 'div',
  props: {
    id: 'hello'
  },
  children: [
    /* more vnodes */
  ]
}If we have two copies of virtual DOM trees, the renderer can also walk and compare the two
trees, figuring out the differences, and apply those changes to the actual DOM. This process
is called patch, also known as "diffing" or "reconciliation".
The main benefit of virtual DOM is that it gives the developer the ability to programmatically
create, inspect and compose desired UI structures in a declarative way, while leaving the
direct DOM manipulation to the renderer.
At the high level, this is what happens when a Vue component is mounted:
Render Pipeline
Compile: Vue templates are compiled into render functions: functions that return virtual
DOM trees. This step can be done either ahead-of-time via a build step, or on-the-fly by
using the runtime compiler.1.
Mount: The runtime renderer invokes the render functions, walks the returned virtual
DOM tree, and creates actual DOM nodes based on it. This step is performed as a
reactive effect, so it keeps track of all reactive dependencies that were used.2.
Patch: When a dependency used during mount changes, the effect re-runs. This time, a
new, updated Virtual DOM tree is created. The runtime renderer walks the new tree,
compares it with the old one, and applies necessary updates to the actual DOM.3.Vue templates are compiled into virtual DOM render functions. Vue also provides APIs that
allow us to skip the template compilation step and directly author render functions. Render
functions are more flexible than templates when dealing with highly dynamic logic, because
you can work with vnodes using the full power of JavaScript.
So why does Vue recommend templates by default? There are a number of reasons:
In practice, templates are sufficient for most use cases in applications. Render functions are
typically only used in reusable components that need to deal with highly dynamic rendering
logic. Render function usage is discussed in more detail in Render Functions & JSX.
The virtual DOM implementation in React and most other virtual-DOM implementations are
purely runtime: the reconciliation algorithm cannot make any assumptions about the
incoming virtual DOM tree, so it has to fully traverse the tree and diff the props of every
vnode in order to ensure correctness. In addition, even if a part of the tree never changes,
new vnodes are always created for them on each re-render, resulting in unnecessary
memory pressure. This is one of the most criticized aspect of virtual DOM: the somewhat
brute-force reconciliation process sacrifices efficiency in return for declarativeness and
correctness.
But it doesn't have to be that way. In Vue, the framework controls both the compiler and the
runtime. This allows us to implement many compile-time optimizations that only a tightly-Templates vs. Render Functions
Templates are closer to actual HTML. This makes it easier to reuse existing HTML
snippets, apply accessibility best practices, style with CSS, and for designers to
understand and modify.1.
Templates are easier to statically analyze due to their more deterministic syntax. This
allows Vue's template compiler to apply many compile-time optimizations to improve the
performance of the virtual DOM (which we will discuss below).2.
Compiler-Informed Virtual DOMcoupled renderer can take advantage of. The compiler can statically analyze the template
and leave hints in the generated code so that the runtime can take shortcuts whenever
possible. At the same time, we still preserve the capability for the user to drop down to the
render function layer for more direct control in edge cases. We call this hybrid approach
Compiler-Informed Virtual DOM.
Below, we will discuss a few major optimizations done by the Vue template compiler to
improve the virtual DOM's runtime performance.
Quite often there will be parts in a template that do not contain any dynamic bindings:
Inspect in Template Explorer
The foo and bar divs are static - re-creating vnodes and diffing them on each re-render
is unnecessary. The Vue compiler automatically hoists their vnode creation calls out of the
render function, and reuses the same vnodes on every render. The renderer is also able to
completely skip diffing them when it notices the old vnode and the new vnode are the same
one.
In addition, when there are enough consecutive static elements, they will be condensed into
a single "static vnode" that contains the plain HTML string for all these nodes (Example).
These static vnodes are mounted by directly setting innerHTML. They also cache their
corresponding DOM nodes on initial mount - if the same piece of content is reused
elsewhere in the app, new DOM nodes are created using native cloneNode(), which is
extremely efficient.Static Hoisting
Patch Flags<div>
  <div>foo</div> <!-- hoisted -->
  <div>bar</div> <!-- hoisted -->
  <div>{{ dynamic }}</div>
</div>templaFor a single element with dynamic bindings, we can also infer a lot of information from it at
compile time:
Inspect in Template Explorer
When generating the render function code for these elements, Vue encodes the type of
update each of them needs directly in the vnode creation call:
The last argument, 2, is a patch flag. An element can have multiple patch flags, which will
be merged into a single number. The runtime renderer can then check against the flags
using bitwise operations to determine whether it needs to do certain work:
Bitwise checks are extremely fast. With the patch flags, Vue is able to do the least amount of
work necessary when updating elements with dynamic bindings.
Vue also encodes the type of children a vnode has. For example, a template that has
multiple root nodes is represented as a fragment. In most cases, we know for sure that the
order of these root nodes will never change, so this information can also be provided to the
runtime as a patch flag:<!-- class binding only -->
<div :class="{ active }"></div>
<!-- id and value bindings only -->
<input :id="id" :value="value">
<!-- text children only -->
<div>{{ dynamic }}</div>
createElementVNode("div", {
  class: _normalizeClass({ active: _ctx.active })
}, null, 2 /* CLASS */)
if (vnode.patchFlag & PatchFlags.CLASS /* 2 */) {
  // update the element's class
}templaThe runtime can thus completely skip child-order reconciliation for the root fragment.
Taking another look at the generated code from the previous example, you'll notice the root
of the returned virtual DOM tree is created using a special createElementBlock() call:
Conceptually, a "block" is a part of the template that has stable inner structure. In this case,
the entire template has a single block because it does not contain any structural directives
like v-if and v-for.
Each block tracks any descendant nodes (not just direct children) that have patch flags. For
example:
The result is a flattened array that contains only the dynamic descendant nodes:Tree Flatteningexport function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* children */
  ], 64 /* STABLE_FRAGMENT */))
}
export function render() {
  return (_openBlock(), _createElementBlock(_Fragment, null, [
    /* children */
  ], 64 /* STABLE_FRAGMENT */))
}
<div> <!-- root block -->
  <div>...</div>         <!-- not tracked -->
  <div :id="id"></div>   <!-- tracked -->
  <div>                  <!-- not tracked -->
    <div>{{ bar }}</div> <!-- tracked -->
  </div>
</div>templaWhen this component needs to re-render, it only needs to traverse the flattened tree instead
of the full tree. This is called Tree Flattening, and it greatly reduces the number of nodes
that need to be traversed during virtual DOM reconciliation. Any static parts of the template
are effectively skipped.
v-if and v-for directives will create new block nodes:
A child block is tracked inside the parent block's array of dynamic descendants. This retains
a stable structure for the parent block.
Both patch flags and tree flattening also greatly improve Vue's SSR Hydration performance:Impact on SSR Hydration
Single element hydration can take fast paths based on the corresponding vnode's patch
flag.
Only block nodes and their dynamic descendants need to be traversed during hydration,
effectively achieving partial hydration at the template level.div (block root)
- div with :id binding
- div with {{ bar }} binding
<div> <!-- root block -->
  <div>
    <div v-if> <!-- if block -->
      ...
    <div>
  </div>
</div>templaVue recommends using templates to build applications in the vast majority of cases.
However, there are situations where we need the full programmatic power of JavaScript.
That's where we can use the render function.
If you are new to the concept of virtual DOM and render functions, make sure to read the
Rendering Mechanism chapter first.
Vue provides an h() function for creating vnodes:
h() is short for hyperscript - which means "JavaScript that produces HTML (hypertext
markup language)". This name is inherited from conventions shared by many virtual DOM
implementations. A more descriptive name could be createVnode(), but a shorter name
helps when you have to call this function many times in a render function.
The h() function is designed to be very flexible:Render Functions & JSX
Basic Usage
Creating Vnodes
import { h } from 'vue'
const vnode = h(
  'div', // type
  { id: 'foo', class: 'bar' }, // props
  [
    /* children */
  ]
)The resulting vnode has the following shape:// all arguments except the type are optional
h('div')
h('div', { id: 'foo' })
// both attributes and properties can be used in props
// Vue automatically picks the right way to assign it
h('div', { class: 'bar', innerHTML: 'hello' })
// props modifiers such as .prop and .attr can be added
// with '.' and `^' prefixes respectively
h('div', { '.name': 'some-name', '^width': '100' })
// class and style have the same object / array
// value support that they have in templates
h('div', { class: [foo, { bar }], style: { color: 'red' } })
// event listeners should be passed as onXxx
h('div', { onClick: () => {} })
// children can be a string
h('div', { id: 'foo' }, 'hello')
// props can be omitted when there are no props
h('div', 'hello')
h('div', [h('span', 'hello')])
// children array can contain mixed vnodes and strings
h('div', ['hello', h('span', 'hello')])
const vnode = h('div', { id: 'foo' }, [])
vnode.type // 'div'
vnode.props // { id: 'foo' }
vnode.children // []
vnode.key // nullWhen using templates with Composition API, the return value of the setup() hook is used
to expose data to the template. When using render functions, however, we can directly
return the render function instead:
The render function is declared inside setup() so it naturally has access to the props and
any reactive state declared in the same scope.
In addition to returning a single vnode, you can also return strings or arrays:Note
The full VNode interface contains many other internal properties, but it is strongly
recommended to avoid relying on any properties other than the ones listed here. This
avoids unintended breakage in case the internal properties are changed.⚠
Declaring Render Functions
import { ref, h } from 'vue'
export default {
  props: {
    /* ... */
  },
  setup(props) {
    const count = ref(1)
    // return the render function
    return () => h('div', props.msg + count.value)
  }
}
export default {
  setup() {
    return () => 'hello world!'
  }
}If a render function component doesn't need any instance state, they can also be declared
directly as a function for brevity:
That's right, this is a valid Vue component! See Functional Components for more details on
this syntax.
All vnodes in the component tree must be unique. That means the following render function
is invalid:TIP
Make sure to return a function instead of directly returning values! The setup() function
is called only once per component, while the returned render function will be called
multiple times.ⓘ
Vnodes Must Be Uniqueimport { h } from 'vue'
export default {
  setup() {
    // use an array to return multiple root nodes
    return () => [
      h('div'),
      h('div'),
      h('div')
    ]
  }
}
function Hello() {
  return 'hello world!'
}If you really want to duplicate the same element/component many times, you can do so with
a factory function. For example, the following render function is a perfectly valid way of
rendering 20 identical paragraphs:
JSX is an XML-like extension to JavaScript that allows us to write code like this:
Inside JSX expressions, use curly braces to embed dynamic values:
create-vue and Vue CLI both have options for scaffolding projects with pre-configured
JSX support. If you are configuring JSX manually, please refer to the documentation ofJSX / TSXfunction render() {
  const p = h('p', 'hi')
  return h('div', [
    // Yikes - duplicate vnodes!
    p,
    p
  ])
}
function render() {
  return h(
    'div',
    Array.from({ length: 20 }).map(() => {
      return h('p', 'hi')
    })
  )
}
const vnode = <div>hello</div>
const vnode = <div id={dynamicId}>hello, {userName}</div>j
j@vue/babel-plugin-jsx for details.
Although first introduced by React, JSX actually has no defined runtime semantics and can
be compiled into various different outputs. If you have worked with JSX before, do note that
Vue JSX transform is different from React's JSX transform, so you can't use React's JSX
transform in Vue applications. Some notable differences from React JSX include:
Vue's type definition also provides type inference for TSX usage. When using TSX, make
sure to specify "jsx": "preserve" in tsconfig.json so that TypeScript leaves the JSX
syntax intact for Vue JSX transform to process.
Below we will provide some common recipes for implementing template features as their
equivalent render functions / JSX.
Template:
Equivalent render function / JSX:You can use HTML attributes such as class and for as props - no need to use
className or htmlFor.
Passing children to components (i.e. slots) works differently.
Render Function Recipes
v-if
<div>
  <div v-if="ok">yes</div>
  <span v-else>no</span>
</div>
h('div', [ok.value ? h('div', 'yes') : h('span', 'no')])templaTemplate:
Equivalent render function / JSX:
Props with names that start with on followed by an uppercase letter are treated as event
listeners. For example, onClick is the equivalent of @click in templates.v-for
v-on<div>{ok.value ? <div>yes</div> : <span>no</span>}</div>
<ul>
  <li v-for="{ id, text } in items" :key="id">
    {{ text }}
  </li>
</ul>
h(
  'ul',
  // assuming `items` is a ref with array value
  items.value.map(({ id, text }) => {
    return h('li', { key: id }, text)
  })
)
<ul>
  {items.value.map(({ id, text }) => {
    return <li key={id}>{text}</li>
  })}
</ul>j
templa
jFor the .passive, .capture, and .once event modifiers, they can be concatenated
after the event name using camelCase.
For example:Event Modifiersh(
  'button',
  {
    onClick(event) {
      /* ... */
    }
  },
  'click me'
)
<button
  onClick={(event) => {
    /* ... */
  }}
>
  click me
</button>
h('input', {
  onClickCapture() {
    /* listener in capture mode */
  },
  onKeyupOnce() {
    /* triggers only once */
  },
  onMouseoverOnceCapture() {
    /* once + capture */
  }
})
<input
  onClickCapture={() => {}}
  onKeyupOnce={() => {}}
  onMouseoverOnceCapture={() => {}}
/>j
jFor other event and key modifiers, the withModifiers helper can be used:
To create a vnode for a component, the first argument passed to h() should be the
component definition. This means when using render functions, it is unnecessary to register
components - you can just use the imported components directly:
As we can see, h can work with components imported from any file format as long as it's a
valid Vue component.
Dynamic components are straightforward with render functions:Componentsimport { withModifiers } from 'vue'
h('div', {
  onClick: withModifiers(() => {}, ['self'])
})
<div onClick={withModifiers(() => {}, ['self'])} />
import Foo from './Foo.vue'
import Bar from './Bar.jsx'
function render() {
  return h('div', [h(Foo), h(Bar)])
}
function render() {
  return (
    <div>
      <Foo />
      <Bar />
    </div>
  )
}j
jIf a component is registered by name and cannot be imported directly (for example, globally
registered by a library), it can be programmatically resolved by using the
resolveComponent() helper.
In render functions, slots can be accessed from the setup() context. Each slot on the
slots object is a function that returns an array of vnodes:Rendering Slotsimport Foo from './Foo.vue'
import Bar from './Bar.jsx'
function render() {
  return ok.value ? h(Foo) : h(Bar)
}
function render() {
  return ok.value ? <Foo /> : <Bar />
}
export default {
  props: ['message'],
  setup(props, { slots }) {
    return () => [
      // default slot:
      // <div><slot /></div>
      h('div', slots.default()),
      // named slot:
      // <div><slot name="footer" :text="message" /></div>
      h(
        'div',
        slots.footer({
          text: props.message
        })
      )
    ]
  }
}jJSX equivalent:
Passing children to components works a bit differently from passing children to elements.
Instead of an array, we need to pass either a slot function, or an object of slot functions. Slot
functions can return anything a normal render function can return - which will always be
normalized to arrays of vnodes when accessed in the child component.
JSX equivalent:Passing Slots// default
<div>{slots.default()}</div>
// named
<div>{slots.footer({ text: props.message })}</div>
// single default slot
h(MyComponent, () => 'hello')
// named slots
// notice the `null` is required to avoid
// the slots object being treated as props
h(MyComponent, null, {
  default: () => 'default slot',
  foo: () => h('div', 'foo'),
  bar: () => [h('span', 'one'), h('span', 'two')]
})
// default
<MyComponent>{() => 'hello'}</MyComponent>
// named
<MyComponent>{{
  default: () => 'default slot',
  foo: () => <div>foo</div>,
  bar: () => [<span>one</span>, <span>two</span>]
}}</MyComponent>j
jPassing slots as functions allows them to be invoked lazily by the child component. This
leads to the slot's dependencies being tracked by the child instead of the parent, which
results in more accurate and efficient updates.
Built-in components such as <KeepAlive>, <Transition>, <TransitionGroup>,
<Teleport> and <Suspense> must be imported for use in render functions:
The v-model directive is expanded to modelValue and onUpdate:modelValue props
during template compilation—we will have to provide these props ourselves:
Custom directives can be applied to a vnode using withDirectives:Built-in Components
v-model
Custom Directivesimport { h, KeepAlive, Teleport, Transition, TransitionGroup } from 'vue'
export default {
  setup () {
    return () => h(Transition, { mode: 'out-in' }, /* ... */)
  }
}
export default {
  props: ['modelValue'],
  emits: ['update:modelValue'],
  setup(props, { emit }) {
    return () =>
      h(SomeComponent, {
        modelValue: props.modelValue,
        'onUpdate:modelValue': (value) => emit('update:modelValue', value)
      })
  }
}If the directive is registered by name and cannot be imported directly, it can be resolved
using the resolveDirective helper.
Functional components are an alternative form of component that don't have any state of
their own. They act like pure functions: props in, vnodes out. They are rendered without
creating a component instance (i.e. no this), and without the usual component lifecycle
hooks.
To create a functional component we use a plain function, rather than an options object. The
function is effectively the render function for the component.
The signature of a functional component is the same as the setup() hook:
Most of the usual configuration options for components are not available for functional
components. However, it is possible to define props and emits by adding them as
properties:Functional Componentsimport { h, withDirectives } from 'vue'
// a custom directive
const pin = {
  mounted() { /* ... */ },
  updated() { /* ... */ }
}
// <div v-pin:top.animate="200"></div>
const vnode = withDirectives(h('div'), [
  [pin, 200, 'top', { animate: true }]
])
function MyComponent(props, { slots, emit, attrs }) {
  // ...
}If the props option is not specified, then the props object passed to the function will
contain all attributes, the same as attrs. The prop names will not be normalized to
camelCase unless the props option is specified.
For functional components with explicit props, attribute fallthrough works much the same
as with normal components. However, for functional components that don't explicitly specify
their props, only the class, style, and onXxx event listeners will be inherited from
the attrs by default. In either case, inheritAttrs can be set to false to disable
attribute inheritance:
Functional components can be registered and consumed just like normal components. If you
pass a function as the first argument to h(), it will be treated as a functional component.MyComponent.props = ['value']
MyComponent.emits = ['click']
MyComponent.inheritAttrs = falseWeb Components is an umbrella term for a set of web native APIs that allows developers to
create reusable custom elements.
We consider Vue and Web Components to be primarily complementary technologies. Vue
has excellent support for both consuming and creating custom elements. Whether you are
integrating custom elements into an existing Vue application, or using Vue to build and
distribute custom elements, you are in good company.
Vue scores a perfect 100% in the Custom Elements Everywhere tests. Consuming
custom elements inside a Vue application largely works the same as using native HTML
elements, with a few things to keep in mind:
By default, Vue will attempt to resolve a non-native HTML tag as a registered Vue
component before falling back to rendering it as a custom element. This will cause Vue to
emit a "failed to resolve component" warning during development. To let Vue know that
certain elements should be treated as custom elements and skip component resolution, we
can specify the compilerOptions.isCustomElement option.
If you are using Vue with a build setup, the option should be passed via build configs since it
is a compile-time option.Vue and Web Components
Using Custom Elements in Vue
Skipping Component Resolution
Example In-Browser Config
// Only works if using in-browser compilation.
// If using build tools, see config examples below.
app.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')Since DOM attributes can only be strings, we need to pass complex data to custom
elements as DOM properties. When setting props on a custom element, Vue 3 automatically
checks DOM-property presence using the in operator and will prefer setting the value as aExample Vite Config
Example Vue CLI Config
Passing DOM Properties// vite.config.js
import vue from '@vitejs/plugin-vue'
export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // treat all tags with a dash as custom elements
          isCustomElement: (tag) => tag.includes('-')
        }
      }
    })
  ]
}
// vue.config.js
module.exports = {
  chainWebpack: config => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => ({
        ...options,
        compilerOptions: {
          // treat any tag that starts with ion- as custom elements
          isCustomElement: tag => tag.startsWith('ion-')
        }
      }))
  }
}DOM property if the key is present. This means that, in most cases, you won't need to think
about this if the custom element follows the recommended best practices.
However, there could be rare cases where the data must be passed as a DOM property, but
the custom element does not properly define/reflect the property (causing the in check to
fail). In this case, you can force a v-bind binding to be set as a DOM property using the
.prop modifier:
The primary benefit of custom elements is that they can be used with any framework, or
even without a framework. This makes them ideal for distributing components where the end
consumer may not be using the same frontend stack, or when you want to insulate the end
application from the implementation details of the components it uses.
Vue supports creating custom elements using exactly the same Vue component APIs via the
defineCustomElement method. The method accepts the same argument as
defineComponent, but instead returns a custom element constructor that extends
HTMLElement:Building Custom Elements with Vue
defineCustomElement<my-element :user.prop="{ name: 'jack' }"></my-element>
<!-- shorthand equivalent -->
<my-element .user="{ name: 'jack' }"></my-element>
<my-vue-element></my-vue-element>templa
templaLifecycle
A Vue custom element will mount an internal Vue component instance inside its shadow
root when the element's connectedCallback is called for the first time.
When the element's disconnectedCallback is invoked, Vue will check whether the
element is detached from the document after a microtask tick.
If the element is still in the document, it's a move and the component instance will be
preserved;
If the element is detached from the document, it's a removal and the component
instance will be unmounted.
Props
All props declared using the props option will be defined on the custom element as
properties. Vue will automatically handle the reflection between attributes / propertiesimport { defineCustomElement } from 'vue'
const MyVueElement = defineCustomElement({
  // normal Vue component options here
  props: {},
  emits: {},
  template: `...`,
  // defineCustomElement only: CSS to be injected into shadow root
  styles: [`/* inlined css */`]
})
// Register the custom element.
// After registration, all `<my-vue-element>` tags
// on the page will be upgraded.
customElements.define('my-vue-element', MyVueElement)
// You can also programmatically instantiate the element:
// (can only be done after registration)
document.body.appendChild(
  new MyVueElement({
    // initial props (optional)
  })
)Events emitted via this.$emit or setup emit are dispatched as native CustomEvents on
the custom element. Additional event arguments (payload) will be exposed as an array on
the CustomEvent object as its detail property.
Inside the component, slots can be rendered using the <slot/> element as usual.
However, when consuming the resulting element, it only accepts native slots syntax:where appropriate.
Attributes are always reflected to corresponding properties.
Properties with primitive values (string, boolean or number) are reflected as
attributes.
Vue also automatically casts props declared with Boolean or Number types into the
desired type when they are set as attributes (which are always strings). For example,
given the following props declaration:
And the custom element usage:
In the component, selected will be cast to true (boolean) and index will be cast to
1 (number).
Events
Slots
Scoped slots are not supported.
When passing named slots, use the slot attribute instead of the v-slot directive:props: {
  selected: Boolean,
  index: Number
}
<my-element selected index="1"></my-element>templaThe Provide / Inject API and its Composition API equivalent also work between Vue-
defined custom elements. However, note that this works only between custom elements.
i.e. a Vue-defined custom element won't be able to inject properties provided by a non-
custom-element Vue component.
defineCustomElement also works with Vue Single-File Components (SFCs). However, with
the default tooling setup, the <style> inside the SFCs will still be extracted and merged
into a single CSS file during production build. When using an SFC as a custom element, it is
often desirable to inject the <style> tags into the custom element's shadow root instead.
The official SFC toolings support importing SFCs in "custom element mode" (requires
@vitejs/plugin-vue@^1.4.0 or vue-loader@^16.5.0). An SFC loaded in custom
element mode inlines its <style> tags as strings of CSS and exposes them under the
component's styles option. This will be picked up by defineCustomElement and injected
into the element's shadow root when instantiated.
To opt-in to this mode, simply end your component file name with .ce.vue:Provide / Inject
SFC as Custom Element<my-element>
  <div slot="named">hello</div>
</my-element>
import { defineCustomElement } from 'vue'
import Example from './Example.ce.vue'
console.log(Example.styles) // ["/* inlined css */"]
// convert into custom element constructor
const ExampleElement = defineCustomElement(Example)
// register
customElements.define('my-example', ExampleElement)templaIf you wish to customize what files should be imported in custom element mode (for
example, treating all SFCs as custom elements), you can pass the customElement option to
the respective build plugins:
When building custom elements with Vue, the elements will rely on Vue's runtime. There is a
~16kb baseline size cost depending on how many features are being used. This means it is
not ideal to use Vue if you are shipping a single custom element - you may want to use
vanilla JavaScript, petite-vue, or frameworks that specialize in small runtime size. However,
the base size is more than justifiable if you are shipping a collection of custom elements with
complex logic, as Vue will allow each component to be authored with much less code. The
more elements you are shipping together, the better the trade-off.
If the custom elements will be used in an application that is also using Vue, you can choose
to externalize Vue from the built bundle so that the elements will be using the same copy of
Vue from the host application.
It is recommended to export the individual element constructors to give your users the
flexibility to import them on-demand and register them with desired tag names. You can also
export a convenience function to automatically register all elements. Here's an example
entry point of a Vue custom element library:@vitejs/plugin-vue
vue-loader
Tips for a Vue Custom Elements LibraryIf you have many components, you can also leverage build tool features such as Vite's glob
import or webpack's require.context to load all components from a directory.
Some developers believe that framework-proprietary component models should be avoided,
and that exclusively using Custom Elements makes an application "future-proof". Here we
will try to explain why we believe that this is an overly simplistic take on the problem.
There is indeed a certain level of feature overlap between Custom Elements and Vue
Components: they both allow us to define reusable components with data passing, event
emitting, and lifecycle management. However, Web Components APIs are relatively low-level
and bare-bones. To build an actual application, we need quite a few additional capabilities
which the platform does not cover:Web Components vs. Vue Components
A declarative and efficient templating system;
A reactive state management system that facilitates cross-component logic extraction
and reuse;
A performant way to render the components on the server and hydrate them on the client
(SSR), which is important for SEO and Web Vitals metrics such as LCP. Native customimport { defineCustomElement } from 'vue'
import Foo from './MyFoo.ce.vue'
import Bar from './MyBar.ce.vue'
const MyFoo = defineCustomElement(Foo)
const MyBar = defineCustomElement(Bar)
// export individual elements
export { MyFoo, MyBar }
export function register() {
  customElements.define('my-foo', MyFoo)
  customElements.define('my-bar', MyBar)
}Vue's component model is designed with these needs in mind as a coherent system.
With a competent engineering team, you could probably build the equivalent on top of native
Custom Elements - but this also means you are taking on the long-term maintenance burden
of an in-house framework, while losing out on the ecosystem and community benefits of a
mature framework like Vue.
There are also frameworks built using Custom Elements as the basis of their component
model, but they all inevitably have to introduce their proprietary solutions to the problems
listed above. Using these frameworks entails buying into their technical decisions on how to
solve these problems - which, despite what may be advertised, doesn't automatically
insulate you from potential future churns.
There are also some areas where we find custom elements to be limiting:
Vue will always stay up to date with the latest standards in the web platform, and we will
happily leverage whatever the platform provides if it makes our job easier. However, our goal
is to provide solutions that work well and work today. That means we have to incorporate
new platform features with a critical mindset - and that involves filling the gaps where the
standards fall short while that is still the case.elements SSR typically involves simulating the DOM in Node.js and then serializing the
mutated DOM, while Vue SSR compiles into string concatenation whenever possible,
which is much more efficient.
Eager slot evaluation hinders component composition. Vue's scoped slots are a powerful
mechanism for component composition, which can't be supported by custom elements
due to native slots' eager nature. Eager slots also mean the receiving component cannot
control when or whether to render a piece of slot content.
Shipping custom elements with shadow DOM scoped CSS today requires embedding the
CSS inside JavaScript so that they can be injected into shadow roots at runtime. They
also result in duplicated styles in markup in SSR scenarios. There are platform features
being worked on in this area - but as of now they are not yet universally supported, and
there are still production performance / SSR concerns to be addressed. In the meanwhile,
Vue SFCs provide CSS scoping mechanisms that support extracting the styles into plain
CSS files.Vue provides the <Transition> and <TransitionGroup> components for handling enter /
leave and list transitions. However, there are many other ways of using animations on the
web, even in a Vue application. Here we will discuss a few additional techniques.
For elements that are not entering / leaving the DOM, we can trigger animations by
dynamically adding a CSS class:Animation Techniques
Class-based Animations
const disabled = ref(false)
function warnDisabled() {
  disabled.value = true
  setTimeout(() => {
    disabled.value = false
  }, 1500)
}
<div :class="{ shake: disabled }">
  <button @click="warnDisabled">Click me</button>
  <span v-if="disabled">This feature is disabled!</span>
</div>templaClick me
Some transition effects can be applied by interpolating values, for instance by binding a
style to an element while an interaction occurs. Take this example for instance:State-driven Animations.shake {
  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  transform: translate3d(0, 0, 0);
}
@keyframes shake {
  10%,
  90% {
    transform: translate3d(-1px, 0, 0);
  }
  20%,
  80% {
    transform: translate3d(2px, 0, 0);
  }
  30%,
  50%,
  70% {
    transform: translate3d(-4px, 0, 0);
  }
  40%,
  60% {
    transform: translate3d(4px, 0, 0);
  }
}cMove your mouse across this div...
x: 0
In addition to color, you can also use style bindings to animate transform, width, or height.
You can even animate SVG paths using spring physics - after all, they are all attribute data
bindings:const x = ref(0)
function onMousemove(e) {
  x.value = e.clientX
}
<div
  @mousemove="onMousemove"
  :style="{ backgroundColor: `hsl(${x}, 80%, 50%)` }"
  class="movearea"
>
  <p>Move your mouse across this div...</p>
  <p>x: {{ x }}</p>
</div>
.movearea {
  transition: 0.3s background-color ease;
}
Drag Me
Source code ▶templa
cWith some creativity, we can use watchers to animate anything based on some numerical
state. For example, we can animate the number itself:
Type a number: 0
0
Try it in the PlaygroundAnimating with Watchers
▶import { ref, reactive, watch } from 'vue'
import gsap from 'gsap'
const number = ref(0)
const tweened = reactive({
  number: 0
})
watch(number, (n) => {
  gsap.to(tweened, { duration: 0.5, number: Number(n) || 0 })
})
Type a number: <input v-model.number="number" />
<p>{{ tweened.number.toFixed(0) }}</p>templaEver since the introduction of the Composition API, one of the primary unresolved questions
is the use of refs vs. reactive objects. It's easy to lose reactivity when destructuring reactive
objects, while it can be cumbersome to use .value everywhere when using refs. Also,
.value is easy to miss if not using a type system.
Vue Reactivity Transform is a compile-time transform that allows us to write code like this:Reactivity Transform
Experimental Feature
Reactivity Transform is currently an experimental feature. It is disabled by default and
requires explicit opt-in. It may also change before being finalized. To stay up-to-date,
keep an eye on its proposal and discussion on GitHub.⚠
Composition-API-specific
Reactivity Transform is a Composition-API-specific feature and requires a build step.ⓘ
Refs vs. Reactive Variables
<script setup>
let count = $ref(0)
console.log(count)
function increment() {
  count++
}
</script>
<template>
  <button @click="increment">{{ count }}</button>
</template>vuThe $ref() method here is a compile-time macro: it is not an actual method that will be
called at runtime. Instead, the Vue compiler uses it as a hint to treat the resulting count
variable as a reactive variable.
Reactive variables can be accessed and re-assigned just like normal variables, but these
operations are compiled into refs with .value. For example, the <script> part of the
above component is compiled into:
Every reactivity API that returns refs will have a $-prefixed macro equivalent. These APIs
include:
These macros are globally available and do not need to be imported when Reactivity
Transform is enabled, but you can optionally import them from vue/macros if you want to
be more explicit:ref -> $ref
computed -> $computed
shallowRef -> $shallowRef
customRef -> $customRef
toRef -> $toRefimport { ref } from 'vue'
let count = ref(0)
console.log(count.value)
function increment() {
  count.value++
}
import { $ref } from 'vue/macros'
let count = $ref(0)It is common for a composition function to return an object of refs, and use destructuring to
retrieve these refs. For this purpose, reactivity transform provides the $ ( ) macro:
Compiled output:
Note that if x is already a ref, toRef(__temp, 'x') will simply return it as-is and no
additional ref will be created. If a destructured value is not a ref (e.g. a function), it will still
work - the value will be wrapped in a ref so the rest of the code works as expected.
$() destructure works on both reactive objects and plain objects containing refs.
In some cases we may have wrapped functions that also return refs. However, the Vue
compiler won't be able to know ahead of time that a function is going to return a ref. In such
cases, the $() macro can also be used to convert any existing refs into reactive variables:Destructuring with $ ( )
Convert Existing Refs to Reactive Variables with $ ( )import { useMouse } from '@vueuse/core'
const { x, y } = $(useMouse())
console.log(x, y)
import { toRef } from 'vue'
import { useMouse } from '@vueuse/core'
const __temp = useMouse(),
  x = toRef(__temp, 'x'),
  y = toRef(__temp, 'y')
console.log(x.value, y.value)There are two pain points with the current defineProps() usage in <script setup>:
We can address these issues by applying a compile-time transform when defineProps is
used with destructuring, similar to what we saw earlier with $():Reactive Props Destructure
Similar to .value, you need to always access props as props.x in order to retain
reactivity. This means you cannot destructure defineProps because the resulting
destructured variables are not reactive and will not update.1.
When using the type-only props declaration, there is no easy way to declare default
values for the props. We introduced the withDefaults() API for this exact purpose, but
it's still clunky to use.2.function myCreateRef() {
  return ref(0)
}
let count = $(myCreateRef())The above will be compiled into the following runtime declaration equivalent:
Retaining Reactivity Across Function Boundaries<script setup lang="ts">
  interface Props {
    msg: string
    count?: number
    foo?: string
  }
  const {
    msg,
    // default value just works
    count = 1,
    // local aliasing also just works
    // here we are aliasing `props.foo` to `bar`
    foo: bar
  } = defineProps<Props>()
  watchEffect(() => {
    // will log whenever the props change
    console.log(msg, count, bar)
  })
</script>
export default {
  props: {
    msg: { type: String, required: true },
    count: { type: Number, default: 1 },
    foo: String
  },
  setup(props) {
    watchEffect(() => {
      console.log(props.msg, props.count, props.foo)
    })
  }
}htmWhile reactive variables relieve us from having to use .value everywhere, it creates an
issue of "reactivity loss" when we pass reactive variables across function boundaries. This
can happen in two cases:
Given a function that expects a ref as an argument, e.g.:
The above case will not work as expected because it compiles to:
Here count.value is passed as a number, whereas trackChange expects an actual ref.
This can be fixed by wrapping count with $$() before passing it:
The above compiles to:Passing into function as argument
function trackChange(x: Ref<number>) {
  watch(x, (x) => {
    console.log('x changed!')
  })
}
let count = $ref(0)
trackChange(count) // doesn't work!
let count = ref(0)
trackChange(count.value)
let count = $ref(0)
- trackChange(count)
+ trackChange($$(count))
import { ref } from 'vue'
let count = ref(0)
trackChange(count)dAs we can see, $$() is a macro that serves as an escape hint: reactive variables inside
$$() will not get .value appended.
Reactivity can also be lost if reactive variables are used directly in a returned expression:
The above return statement compiles to:
In order to retain reactivity, we should be returning the actual refs, not the current value at
return time.
Again, we can use $$() to fix this. In this case, $$() can be used directly on the returned
object - any reference to reactive variables inside the $$() call will retain the reference to
their underlying refs:Returning inside function scope
function useMouse() {
  let x = $ref(0)
  let y = $ref(0)
  // listen to mousemove...
  // doesn't work!
  return {
    x,
    y
  }
}
return {
  x: x.value,
  y: y.value
}$$() works on destructured props since they are reactive variables as well. The compiler
will convert it with toRef for efficiency:
compiles to:
Vue provides typings for these macros (available globally) and all types will work as
expected. There are no incompatibilities with standard TypeScript semantics, so the syntax
will work with all existing tooling.Using $$() on destructured props
TypeScript Integration TSfunction useMouse() {
  let x = $ref(0)
  let y = $ref(0)
  // listen to mousemove...
  // fixed
  return $$({
    x,
    y
  })
}
const { count } = defineProps<{ count: number }>()
passAsRef($$(count))
setup(props) {
  const __props_count = toRef(props, 'count')
  passAsRef(__props_count)
}This also means the macros can work in any files where valid JS / TS are allowed - not just
inside Vue SFCs.
Since the macros are available globally, their types need to be explicitly referenced (e.g. in a
env.d.ts file):
When explicitly importing the macros from vue/macros, the type will work without
declaring the globals.
Reactivity Transform is currently disabled by default and requires explicit opt-in. In addition,
all of the following setups require vue@^3.2.25.Explicit Opt-in
Vite
Requires @vitejs/plugin-vue@>=2.0.0
Applies to SFCs and js(x)/ts(x) files. A fast usage check is performed on files before
applying the transform so there should be no performance cost for files not using the
macros.
Note reactivityTransform is now a plugin root-level option instead of nested as
script.refSugar, since it affects not just SFCs./// <reference types="vue/macros-global" />
// vite.config.js
export default {
  plugins: [
    vue({
      reactivityTransform: true
    })
  ]
}vue-cli
Currently only affects SFCs
Requires vue-loader@>=17.0.0
Plain webpack + vue-loader
Currently only affects SFCs
Requires vue-loader@>=17.0.0// vue.config.js
module.exports = {
  chainWebpack: (config) => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap((options) => {
        return {
          ...options,
          reactivityTransform: true
        }
      })
  }
}
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: {
          reactivityTransform: true
        }
      }
    ]
  }
}Creates an application instance.Application API
createApp()
Type
Details
The first argument is the root component. The second optional argument is the props to
be passed to the root component.
Example
With inline root component:
With imported component:
See also:Guide - Creating a Vue Applicationfunction createApp(rootComponent: Component, rootProps?: object): App
import { createApp } from 'vue'
const app = createApp({
  /* root component options */
})
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)Creates an application instance in SSR Hydration mode. Usage is exactly the same as
createApp().
Mounts the application instance in a container element.createSSRApp()
app.mount()
Type
Details
The argument can either be an actual DOM element or a CSS selector (the first matched
element will be used). Returns the root component instance.
If the component has a template or a render function defined, it will replace any existing
DOM nodes inside the container. Otherwise, if the runtime compiler is available, the
innerHTML of the container will be used as the template.
In SSR hydration mode, it will hydrate the existing DOM nodes inside the container. If
there are mismatches, the existing DOM nodes will be morphed to match the expected
output.
For each app instance, mount() can only be called once.
Exampleinterface App {
  mount(rootContainer: Element | string): ComponentPublicInstance
}Unmounts a mounted application instance, triggering the unmount lifecycle hooks for all
components in the application's component tree.
Provide a value that can be injected in all descendant components within the application.Can also mount to an actual DOM element:
app.unmount()
Type
app.provide()
Typeimport { createApp } from 'vue'
const app = createApp(/* ... */)
app.mount('#app')
app.mount(document.body.firstChild)
interface App {
  unmount(): void
}
interface App {
  provide<T>(key: InjectionKey<T> | symbol | string, value: T): this
}Registers a global component if passing both a name string and a component definition, or
retrieves an already registered one if only the name is passed.Details
Expects the injection key as the first argument, and the provided value as the second.
Returns the application instance itself.
Example
Inside a component in the application:
See also:
Provide / Inject
App-level Provide
app.component()
Typeimport { createApp } from 'vue'
const app = createApp(/* ... */)
app.provide('message', 'hello')
import { inject } from 'vue'
export default {
  setup() {
    console.log(inject('message')) // 'hello'
  }
}Registers a global custom directive if passing both a name string and a directive definition,
or retrieves an already registered one if only the name is passed.Example
See also:Component Registration
app.directive()
Type
Exampleinterface App {
  component(name: string): Component | undefined
  component(name: string, component: Component): this
}
import { createApp } from 'vue'
const app = createApp({})
// register an options object
app.component('my-component', {
  /* ... */
})
// retrieve a registered component
const MyComponent = app.component('my-component')
interface App {
  directive(name: string): Directive | undefined
  directive(name: string, directive: Directive): this
}Installs a plugin.See also:Custom Directives
app.use()
Type
Details
Expects the plugin as the first argument, and optional plugin options as the second
argument.
The plugin can either be an object with an install() method, or just a function that will
be used as the install() method. The options (second argument of app.use()) willimport { createApp } from 'vue'
const app = createApp({
  /* ... */
})
// register (object directive)
app.directive('my-directive', {
  /* custom directive hooks */
})
// register (function directive shorthand)
app.directive('my-directive', () => {
  /* ... */
})
// retrieve a registered directive
const myDirective = app.directive('my-directive')
interface App {
  use(plugin: Plugin, ...options: any[]): this
}Applies a global mixin (scoped to the application). A global mixin applies its included options
to every component instance in the application.be passed along to the plugin's install() method.
When app.use() is called on the same plugin multiple times, the plugin will be installed
only once.
Example
See also:Plugins
app.mixin()
Not Recommended
Mixins are supported in Vue 3 mainly for backwards compatibility, due to their
widespread use in ecosystem libraries. Use of mixins, especially global mixins, should be
avoided in application code.
For logic reuse, prefer Composables instead.⚠
Typeimport { createApp } from 'vue'
import MyPlugin from './plugins/MyPlugin'
const app = createApp({
  /* ... */
})
app.use(MyPlugin)
interface App {
  mixin(mixin: ComponentOptions): this
}Provides the version of Vue that the application was created with. This is useful inside
plugins, where you might need conditional logic based on different Vue versions.
Every application instance exposes a config object that contains the configuration
settings for that application. You can modify its properties (documented below) before
mounting your application.app.version
Type
Example
Performing a version check inside a plugin:
See also:Global API - version
app.configinterface App {
  version: string
}
export default {
  install(app) {
    const version = Number(app.version.split('.')[0])
    if (version < 3) {
      console.warn('This plugin requires Vue 3')
    }
  }
}Assign a global handler for uncaught errors propagating from within the application.app.config.errorHandler
Type
Details
The error handler receives three arguments: the error, the component instance that
triggered the error, and an information string specifying the error source type.
It can capture errors from the following sources:
Component renders
Event handlers
Lifecycle hooks
setup() function
Watchers
Custom directive hooks
Transition hooksimport { createApp } from 'vue'
const app = createApp(/* ... */)
console.log(app.config)
interface AppConfig {
  errorHandler?: (
    err: unknown,
    instance: ComponentPublicInstance | null,
    // `info` is a Vue-specific error info,
    // e.g. which lifecycle hook the error was thrown in
    info: string
  ) => void
}Assign a custom handler for runtime warnings from Vue.Example
app.config.warnHandler
Type
Details
The warning handler receives the warning message as the first argument, the source
component instance as the second argument, and a component trace string as the third.
It can be used to filter out specific warnings to reduce console verbosity. All Vue warnings
should be addressed during development, so this is only recommended during debug
sessions to focus on specific warnings among many, and should be removed once the
debugging is done.
TIP
Warnings only work during development, so this config is ignored in production mode.ⓘapp.config.errorHandler = (err, instance, info) => {
  // handle error, e.g. report to a service
}
interface AppConfig {
  warnHandler?: (
    msg: string,
    instance: ComponentPublicInstance | null,
    trace: string
  ) => void
}Set this to true to enable component init, compile, render and patch performance tracing
in the browser devtool performance/timeline panel. Only works in development mode and in
browsers that support the performance.mark API.
Configure runtime compiler options. Values set on this object will be passed to the in-
browser template compiler and affect every component in the configured app. Note you can
also override these options on a per-component basis using the compilerOptions option.Example
app.config.performance
Type: boolean
See also:Guide - Performance
app.config.compilerOptionsapp.config.warnHandler = (msg, instance, trace) => {
  // `trace` is the component hierarchy trace
}Specifies a check method to recognize native custom elements.Important
This config option is only respected when using the full build (i.e. the standalone vue.js
that can compile templates in the browser). If you are using the runtime-only build with a
build setup, compiler options must be passed to @vue/compiler-dom via build tool
configurations instead.⚠
For vue-loader: pass via the compilerOptions loader option. Also see how to
configure it in vue-cli.
For vite: pass via @vitejs/plugin-vue options.
app.config.compilerOptions.isCustomElement
Type:(tag: string) => boolean
Details
Should return true if the tag should be treated as a native custom element. For a
matched tag, Vue will render it as a native element instead of attempting to resolve it as a
Vue component.
Native HTML and SVG tags don't need to be matched in this function - Vue's parser
recognizes them automatically.
Example
See also:Vue and Web Components
app.config.compilerOptions.whitespace// treat all tags starting with 'ion-' as custom elements
app.config.compilerOptions.isCustomElement = (tag) => {
  return tag.startsWith('ion-')
}Adjusts template whitespace handling behavior.
Adjusts the delimiters used for text interpolation within the template.Type:'condense' | 'preserve'
Default:'condense'
Details
Vue removes / condenses whitespace characters in templates to produce more efficient
compiled output. The default strategy is "condense", with the following behavior:
Setting this option to 'preserve' will disable (2) and (3).Leading / ending whitespace characters inside an element are condensed into a single
space.1.
Whitespace characters between elements that contain newlines are removed. 2.
Consecutive whitespace characters in text nodes are condensed into a single space. 3.
Example
app.config.compilerOptions.delimiters
Type:[string, string]
Default:['{{', '}}']
Details
This is typically used to avoid conflicting with server-side frameworks that also use
mustache syntax.
Exampleapp.config.compilerOptions.whitespace = 'preserve'Adjusts treatment of HTML comments in templates.
An object that can be used to register global properties that can be accessed on any
component instance inside the application.app.config.compilerOptions.comments
Type:boolean
Default:false
Details
By default, Vue will remove the comments in production. Setting this option to true will
force Vue to preserve comments even in production. Comments are always preserved
during development. This option is typically used when Vue is used with other libraries
that rely on HTML comments.
Example
app.config.globalProperties
Type// Delimiters changed to ES6 template string style
app.config.compilerOptions.delimiters = ['${', '}']
app.config.compilerOptions.comments = true
interface AppConfig {
  globalProperties: Record<string, any>
}An object for defining merging strategies for custom component options.Details
This is a replacement of Vue 2's Vue.prototype which is no longer present in Vue 3. As
with anything global, this should be used sparingly.
If a global property conflicts with a componentʼs own property, the component's own
property will have higher priority.
Usage
This makes msg available inside any component template in the application, and also on
this of any component instance:
See also:Guide - Augmenting Global PropertiesTS
app.config.optionMergeStrategies
Typeapp.config.globalProperties.msg = 'hello'
export default {
  mounted() {
    console.log(this.msg) // 'hello'
  }
}
interface AppConfig {
  optionMergeStrategies: Record<string, OptionMergeFunction>
}
type OptionMergeFunction = (to: unknown, from: unknown) => anyDetails
Some plugins / libraries add support for custom component options (by injecting global
mixins). These options may require special merging logic when the same option needs to
be "merged" from multiple sources (e.g. mixins or component inheritance).
A merge strategy function can be registered for a custom option by assigning it on the
app.config.optionMergeStrategies object using the option's name as the key.
The merge strategy function receives the value of that option defined on the parent and
child instances as the first and second arguments, respectively.
Example
See also:Component Instance - $optionsconst app = createApp({
  // option from self
  msg: 'Vue',
  // option from a mixin
  mixins: [
    {
      msg: 'Hello '
    }
  ],
  mounted() {
    // merged options exposed on this.$options
    console.log(this.$options.msg)
  }
})
// define a custom merge strategy for `msg`
app.config.optionMergeStrategies.msg = (parent, child) => {
  return (parent || '') + (child || '')
}
app.mount('#app')
// logs 'Hello Vue'Exposes the current version of Vue.
A utility for waiting for the next DOM update flush.Global API: General
version
Type:string
Example
nextTick()
Type
Details
When you mutate reactive state in Vue, the resulting DOM updates are not applied
synchronously. Instead, Vue buffers them until the "next tick" to ensure that each
component updates only once no matter how many state changes you have made.
nextTick() can be used immediately after a state change to wait for the DOM updates
to complete. You can either pass a callback as an argument, or await the returned
Promise.import { version } from 'vue'
console.log(version)
function nextTick(callback?: () => void): Promise<void>A type helper for defining a Vue component with type inference.Example
See also:this.$nextTick()
defineComponent()
Type
Type is simplified for readability.
Details<script setup>
import { ref, nextTick } from 'vue'
const count = ref(0)
async function increment() {
  count.value++
  // DOM not yet updated
  console.log(document.getElementById('counter').textContent) // 0
  await nextTick()
  // DOM is now updated
  console.log(document.getElementById('counter').textContent) // 1
}
</script>
<template>
  <button id="counter" @click="increment">{{ count }}</button>
</template>
function defineComponent(
  component: ComponentOptions | ComponentOptions['setup']
): ComponentConstructorvuThe first argument expects a component options object. The return value will be the same
options object, since the function is essentially a runtime no-op for type inference
purposes only.
Note that the return type is a bit special: it will be a constructor type whose instance type
is the inferred component instance type based on the options. This is used for type
inference when the returned type is used as a tag in TSX.
You can extract the instance type of a component (equivalent to the type of this in its
options) from the return type of defineComponent() like this:
Because defineComponent() is a function call, it could look like that it would produce
side-effects to some build tools, e.g. webpack. This will prevent the component from
being tree-shaken even when the component is never used.
To tell webpack that this function call is safe to be tree-shaken, you can add a
/*#__PURE__*/ comment notation before the function call:
Note this is not necessary if you are using Vite, because Rollup (the underlying
production bundler used by Vite) is smart enough to determine that defineComponent()
is in fact side-effect-free without the need for manual annotations.Note on webpack Treeshaking
See also:Guide - Using Vue with TypeScript
defineAsyncComponent()const Foo = defineComponent(/* ... */)
type FooInstance = InstanceType<typeof Foo>
export default /*#__PURE__*/ defineComponent(/* ... */)Define an async component which is lazy loaded only when it is rendered. The argument can
either be a loader function, or an options object for more advanced control of the loading
behavior.
This method accepts the same argument as defineComponent, but instead returns a native
Custom Element class constructor.Type
See also:Guide - Async Components
defineCustomElement()
Typefunction defineAsyncComponent(
  source: AsyncComponentLoader | AsyncComponentOptions
): Component
type AsyncComponentLoader = () => Promise<Component>
interface AsyncComponentOptions {
  loader: AsyncComponentLoader
  loadingComponent?: Component
  errorComponent?: Component
  delay?: number
  timeout?: number
  suspensible?: boolean
  onError?: (
    error: Error,
    retry: () => void,
    fail: () => void,
    attempts: number
  ) => any
}Type is simplified for readability.
Details
In addition to normal component options, defineCustomElement() also supports a
special option styles, which should be an array of inlined CSS strings, for providing
CSS that should be injected into the element's shadow root.
The return value is a custom element constructor that can be registered using
customElements.define().
Example
See also:
Guide - Building Custom Elements with Vue
Also note that defineCustomElement() requires special config when used with
Single-File Components.function defineCustomElement(
  component:
    | (ComponentOptions & { styles?: string[] })
    | ComponentOptions['setup']
): {
  new (props?: object): HTMLElement
}
import { defineCustomElement } from 'vue'
const MyVueElement = defineCustomElement({
  /* component options */
})
// Register the custom element.
customElements.define('my-vue-element', MyVueElement)The setup() hook serves as the entry point for Composition API usage in components in
the following cases:
We can declare reactive state using Reactivity APIs and expose them to the template by
returning an object from setup(). The properties on the returned object will also be made
available on the component instance (if other options are used):Composition API: setup()
Basic Usage
Using Composition API without a build step; 1.
Integrating with Composition-API-based code in an Options API component. 2.
Note
If you are using Composition API with Single-File Components, <script setup> is
strongly recommended for a more succinct and ergonomic syntax.ⓘrefs returned from setup are automatically shallow unwrapped when accessed in the
template so you do not need to use .value when accessing them. They are also
unwrapped in the same way when accessed on this.
setup() itself does not have access to the component instance - this will have a value
of undefined inside setup(). You can access Composition-API-exposed values from
Options API, but not the other way around.
setup() should return an object synchronously. The only case when async setup() can
be used is when the component is a descendant of a Suspense component.
The first argument in the setup function is the props argument. Just as you would
expect in a standard component, props inside of a setup function are reactive and willAccessing Props<script>
import { ref } from 'vue'
export default {
  setup() {
    const count = ref(0)
    // expose to template and other options API hooks
    return {
      count
    }
  },
  mounted() {
    console.log(this.count) // 0
  }
}
</script>
<template>
  <button @click="count++">{{ count }}</button>
</template>vube updated when new props are passed in.
Note that if you destructure the props object, the destructured variables will lose
reactivity. It is therefore recommended to always access props in the form of props.xxx.
If you really need to destructure the props, or need to pass a prop into an external function
while retaining reactivity, you can do so with the toRefs() and toRef() utility APIs:
The second argument passed to the setup function is a Setup Context object. The
context object exposes other values that may be useful inside setup:Setup Contextexport default {
  props: {
    title: String
  },
  setup(props) {
    console.log(props.title)
  }
}
import { toRefs, toRef } from 'vue'
export default {
  setup(props) {
    // turn `props` into an object of refs, then destructure
    const { title } = toRefs(props)
    // `title` is a ref that tracks `props.title`
    console.log(title.value)
    // OR, turn a single property on `props` into a ref
    const title = toRef(props, 'title')
  }
}The context object is not reactive and can be safely destructured:
attrs and slots are stateful objects that are always updated when the component itself
is updated. This means you should avoid destructuring them and always reference
properties as attrs.x or slots.x. Also note that, unlike props, the properties of
attrs and slots are not reactive. If you intend to apply side effects based on changes
to attrs or slots, you should do so inside an onBeforeUpdate lifecycle hook.
expose is a function that can be used to explicitly limit the properties exposed when the
component instance is accessed by a parent component via template refs:Exposing Public Propertiesexport default {
  setup(props, context) {
    // Attributes (Non-reactive object, equivalent to $attrs)
    console.log(context.attrs)
    // Slots (Non-reactive object, equivalent to $slots)
    console.log(context.slots)
    // Emit events (Function, equivalent to $emit)
    console.log(context.emit)
    // Expose public properties (Function)
    console.log(context.expose)
  }
}
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}setup can also return a render function which can directly make use of the reactive state
declared in the same scope:
Returning a render function prevents us from returning anything else. Internally that
shouldn't be a problem, but it can be problematic if we want to expose methods of this
component to the parent component via template refs.
We can solve this problem by calling expose():Usage with Render Functionsexport default {
  setup(props, { expose }) {
    // make the instance "closed" -
    // i.e. do not expose anything to the parent
    expose()
    const publicCount = ref(0)
    const privateCount = ref(0)
    // selectively expose local state
    expose({ count: publicCount })
  }
}
import { h, ref } from 'vue'
export default {
  setup() {
    const count = ref(0)
    return () => h('div', count.value)
  }
}The increment method would then be available in the parent component via a template ref.import { h, ref } from 'vue'
export default {
  setup(props, { expose }) {
    const count = ref(0)
    const increment = () => ++count.value
    expose({
      increment
    })
    return () => h('div', count.value)
  }
}Takes an inner value and returns a reactive and mutable ref object, which has a single
property .value that points to the inner value.Reactivity API: Core
See also
To better understand the Reactivity APIs, it is recommended to read the following
chapters in the guide:ⓘ
Reactivity Fundamentals (with the API preference set to Composition API)
Reactivity in Depth
ref()
Type
Details
The ref object is mutable - i.e. you can assign new values to .value. It is also reactive -
i.e. any read operations to .value are tracked, and write operations will trigger
associated effects.
If an object is assigned as a ref's value, the object is made deeply reactive with
reactive(). This also means if the object contains nested refs, they will be deeply
unwrapped.
To avoid the deep conversion, use shallowRef() instead.function ref<T>(value: T): Ref<UnwrapRef<T>>
interface Ref<T> {
  value: T
}Takes a getter function and returns a readonly reactive ref object for the returned value from
the getter. It can also take an object with get and set functions to create a writable ref
object.Example
See also:
Guide - Reactive Variables with ref()
Guide - Typing ref()TS
computed()
Typeconst count = ref(0)
console.log(count.value) // 0
count.value++
console.log(count.value) // 1
// read-only
function computed<T>(
  getter: () => T,
  // see "Computed Debugging" link below
  debuggerOptions?: DebuggerOptions
): Readonly<Ref<Readonly<T>>>
// writable
function computed<T>(
  options: {
    get: () => T
    set: (value: T) => void
  },
  debuggerOptions?: DebuggerOptions
): Ref<T>Example
Creating a readonly computed ref:
Creating a writable computed ref:
Debugging:
See also:
Guide - Computed Properties
Guide - Computed Debuggingconst count = ref(1)
const plusOne = computed(() => count.value + 1)
console.log(plusOne.value) // 2
plusOne.value++ // error
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: (val) => {
    count.value = val - 1
  }
})
plusOne.value = 1
console.log(count.value) // 0
const plusOne = computed(() => count.value + 1, {
  onTrack(e) {
    debugger
  },
  onTrigger(e) {
    debugger
  }
})Returns a reactive proxy of the object.Guide - Typing computed()TS
reactive()
Type
Details
The reactive conversion is "deep": it affects all nested properties. A reactive object also
deeply unwraps any properties that are refs while maintaining reactivity.
It should also be noted that there is no ref unwrapping performed when the ref is
accessed as an element of a reactive array or a native collection type like Map.
To avoid the deep conversion and only retain reactivity at the root level, use
shallowReactive() instead.
The returned object and its nested objects are wrapped with ES Proxy and not equal to
the original objects. It is recommended to work exclusively with the reactive proxy and
avoid relying on the original object.
Example
Creating a reactive object:
Ref unwrapping:function reactive<T extends object>(target: T): UnwrapNestedRefs<T>
const obj = reactive({ count: 0 })
obj.count++Note that refs are not unwrapped when accessed as array or collection elements:
When assigning a ref to a reactive property, that ref will also be automatically
unwrapped:
See also:
Guide - Reactivity Fundamentals
Guide - Typing reactive()TSconst count = ref(1)
const obj = reactive({ count })
// ref will be unwrapped
console.log(obj.count === count.value) // true
// it will update `obj.count`
count.value++
console.log(count.value) // 2
console.log(obj.count) // 2
// it will also update `count` ref
obj.count++
console.log(obj.count) // 3
console.log(count.value) // 3
const books = reactive([ref('Vue 3 Guide')])
// need .value here
console.log(books[0].value)
const map = reactive(new Map([['count', ref(0)]]))
// need .value here
console.log(map.get('count').value)
const count = ref(1)
const obj = reactive({})
obj.count = count
console.log(obj.count) // 1
console.log(obj.count === count.value) // trueTakes an object (reactive or plain) or a ref and returns a readonly proxy to the original.readonly()
Type
Details
A readonly proxy is deep: any nested property accessed will be readonly as well. It also
has the same ref-unwrapping behavior as reactive(), except the unwrapped values will
also be made readonly.
To avoid the deep conversion, use shallowReadonly() instead.
Examplefunction readonly<T extends object>(
  target: T
): DeepReadonly<UnwrapNestedRefs<T>>
const original = reactive({ count: 0 })
const copy = readonly(original)
watchEffect(() => {
  // works for reactivity tracking
  console.log(copy.count)
})
// mutating original will trigger watchers relying on the copy
original.count++
// mutating the copy will fail and result in a warning
copy.count++ // warning!Runs a function immediately while reactively tracking its dependencies and re-runs it
whenever the dependencies are changed.watchEffect()
Type
Details
The first argument is the effect function to be run. The effect function receives a function
that can be used to register a cleanup callback. The cleanup callback will be called right
before the next time the effect is re-run, and can be used to clean up invalidated side
effects, e.g. a pending async request (see example below).
The second argument is an optional options object that can be used to adjust the effect's
flush timing or to debug the effect's dependencies.
By default, watchers will run just prior to component rendering. Setting flush: 'post'
will defer the watcher until after component rendering. See Callback Flush Timing for
more information. In rare cases, it might be necessary to trigger a watcher immediately
when a reactive dependency changes, e.g. to invalidate a cache. This can be achieved
using flush: 'sync'. However, this setting should be used with caution, as it can leadfunction watchEffect(
  effect: (onCleanup: OnCleanup) => void,
  options?: WatchEffectOptions
): StopHandle
type OnCleanup = (cleanupFn: () => void) => void
interface WatchEffectOptions {
  flush?: 'pre' | 'post' | 'sync' // default: 'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}
type StopHandle = () => voidto problems with performance and data consistency if multiple properties are being
updated at the same time.
The return value is a handle function that can be called to stop the effect from running
again.
Example
Side effect cleanup:
Stopping the watcher:
Options:const count = ref(0)
watchEffect(() => console.log(count.value))
// -> logs 0
count.value++
// -> logs 1
watchEffect(async (onCleanup) => {
  const { response, cancel } = doAsyncWork(id.value)
  // `cancel` will be called if `id` changes
  // so that previous pending request will be cancelled
  // if not yet completed
  onCleanup(cancel)
  data.value = await response
})
const stop = watchEffect(() => {})
// when the watcher is no longer needed:
stop()Alias of watchEffect() with flush: 'post' option.
Alias of watchEffect() with flush: 'sync' option.
Watches one or more reactive data sources and invokes a callback function when the
sources change.See also:
Guide - Watchers
Guide - Watcher Debugging
watchPostEffect()
watchSyncEffect()
watch()
TypewatchEffect(() => {}, {
  flush: 'post',
  onTrack(e) {
    debugger
  },
  onTrigger(e) {
    debugger
  }
})Types are simplified for readability.
Details
watch() is lazy by default - i.e. the callback is only called when the watched source has
changed.
The first argument is the watcher's source. The source can be one of the following:
A getter function that returns a value// watching single source
function watch<T>(
  source: WatchSource<T>,
  callback: WatchCallback<T>,
  options?: WatchOptions
): StopHandle
// watching multiple sources
function watch<T>(
  sources: WatchSource<T>[],
  callback: WatchCallback<T[]>,
  options?: WatchOptions
): StopHandle
type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void
type WatchSource<T> =
  | Ref<T> // ref
  | (() => T) // getter
  | T extends object
  ? T
  : never // reactive object
interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // default: false
  deep?: boolean // default: false
  flush?: 'pre' | 'post' | 'sync' // default: 'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}The second argument is the callback that will be called when the source changes. The
callback receives three arguments: the new value, the old value, and a function for
registering a side effect cleanup callback. The cleanup callback will be called right before
the next time the effect is re-run, and can be used to clean up invalidated side effects,
e.g. a pending async request.
When watching multiple sources, the callback receives two arrays containing new / old
values corresponding to the source array.
The third optional argument is an options object that supports the following options:
Compared to watchEffect(), watch() allows us to:A ref
A reactive object
...or an array of the above.
immediate: trigger the callback immediately on watcher creation. Old value will be
undefined on the first call.
deep: force deep traversal of the source if it is an object, so that the callback fires on
deep mutations. See Deep Watchers.
flush: adjust the callback's flush timing. See Callback Flush Timing and
watchEffect().
onTrack / onTrigger: debug the watcher's dependencies. See Watcher
Debugging.
Perform the side effect lazily;
Be more specific about what state should trigger the watcher to re-run;
Access both the previous and current value of the watched state.
Example
Watching a getter:Watching a ref:
When watching multiple sources, the callback receives arrays containing new / old values
corresponding to the source array:
When using a getter source, the watcher only fires if the getter's return value has
changed. If you want the callback to fire even on deep mutations, you need to explicitly
force the watcher into deep mode with { deep: true }. Note in deep mode, the new
value and the old will be the same object if the callback was triggered by a deep
mutation:const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
  /* ... */
})
const state = reactive({ count: 0 })
watch(
  () => state,
  (newValue, oldValue) => {
    // newValue === oldValue
  },
  { deep: true }
)When directly watching a reactive object, the watcher is automatically in deep mode:
watch() shares the same flush timing and debugging options with watchEffect():
Stopping the watcher:
Side effect cleanup:
See also:
Guide - Watchersconst state = reactive({ count: 0 })
watch(state, () => {
  /* triggers on deep mutation to state */
})
watch(source, callback, {
  flush: 'post',
  onTrack(e) {
    debugger
  },
  onTrigger(e) {
    debugger
  }
})
const stop = watch(source, callback)
// when the watcher is no longer needed:
stop()
watch(id, async (newId, oldId, onCleanup) => {
  const { response, cancel } = doAsyncWork(newId)
  // `cancel` will be called if `id` changes, cancelling
  // the previous request if it hasn't completed yet
  onCleanup(cancel)
  data.value = await response
})Guide - Watcher DebuggingChecks if a value is a ref object.
Returns the inner value if the argument is a ref, otherwise return the argument itself. This is a
sugar function for val = isRef(val) ? val.value : val.Reactivity API: Utilities
isRef()
Type
Note the return type is a type predicate, which means isRef can be used as a type
guard:
unref()
Type
Examplefunction isRef<T>(r: Ref<T> | unknown): r is Ref<T>
let foo: unknown
if (isRef(foo)) {
  // foo's type is narrowed to Ref<unknown>
  foo.value
}
function unref<T>(ref: T | Ref<T>): TCan be used to create a ref for a property on a source reactive object. The created ref is
synced with its source property: mutating the source property will update the ref, and vice-
versa.toRef()
Type
Examplefunction useFoo(x: number | Ref<number>) {
  const unwrapped = unref(x)
  // unwrapped is guaranteed to be number now
}
function toRef<T extends object, K extends keyof T>(
  object: T,
  key: K,
  defaultValue?: T[K]
): ToRef<T[K]>
type ToRef<T> = T extends Ref ? T : Ref<T>
const state = reactive({
  foo: 1,
  bar: 2
})
const fooRef = toRef(state, 'foo')
// mutating the ref updates the original
fooRef.value++
console.log(state.foo) // 2
// mutating the original also updates the ref
state.foo++
console.log(fooRef.value) // 3Converts a reactive object to a plain object where each property of the resulting object is a
ref pointing to the corresponding property of the original object. Each individual ref is
created using toRef().Note this is different from:
The above ref is not synced with state.foo, because the ref() receives a plain
number value.
toRef() is useful when you want to pass the ref of a prop to a composable function:
When toRef is used with component props, the usual restrictions around mutating the
props still apply. Attempting to assign a new value to the ref is equivalent to trying to
modify the prop directly and is not allowed. In that scenario you may want to consider
using computed with get and set instead. See the guide to using v-model with
components for more information.
toRef() will return a usable ref even if the source property doesn't currently exist. This
makes it possible to work with optional properties, which wouldn't be picked up by
toRefs.
toRefs()const fooRef = ref(state.foo)
<script setup>
import { toRef } from 'vue'
const props = defineProps(/* ... */)
// convert `props.foo` into a ref, then pass into
// a composable
useSomeFeature(toRef(props, 'foo'))
</script>vuType
Example
toRefs is useful when returning a reactive object from a composable function so that
the consuming component can destructure/spread the returned object without losing
reactivity:function toRefs<T extends object>(
  object: T
): {
  [K in keyof T]: ToRef<T[K]>
}
type ToRef = T extends Ref ? T : Ref<T>
const state = reactive({
  foo: 1,
  bar: 2
})
const stateAsRefs = toRefs(state)
/*
Type of stateAsRefs: {
  foo: Ref<number>,
  bar: Ref<number>
}
*/
// The ref and the original property is "linked"
state.foo++
console.log(stateAsRefs.foo.value) // 2
stateAsRefs.foo.value++
console.log(state.foo) // 3Checks if an object is a proxy created by reactive(), readonly(), shallowReactive()
or shallowReadonly().
Checks if an object is a proxy created by reactive() or shallowReactive().toRefs will only generate refs for properties that are enumerable on the source object
at call time. To create a ref for a property that may not exist yet, use toRef instead.
isProxy()
Type
isReactive()
Typefunction useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })
  // ...logic operating on state
  // convert to refs when returning
  return toRefs(state)
}
// can destructure without losing reactivity
const { foo, bar } = useFeatureX()
function isProxy(value: unknown): booleanChecks whether the passed value is a readonly object. The properties of a readonly object
can change, but they can't be assigned directly via the passed object.
The proxies created by readonly() and shallowReadonly() are both considered
readonly, as is a computed() ref without a set function.isReadonly()
Typefunction isReactive(value: unknown): boolean
function isReadonly(value: unknown): booleanShallow version of ref().Reactivity API: Advanced
shallowRef()
Type
Details
Unlike ref(), the inner value of a shallow ref is stored and exposed as-is, and will not
be made deeply reactive. Only the .value access is reactive.
shallowRef() is typically used for performance optimizations of large data structures,
or integration with external state management systems.
Example
See also:
Guide - Reduce Reactivity Overhead for Large Immutable Structures
Guide - Integration with External State Systemsfunction shallowRef<T>(value: T): ShallowRef<T>
interface ShallowRef<T> {
  value: T
}
const state = shallowRef({ count: 1 })
// does NOT trigger change
state.value.count = 2
// does trigger change
state.value = { count: 2 }Force trigger effects that depends on a shallow ref. This is typically used after making deep
mutations to the inner value of a shallow ref.
Creates a customized ref with explicit control over its dependency tracking and updates
triggering.triggerRef()
Type
Example
customRef()
Typefunction triggerRef(ref: ShallowRef): void
const shallow = shallowRef({
  greet: 'Hello, world'
})
// Logs "Hello, world" once for the first run-through
watchEffect(() => {
  console.log(shallow.value.greet)
})
// This won't trigger the effect because the ref is shallow
shallow.value.greet = 'Hello, universe'
// Logs "Hello, universe"
triggerRef(shallow)Details
customRef() expects a factory function, which receives track and trigger
functions as arguments and should return an object with get and set methods.
In general, track() should be called inside get(), and trigger() should be called
inside set(). However, you have full control over when they should be called, or
whether they should be called at all.
Example
Creating a debounced ref that only updates the value after a certain timeout after the
latest set call:function customRef<T>(factory: CustomRefFactory<T>): Ref<T>
type CustomRefFactory<T> = (
  track: () => void,
  trigger: () => void
) => {
  get: () => T
  set: (value: T) => void
}Shallow version of reactive().Usage in component:
Try it in the Playground ▶
shallowReactive()import { customRef } from 'vue'
export function useDebouncedRef(value, delay = 200) {
  let timeout
  return customRef((track, trigger) => {
    return {
      get() {
        track()
        return value
      },
      set(newValue) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          trigger()
        }, delay)
      }
    }
  })
}
<script setup>
import { useDebouncedRef } from './debouncedRef'
const text = useDebouncedRef('hello')
</script>
<template>
  <input v-model="text" />
</template>vuType
Details
Unlike reactive(), there is no deep conversion: only root-level properties are reactive
for a shallow reactive object. Property values are stored and exposed as-is - this also
means properties with ref values will not be automatically unwrapped.
Use with Caution
Shallow data structures should only be used for root level state in a component. Avoid
nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity
behavior which can be difficult to understand and debug.⚠
Example
shallowReadonly()function shallowReactive<T extends object>(target: T): T
const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2
  }
})
// mutating state's own properties is reactive
state.foo++
// ...but does not convert nested objects
isReactive(state.nested) // false
// NOT reactive
state.nested.bar++Shallow version of readonly().
Type
Details
Unlike readonly(), there is no deep conversion: only root-level properties are made
readonly. Property values are stored and exposed as-is - this also means properties with
ref values will not be automatically unwrapped.
Use with Caution
Shallow data structures should only be used for root level state in a component. Avoid
nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity
behavior which can be difficult to understand and debug.⚠
Examplefunction shallowReadonly<T extends object>(target: T): Readonly<T>
const state = shallowReadonly({
  foo: 1,
  nested: {
    bar: 2
  }
})
// mutating state's own properties will fail
state.foo++
// ...but works on nested objects
isReadonly(state.nested) // false
// works
state.nested.bar++Returns the raw, original object of a Vue-created proxy.
Marks an object so that it will never be converted to a proxy. Returns the object itself.toRaw()
Type
Details
toRaw() can return the original object from proxies created by reactive(),
readonly(), shallowReactive() or shallowReadonly().
This is an escape hatch that can be used to temporarily read without incurring proxy
access / tracking overhead or write without triggering changes. It is not recommended to
hold a persistent reference to the original object. Use with caution.
Example
markRaw()
Typefunction toRaw<T>(proxy: T): T
const foo = {}
const reactiveFoo = reactive(foo)
console.log(toRaw(reactiveFoo) === foo) // true
function markRaw<T extends object>(value: T): TExample
Use with Caution
markRaw() and shallow APIs such as shallowReactive() allow you to selectively
opt-out of the default deep reactive/readonly conversion and embed raw, non-proxied
objects in your state graph. They can be used for various reasons:
They are considered advanced because the raw opt-out is only at the root level, so if
you set a nested, non-marked raw object into a reactive object and then access it
again, you get the proxied version back. This can lead to identity hazards - i.e.
performing an operation that relies on object identity but using both the raw and the
proxied version of the same object:
Identity hazards are in general rare. However, to properly utilize these APIs while safely
avoiding identity hazards requires a solid understanding of how the reactivity system
works.⚠
Some values simply should not be made reactive, for example a complex 3rd party
class instance, or a Vue component object.
Skipping proxy conversion can provide performance improvements when rendering
large lists with immutable data sources.const foo = markRaw({})
console.log(isReactive(reactive(foo))) // false
// also works when nested inside other reactive objects
const bar = reactive({ foo })
console.log(isReactive(bar.foo)) // false
const foo = markRaw({
  nested: {}
})
const bar = reactive({
  // although `foo` is marked as raw, foo.nested is not.
  nested: foo.nested
})
console.log(foo.nested === bar.nested) // falsejsCreates an effect scope object which can capture the reactive effects (i.e. computed and
watchers) created within it so that these effects can be disposed together. For detailed use
cases of this API, please consult its corresponding RFC.
Returns the current active effect scope if there is one.effectScope()
Type
Example
getCurrentScope()
Typefunction effectScope(detached?: boolean): EffectScope
interface EffectScope {
  run<T>(fn: () => T): T | undefined // undefined if scope is inactive
  stop(): void
}
const scope = effectScope()
scope.run(() => {
  const doubled = computed(() => counter.value * 2)
  watch(doubled, () => console.log(doubled.value))
  watchEffect(() => console.log('Count: ', doubled.value))
})
// to dispose all effects in the scope
scope.stop()Registers a dispose callback on the current active effect scope. The callback will be
invoked when the associated effect scope is stopped.
This method can be used as a non-component-coupled replacement of onUnmounted in
reusable composition functions, since each Vue component's setup() function is also
invoked in an effect scope.onScopeDispose()
Typefunction getCurrentScope(): EffectScope | undefined
function onScopeDispose(fn: () => void): voidRegisters a callback to be called after the component has been mounted.Composition API: Lifecycle Hooks
Usage Note
All APIs listed on this page must be called synchronously during the setup() phase of a
component. See Guide - Lifecycle Hooks for more details.ⓘ
onMounted()
Type
Details
A component is considered mounted after:
This hook is typically used for performing side effects that need access to the
component's rendered DOM, or for limiting DOM-related code to the client in a server-
rendered application.
This hook is not called during server-side rendering.All of its synchronous child components have been mounted (does not include async
components or components inside <Suspense> trees).
Its own DOM tree has been created and inserted into the parent container. Note it only
guarantees that the component's DOM tree is in-document if the application's root
container is also in-document.
Examplefunction onMounted(callback: () => void): voidRegisters a callback to be called after the component has updated its DOM tree due to a
reactive state change.Accessing an element via template ref:
onUpdated()
Type
Details
A parent component's updated hook is called after that of its child components.
This hook is called after any DOM update of the component, which can be caused by
different state changes. If you need to access the updated DOM after a specific state
change, use nextTick() instead.
This hook is not called during server-side rendering.<script setup>
import { ref, onMounted } from 'vue'
const el = ref()
onMounted(() => {
  el.value // <div>
})
</script>
<template>
  <div ref="el"></div>
</template>
function onUpdated(callback: () => void): voidvRegisters a callback to be called after the component has been unmounted.WARNING
Do not mutate component state in the updated hook - this will likely lead to an infinite
update loop!⚠
Example
Accessing updated DOM:
onUnmounted()
Type
Details
A component is considered unmounted after:
All of its child components have been unmounted.<script setup>
import { ref, onUpdated } from 'vue'
const count = ref(0)
onUpdated(() => {
  // text content should be the same as current `count.value`
  console.log(document.getElementById('count').textContent)
})
</script>
<template>
  <button id="count" @click="count++">{{ count }}</button>
</template>
function onUnmounted(callback: () => void): voidvRegisters a hook to be called right before the component is to be mounted.Use this hook to clean up manually created side effects such as timers, DOM event
listeners or server connections.
This hook is not called during server-side rendering.All of its associated reactive effects (render effect and computed / watchers created
during setup()) have been stopped.
Example
onBeforeMount()
Type
Details
When this hook is called, the component has finished setting up its reactive state, but no
DOM nodes have been created yet. It is about to execute its DOM render effect for the
first time.<script setup>
import { onMounted, onUnmounted } from 'vue'
let intervalId
onMounted(() => {
  intervalId = setInterval(() => {
    // ...
  })
})
onUnmounted(() => clearInterval(intervalId))
</script>
function onBeforeMount(callback: () => void): voidvRegisters a hook to be called right before the component is about to update its DOM tree
due to a reactive state change.
Registers a hook to be called right before a component instance is to be unmounted.This hook is not called during server-side rendering.
onBeforeUpdate()
Type
Details
This hook can be used to access the DOM state before Vue updates the DOM. It is also
safe to modify component state inside this hook.
This hook is not called during server-side rendering.
onBeforeUnmount()
Type
Details
When this hook is called, the component instance is still fully functional.
This hook is not called during server-side rendering.function onBeforeUpdate(callback: () => void): void
function onBeforeUnmount(callback: () => void): voidRegisters a hook to be called when an error propagating from a descendant component has
been captured.onErrorCaptured()
Type
Details
Errors can be captured from the following sources:
The hook receives three arguments: the error, the component instance that triggered the
error, and an information string specifying the error source type.
You can modify component state in errorCaptured() to display an error state to the
user. However, it is important that the error state should not render the original content
that caused the error; otherwise the component will be thrown into an infinite render loop.
The hook can return false to stop the error from propagating further. See error
propagation details below.Component renders
Event handlers
Lifecycle hooks
setup() function
Watchers
Custom directive hooks
Transition hooksfunction onErrorCaptured(callback: ErrorCapturedHook): void
type ErrorCapturedHook = (
  err: unknown,
  instance: ComponentPublicInstance | null,
  info: string
) => boolean | voidRegisters a debug hook to be called when a reactive dependency has been tracked by the
component's render effect.
This hook is development-mode-only and not called during server-side rendering.Error Propagation Rules
By default, all errors are still sent to the application-level app.config.errorHandler
if it is defined, so that these errors can still be reported to an analytics service in a
single place.
If multiple errorCaptured hooks exist on a component's inheritance chain or parent
chain, all of them will be invoked on the same error, in the order of bottom to top. This
is similar to the bubbling mechanism of native DOM events.
If the errorCaptured hook itself throws an error, both this error and the original
captured error are sent to app.config.errorHandler.
An errorCaptured hook can return false to prevent the error from propagating
further. This is essentially saying "this error has been handled and should be ignored."
It will prevent any additional errorCaptured hooks or app.config.errorHandler
from being invoked for this error.
onRenderTracked() Dev only
Type
function onRenderTracked(callback: DebuggerHook): void
type DebuggerHook = (e: DebuggerEvent) => void
type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type: TrackOpTypes /* 'get' | 'has' | 'iterate' */
  key: any
}Registers a debug hook to be called when a reactive dependency triggers the component's
render effect to be re-run.
This hook is development-mode-only and not called during server-side rendering.
Registers a callback to be called after the component instance is inserted into the DOM as
part of a tree cached by <KeepAlive>.
This hook is not called during server-side rendering.See also:Reactivity in Depth
onRenderTriggered() Dev only
Type
See also:Reactivity in Depth
onActivated()function onRenderTriggered(callback: DebuggerHook): void
type DebuggerHook = (e: DebuggerEvent) => void
type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */
  key: any
  newValue?: any
  oldValue?: any
  oldTarget?: Map<any, any> | Set<any>
}Registers a callback to be called after the component instance is removed from the DOM as
part of a tree cached by <KeepAlive>.
This hook is not called during server-side rendering.
Registers an async function to be resolved before the component instance is to be rendered
on the server.Type
See also:Guide - Lifecycle of Cached Instance
onDeactivated()
Type
See also:Guide - Lifecycle of Cached Instance
onServerPrefetch() SSR only
Type
Detailsfunction onActivated(callback: () => void): void
function onDeactivated(callback: () => void): void
function onServerPrefetch(callback: () => Promise<any>): voidIf the callback returns a Promise, the server renderer will wait until the Promise is resolved
before rendering the component.
This hook is only called during server-side rendering can be used to perform server-only
data fetching.
Example
See also:Server-Side Rendering<script setup>
import { ref, onServerPrefetch, onMounted } from 'vue'
const data = ref(null)
onServerPrefetch(async () => {
  // component is rendered as part of the initial request
  // pre-fetch data on server as it is faster than on the client
  data.value = await fetchOnServer(/* ... */)
})
onMounted(async () => {
  if (!data.value) {
    // if data is null on mount, it means the component
    // is dynamically rendered on the client. Perform a
    // client-side fetch instead.
    data.value = await fetchOnClient(/* ... */)
  }
})
</script>vProvides a value that can be injected by descendant components.Composition API:
Dependency Injection
provide()
Type
Details
provide() takes two arguments: the key, which can be a string or a symbol, and the
value to be injected.
When using TypeScript, the key can be a symbol casted as InjectionKey - a Vue
provided utility type that extends Symbol, which can be used to sync the value type
between provide() and inject().
Similar to lifecycle hook registration APIs, provide() must be called synchronously
during a component's setup() phase.
Examplefunction provide<T>(key: InjectionKey<T> | string, value: T): voidInjects a value provided by an ancestor component or the application (via app.provide()).See also:
Guide - Provide / Inject
Guide - Typing Provide / InjectTS
inject()
Type<script setup>
import { ref, provide } from 'vue'
import { fooSymbol } from './injectionSymbols'
// provide static value
provide('foo', 'bar')
// provide reactive value
const count = ref(0)
provide('count', count)
// provide with Symbol keys
provide(fooSymbol, count)
</script>
// without default value
function inject<T>(key: InjectionKey<T> | string): T | undefined
// with default value
function inject<T>(key: InjectionKey<T> | string, defaultValue: T): T
// with factory
function inject<T>(
  key: InjectionKey<T> | string,
  defaultValue: () => T,
  treatDefaultAsFactory: true
): TvDetails
The first argument is the injection key. Vue will walk up the parent chain to locate a
provided value with a matching key. If multiple components in the parent chain provides
the same key, the one closest to the injecting component will "shadow" those higher up
the chain. If no value with matching key was found, inject() returns undefined
unless a default value is provided.
The second argument is optional and is the default value to be used when no matching
value was found. It can also be a factory function to return values that are expensive to
create. If the default value is a function, then false must be passed as the third
argument to indicate that the function should be used as the value instead of the factory.
Similar to lifecycle hook registration APIs, inject() must be called synchronously
during a component's setup() phase.
When using TypeScript, the key can be of type of InjectionKey - a Vue-provided utility
type that extends Symbol, which can be used to sync the value type between
provide() and inject().
Example
Assuming a parent component has provided values as shown in the previous provide()
example:See also:
Guide - Provide / Inject
Guide - Typing Provide / InjectTS<script setup>
import { inject } from 'vue'
import { fooSymbol } from './injectionSymbols'
// inject static value with default
const foo = inject('foo')
// inject reactive value
const count = inject('count')
// inject with Symbol keys
const foo2 = inject(fooSymbol)
// inject with default value
const bar = inject('foo', 'default value')
// inject with default value factory
const baz = inject('foo', () => new Map())
// inject with function default value, by passing the 3rd argument
const fn = inject('function', () => {}, false)
</script>vA function that returns the initial reactive state for the component instance.Options: State
data
Type
Details
The function is expected to return a plain JavaScript object, which will be made reactive
by Vue. After the instance is created, the reactive data object can be accessed as
this.$data. The component instance also proxies all the properties found on the data
object, so this.a will be equivalent to this.$data.a.
All top-level data properties must be included in the returned data object. Adding new
properties to this.$data is possible, but it is not recommended. If the desired value of
a property is not yet available then an empty value such as undefined or null should
be included as a placeholder to ensure that Vue knows that the property exists.
Properties that start with _ or $ will not be proxied on the component instance
because they may conflict with Vue's internal properties and API methods. You will have
to access them as this.$data._property.
It is not recommended to return objects with their own stateful behavior like browser API
objects and prototype properties. The returned object should ideally be a plain object
that only represents the state of the component.
Exampleinterface ComponentOptions {
  data?(
    this: ComponentPublicInstance,
    vm: ComponentPublicInstance
  ): object
}Declare the props of a component.Note that if you use an arrow function with the data property, this won't be the
component's instance, but you can still access the instance as the function's first
argument:
See also:Reactivity in Depth
props
Typeexport default {
  data() {
    return { a: 1 }
  },
  created() {
    console.log(this.a) // 1
    console.log(this.$data) // { a: 1 }
  }
}
data: (vm) => ({ a: vm.myProp })Types are simplified for readability.
Details
In Vue, all component props need to be explicitly declared. Component props can be
declared in two forms:
With object-based syntax, each prop can further define the following options:Simple form using an array of strings
Full form using an object where each property key is the name of the prop, and the
value is the prop's type (a constructor function) or advanced options.
type: Can be one of the following native constructors: String, Number, Boolean,
Array, Object, Date, Function, Symbol, any custom constructor function or
an array of those. In development mode, Vue will check if a prop's value matches the
declared type, and will throw a warning if it doesn't. See Prop Validation for more
details.
Also note that a prop with Boolean type affects its value casting behavior in both
development and production. See Boolean Casting for more details.interface ComponentOptions {
  props?: ArrayPropsOptions | ObjectPropsOptions
}
type ArrayPropsOptions = string[]
type ObjectPropsOptions = { [key: string]: Prop }
type Prop<T = any> = PropOptions<T> | PropType<T> | null
interface PropOptions<T> {
  type?: PropType<T>
  required?: boolean
  default?: T | ((rawProps: object) => T)
  validator?: (value: unknown) => boolean
}
type PropType<T> = { new (): T } | { new (): T }[]default: Specifies a default value for the prop when it is not passed by the parent or
has undefined value. Object or array defaults must be returned using a factory
function. The factory function also receives the raw props object as the argument.
required: Defines if the prop is required. In a non-production environment, a console
warning will be thrown if this value is truthy and the prop is not passed.
validator: Custom validator function that takes the prop value as the sole argument.
In development mode, a console warning will be thrown if this function returns a falsy
value (i.e. the validation fails).
Example
Simple declaration:
Object declaration with validations:
See also:
Guide - Props
Guide - Typing Component PropsTSexport default {
  props: ['size', 'myMessage']
}
export default {
  props: {
    // type check
    height: Number,
    // type check plus other validations
    age: {
      type: Number,
      default: 0,
      required: true,
      validator: (value) => {
        return value >= 0
      }
    }
  }
}Declare computed properties to be exposed on the component instance.computed
Type
Details
The option accepts an object where the key is the name of the computed property, and
the value is either a computed getter, or an object with get and set methods (for
writable computed properties).
All getters and setters have their this context automatically bound to the component
instance.
Note that if you use an arrow function with a computed property, this won't point to the
component's instance, but you can still access the instance as the function's first
argument:interface ComponentOptions {
  computed?: {
    [key: string]: ComputedGetter<any> | WritableComputedOptions<any>
  }
}
type ComputedGetter<T> = (
  this: ComponentPublicInstance,
  vm: ComponentPublicInstance
) => T
type ComputedSetter<T> = (
  this: ComponentPublicInstance,
  value: T
) => void
type WritableComputedOptions<T> = {
  get: ComputedGetter<T>
  set: ComputedSetter<T>
}Example
See also:
Guide - Computed Properties
Guide - Typing Computed PropertiesTSexport default {
  computed: {
    aDouble: (vm) => vm.a * 2
  }
}
export default {
  data() {
    return { a: 1 }
  },
  computed: {
    // readonly
    aDouble() {
      return this.a * 2
    },
    // writable
    aPlus: {
      get() {
        return this.a + 1
      },
      set(v) {
        this.a = v - 1
      }
    }
  },
  created() {
    console.log(this.aDouble) // => 2
    console.log(this.aPlus) // => 2
    this.aPlus = 3
    console.log(this.a) // => 2
    console.log(this.aDouble) // => 4
  }
}Declare methods to be mixed into the component instance.methods
Type
Details
Declared methods can be directly accessed on the component instance, or used in
template expressions. All methods have their this context automatically bound to the
component instance, even when passed around.
Avoid using arrow functions when declaring methods, as they will not have access to the
component instance via this.
Exampleinterface ComponentOptions {
  methods?: {
    [key: string]: (this: ComponentPublicInstance, ...args: any[]) => any
  }
}
export default {
  data() {
    return { a: 1 }
  },
  methods: {
    plus() {
      this.a++
    }
  },
  created() {
    this.plus()
    console.log(this.a) // => 2
  }
}Declare watch callbacks to be invoked on data change.See also:Event Handling
watch
Type
Types are simplified for readability.
Details
The watch option expects an object where keys are the reactive component instance
properties to watch (e.g. properties declared via data or computed) — and values are
the corresponding callbacks. The callback receives the new value and the old value of the
watched source.interface ComponentOptions {
  watch?: {
    [key: string]: WatchOptionItem | WatchOptionItem[]
  }
}
type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem
type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void
type ObjectWatchOptionItem = {
  handler: WatchCallback | string
  immediate?: boolean // default: false
  deep?: boolean // default: false
  flush?: 'pre' | 'post' | 'sync' // default: 'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}In addition to a root-level property, the key can also be a simple dot-delimited path, e.g.
a.b.c. Note that this usage does not support complex expressions - only dot-delimited
paths are supported. If you need to watch complex data sources, use the imperative
$watch() API instead.
The value can also be a string of a method name (declared via methods), or an object
that contains additional options. When using the object syntax, the callback should be
declared under the handler field. Additional options include:
Avoid using arrow functions when declaring watch callbacks as they will not have access
to the component instance via this.immediate: trigger the callback immediately on watcher creation. Old value will be
undefined on the first call.
deep: force deep traversal of the source if it is an object or an array, so that the
callback fires on deep mutations. See Deep Watchers.
flush: adjust the callback's flush timing. See Callback Flush Timing and
watchEffect().
onTrack / onTrigger: debug the watcher's dependencies. See Watcher
Debugging.
Exampleexport default {
  data() {
    return {
      a: 1,
      b: 2,
      c: {
        d: 4
      },
      e: 5,
      f: 6
    }
  },
  watch: {
    // watching top-level property
    a(val, oldVal) {
      console.log(`new: ${val}, old: ${oldVal}`)
    },
    // string method name
    b: 'someMethod',
    // the callback will be called whenever any of the watched object prope
    c: {
      handler(val, oldVal) {
        console.log('c changed')
      },
      deep: true
    },
    // watching a single nested property:
    'c.d': function (val, oldVal) {
      // do something
    },
    // the callback will be called immediately after the start of the obser
    e: {
      handler(val, oldVal) {
        console.log('e changed')
      },
      immediate: true
    },
    // you can pass array of callbacks, they will be called one-by-one
    f: [
      'handle1',
      function handle2(val, oldVal) {
        console.log('handle2 triggered')
      },
      {
        handler: function handle3(val, oldVal) {
          console.log('handle3 triggered')
        }Declare the custom events emitted by the component.See also:Watchers
emits
Type
Details
Emitted events can be declared in two forms:
Simple form using an array of strings        /* ... */
      }
    ]
  },
  methods: {
    someMethod() {
      console.log('b changed')
    },
    handle1() {
      console.log('handle 1 triggered')
    }
  },
  created() {
    this.a = 3 // => new: 3, old: 1
  }
}
interface ComponentOptions {
  emits?: ArrayEmitsOptions | ObjectEmitsOptions
}
type ArrayEmitsOptions = string[]
type ObjectEmitsOptions = { [key: string]: EmitValidator | null }
type EmitValidator = (...args: unknown[]) => booleanThe validation function will receive the additional arguments passed to the component's
$emit call. For example, if this.$emit('foo', 1) is called, the corresponding
validator for foo will receive the argument 1. The validator function should return a
boolean to indicate whether the event arguments are valid.
Note that the emits option affects which event listeners are considered component
event listeners, rather than native DOM event listeners. The listeners for declared events
will be removed from the component's $attrs object, so they will not be passed
through to the component's root element. See Fallthrough Attributes for more details.Full form using an object where each property key is the name of the event, and the
value is either null or a validator function.
Example
Array syntax:
Object syntax:export default {
  emits: ['check'],
  created() {
    this.$emit('check')
  }
}Declare exposed public properties when the component instance is accessed by a parent via
template refs.See also:
Guide - Fallthrough Attributes
Guide - Typing Component EmitsTS
expose
Type
Details
By default, a component instance exposes all instance properties to the parent when
accessed via $parent, $root, or template refs. This can be undesirable, since aexport default {
  emits: {
    // no validation
    click: null,
    // with validation
    submit: (payload) => {
      if (payload.email && payload.password) {
        return true
      } else {
        console.warn(`Invalid submit event payload!`)
        return false
      }
    }
  }
}
interface ComponentOptions {
  expose?: string[]
}component most likely has internal state or methods that should be kept private to avoid
tight coupling.
The expose option expects a list of property name strings. When expose is used, only
the properties explicitly listed will be exposed on the component's public instance.
expose only affects user-defined properties - it does not filter out built-in component
instance properties.
Example
export default {
  // only `publicMethod` will be available on the public instance
  expose: ['publicMethod'],
  methods: {
    publicMethod() {
      // ...
    },
    privateMethod() {
      // ...
    }
  }
}A string template for the component.Options: Rendering
template
Type
Details
A template provided via the template option will be compiled on-the-fly at runtime. It is
only supported when using a build of Vue that includes the template compiler. The
template compiler is NOT included in Vue builds that have the word runtime in their
names, e.g. vue.runtime.esm-bundler.js. Consult the dist file guide for more details
about the different builds.
If the string starts with # it will be used as a querySelector and use the selected
element's innerHTML as the template string. This allows the source template to be
authored using native <template> elements.
If the render option is also present in the same component, template will be ignored.
If the root component of your application doesn't have a template or render option
specified, Vue will try to use the innerHTML of the mounted element as the template
instead.
Security Note
Only use template sources that you can trust. Do not use user-provided content as
your template. See Security Guide for more details.⚠interface ComponentOptions {
  template?: string
}A function that programmatically returns the virtual DOM tree of the component.render
Type
Details:
render is an alternative to string templates that allows you to leverage the full
programmatic power of JavaScript to declare the render output of the component.
Pre-compiled templates, for example those in Single-File Components, are compiled into
the render option at build time. If both render and template are present in a
component, render will take higher priority.
See also:
Rendering Mechanism
Render Functionsinterface ComponentOptions {
  render?(this: ComponentPublicInstance) => VNodeChild
}
type VNodeChild = VNodeChildAtom | VNodeArrayChildren
type VNodeChildAtom =
  | VNode
  | string
  | number
  | boolean
  | null
  | undefined
  | void
type VNodeArrayChildren = (VNodeArrayChildren | VNodeChildAtom)[]Configure runtime compiler options for the component's template.compilerOptions
Type
Details
This config option is only respected when using the full build (i.e. the standalone vue.js
that can compile templates in the browser). It supports the same options as the app-level
app.config.compilerOptions, and has higher priority for the current component.
See also:app.config.compilerOptionsinterface ComponentOptions {
  compilerOptions?: {
    isCustomElement?: (tag: string) => boolean
    whitespace?: 'condense' | 'preserve' // default: 'condense'
    delimiters?: [string, string] // default: ['{{', '}}']
    comments?: boolean // default: false
  }
}Called when the instance is initialized.
Called after the instance has finished processing all state-related options.Options: Lifecycle
See also
For shared usage of lifecycle hooks, see Guide - Lifecycle Hooksⓘ
beforeCreate
Type
Details
Called immediately when the instance is initialized, after props resolution, before
processing other options such as data() or computed.
Note that the setup() hook of Composition API is called before any Options API hooks,
even beforeCreate().
created
Typeinterface ComponentOptions {
  beforeCreate?(this: ComponentPublicInstance): void
}Called right before the component is to be mounted.
Called after the component has been mounted.Details
When this hooks is called, the following have been set up: reactive data, computed
properties, methods, and watchers. However, the mounting phase has not been started,
and the $el property will not be available yet.
beforeMount
Type
Details
When this hook is called, the component has finished setting up its reactive state, but no
DOM nodes have been created yet. It is about to execute its DOM render effect for the
first time.
This hook is not called during server-side rendering.
mounted
Typeinterface ComponentOptions {
  created?(this: ComponentPublicInstance): void
}
interface ComponentOptions {
  beforeMount?(this: ComponentPublicInstance): void
}Called right before the component is about to update its DOM tree due to a reactive state
change.Details
A component is considered mounted after:
This hook is typically used for performing side effects that need access to the
component's rendered DOM, or for limiting DOM-related code to the client in a server-
rendered application.
This hook is not called during server-side rendering.All of its synchronous child components have been mounted (does not include async
components or components inside <Suspense> trees).
Its own DOM tree has been created and inserted into the parent container. Note it only
guarantees that the component's DOM tree is in-document if the application's root
container is also in-document.
beforeUpdate
Type
Details
This hook can be used to access the DOM state before Vue updates the DOM. It is also
safe to modify component state inside this hook.interface ComponentOptions {
  mounted?(this: ComponentPublicInstance): void
}
interface ComponentOptions {
  beforeUpdate?(this: ComponentPublicInstance): void
}Called after the component has updated its DOM tree due to a reactive state change.
Called right before a component instance is to be unmounted.This hook is not called during server-side rendering.
updated
Type
Details
A parent component's updated hook is called after that of its child components.
This hook is called after any DOM update of the component, which can be caused by
different state changes. If you need to access the updated DOM after a specific state
change, use nextTick() instead.
This hook is not called during server-side rendering.
WARNING
Do not mutate component state in the updated hook - this will likely lead to an infinite
update loop!⚠
beforeUnmount
Typeinterface ComponentOptions {
  updated?(this: ComponentPublicInstance): void
}Called after the component has been unmounted.Details
When this hook is called, the component instance is still fully functional.
This hook is not called during server-side rendering.
unmounted
Type
Details
A component is considered unmounted after:
Use this hook to clean up manually created side effects such as timers, DOM event
listeners or server connections.
This hook is not called during server-side rendering.All of its child components have been unmounted.
All of its associated reactive effects (render effect and computed / watchers created
during setup()) have been stopped.interface ComponentOptions {
  beforeUnmount?(this: ComponentPublicInstance): void
}
interface ComponentOptions {
  unmounted?(this: ComponentPublicInstance): void
}Called when an error propagating from a descendant component has been captured.errorCaptured
Type
Details
Errors can be captured from the following sources:
The hook receives three arguments: the error, the component instance that triggered the
error, and an information string specifying the error source type.
You can modify component state in errorCaptured() to display an error state to the
user. However, it is important that the error state should not render the original content
that caused the error; otherwise the component will be thrown into an infinite render loop.
The hook can return false to stop the error from propagating further. See error
propagation details below.
Error Propagation RulesComponent renders
Event handlers
Lifecycle hooks
setup() function
Watchers
Custom directive hooks
Transition hooksinterface ComponentOptions {
  errorCaptured?(
    this: ComponentPublicInstance,
    err: unknown,
    instance: ComponentPublicInstance | null,
    info: string
  ): boolean | void
}Called when a reactive dependency has been tracked by the component's render effect.
This hook is development-mode-only and not called during server-side rendering.By default, all errors are still sent to the application-level app.config.errorHandler
if it is defined, so that these errors can still be reported to an analytics service in a
single place.
If multiple errorCaptured hooks exist on a component's inheritance chain or parent
chain, all of them will be invoked on the same error, in the order of bottom to top. This
is similar to the bubbling mechanism of native DOM events.
If the errorCaptured hook itself throws an error, both this error and the original
captured error are sent to app.config.errorHandler.
An errorCaptured hook can return false to prevent the error from propagating
further. This is essentially saying "this error has been handled and should be ignored."
It will prevent any additional errorCaptured hooks or app.config.errorHandler
from being invoked for this error.
renderTracked Dev only
Type
See also:Reactivity in Depthinterface ComponentOptions {
  renderTracked?(this: ComponentPublicInstance, e: DebuggerEvent): void
}
type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type: TrackOpTypes /* 'get' | 'has' | 'iterate' */
  key: any
}Called when a reactive dependency triggers the component's render effect to be re-run.
This hook is development-mode-only and not called during server-side rendering.
Called after the component instance is inserted into the DOM as part of a tree cached by
<KeepAlive>.
This hook is not called during server-side rendering.renderTriggered Dev only
Type
See also:Reactivity in Depth
activated
Typeinterface ComponentOptions {
  renderTriggered?(this: ComponentPublicInstance, e: DebuggerEvent): void
}
type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */
  key: any
  newValue?: any
  oldValue?: any
  oldTarget?: Map<any, any> | Set<any>
}Called after the component instance is removed from the DOM as part of a tree cached by
<KeepAlive>.
This hook is not called during server-side rendering.
Async function to be resolved before the component instance is to be rendered on the
server.See also:Guide - Lifecycle of Cached Instance
deactivated
Type
See also:Guide - Lifecycle of Cached Instance
serverPrefetch SSR only
Typeinterface ComponentOptions {
  activated?(this: ComponentPublicInstance): void
}
interface ComponentOptions {
  deactivated?(this: ComponentPublicInstance): void
}
interface ComponentOptions {
  serverPrefetch?(this: ComponentPublicInstance): Promise<any>
}Details
If the hook returns a Promise, the server renderer will wait until the Promise is resolved
before rendering the component.
This hook is only called during server-side rendering can be used to perform server-only
data fetching.
Example
See also:Server-Side Renderingexport default {
  data() {
    return {
      data: null
    }
  },
  async serverPrefetch() {
    // component is rendered as part of the initial request
    // pre-fetch data on server as it is faster than on the client
    this.data = await fetchOnServer(/* ... */)
  },
  async mounted() {
    if (!this.data) {
      // if data is null on mount, it means the component
      // is dynamically rendered on the client. Perform a
      // client-side fetch instead.
      this.data = await fetchOnClient(/* ... */)
    }
  }
}Provide values that can be injected by descendant components.Options: Composition
provide
Type
Details:
provide and inject are used together to allow an ancestor component to serve as a
dependency injector for all its descendants, regardless of how deep the component
hierarchy is, as long as they are in the same parent chain.
The provide option should be either an object or a function that returns an object. This
object contains the properties that are available for injection into its descendants. You
can use Symbols as keys in this object.
Example
Basic usage:
Using a function to provide per-component state:interface ComponentOptions {
  provide?: object | ((this: ComponentPublicInstance) => object)
}
const s = Symbol()
export default {
  provide: {
    foo: 'foo',
    [s]: 'bar'
  }
}Declare properties to inject into the current component by locating them from ancestor
providers.Note in the above example, the provided msg will NOT be reactive. See Working with
Reactivity for more details.
See also:Provide / Inject
inject
Typeexport default {
  data() {
    return {
      msg: 'foo'
    }
  }
  provide() {
    return {
      msg: this.msg
    }
  }
}
interface ComponentOptions {
  inject?: ArrayInjectOptions | ObjectInjectOptions
}
type ArrayInjectOptions = string[]
type ObjectInjectOptions = {
  [key: string | symbol]:
    | string
    | symbol
    | { from?: string | symbol; default?: any }
}Details
The inject option should be either:
An injected property will be undefined if neither a matching property nor a default value
was provided.
Note that injected bindings are NOT reactive. This is intentional. However, if the injected
value is a reactive object, properties on that object do remain reactive. See Working with
Reactivity for more details.An array of strings, or
An object where the keys are the local binding name and the value is either:
The key (string or Symbol) to search for in available injections, or
An object where:
The from property is the key (string or Symbol) to search for in available
injections, and
The default property is used as fallback value. Similar to props default values,
a factory function is needed for object types to avoid value sharing between
multiple component instances.
Example
Basic usage:
Using an injected value as the default for a prop:export default {
  inject: ['foo'],
  created() {
    console.log(this.foo)
  }
}Using an injected value as data entry:
Injections can be optional with default value:
If it needs to be injected from a property with a different name, use from to denote the
source property:const Child = {
  inject: ['foo'],
  props: {
    bar: {
      default() {
        return this.foo
      }
    }
  }
}
const Child = {
  inject: ['foo'],
  data() {
    return {
      bar: this.foo
    }
  }
}
const Child = {
  inject: {
    foo: { default: 'foo' }
  }
}An array of option objects to be mixed into the current component.Similar to prop defaults, you need to use a factory function for non-primitive values:
See also:Provide / Inject
mixins
Type
Details:
The mixins option accepts an array of mixin objects. These mixin objects can contain
instance options like normal instance objects, and they will be merged against theconst Child = {
  inject: {
    foo: {
      from: 'bar',
      default: 'foo'
    }
  }
}
const Child = {
  inject: {
    foo: {
      from: 'bar',
      default: () => [1, 2, 3]
    }
  }
}
interface ComponentOptions {
  mixins?: ComponentOptions[]
}A "base class" component to extend from.eventual options using the certain option merging logic. For example, if your mixin
contains a created hook and the component itself also has one, both functions will be
called.
Mixin hooks are called in the order they are provided, and called before the component's
own hooks.
No Longer Recommended
In Vue 2, mixins were the primary mechanism for creating reusable chunks of
component logic. While mixins continue to be supported in Vue 3, Composition API is
now the preferred approach for code reuse between components.⚠
Example:
extends
Type:const mixin = {
  created() {
    console.log(1)
  }
}
createApp({
  created() {
    console.log(2)
  },
  mixins: [mixin]
})
// => 1
// => 2Details:
Allows one component to extend another, inheriting its component options.
From an implementation perspective, extends is almost identical to mixins. The
component specified by extends will be treated as though it were the first mixin.
However, extends and mixins express different intents. The mixins option is
primarily used to compose chunks of functionality, whereas extends is primarily
concerned with inheritance.
As with mixins, any options will be merged using the relevant merge strategy.
Example:interface ComponentOptions {
  extends?: ComponentOptions
}
const CompA = { ... }
const CompB = {
  extends: CompA,
  ...
}Explicitly declare a display name for the component.Options: Misc
name
Type
Details
The name of a component is used for the following:
When you use Single-File Components, the component already infers its own name from
the filename. For example, a file named MyComponent.vue will have the inferred display
name "MyComponent".
Another case is that when a component is registered globally with app.component, the
global ID is automatically set as its name.
The name option allows you to override the inferred name, or to explicitly provide a name
when no name can be inferred (e.g. when not using build tools, or an inlined non-SFC
component).
There is one case where name is explicitly necessary: when matching against cacheable
components in <KeepAlive> via its include / exclude props.Recursive self-reference in the component's own template
Display in Vue DevTools' component inspection tree
Display in warning component tracesinterface ComponentOptions {
  name?: string
}Controls whether the default component attribute fallthrough behavior should be enabled.TIP
Since version 3.2.34, a single-file component using <script setup> will
automatically infer its name option based on the filename, removing the need to
manually declare the name even when used with <KeepAlive>.ⓘ
inheritAttrs
Type
Details
By default, parent scope attribute bindings that are not recognized as props will
"fallthrough". This means that when we have a single-root component, these bindings will
be applied to the root element of the child component as normal HTML attributes. When
authoring a component that wraps a target element or another component, this may not
always be the desired behavior. By setting inheritAttrs to false, this default
behavior can be disabled. The attributes are available via the $attrs instance property
and can be explicitly bound to a non-root element using v-bind.
Example
When declaring this option in a component that uses <script setup>, a separate
<script> block is necessary:interface ComponentOptions {
  inheritAttrs?: boolean // default: true
}An object that registers components to be made available to the component instance.See also:Fallthrough Attributes
components
Type
Example<script>
export default {
  inheritAttrs: false
}
</script>
<script setup>
defineProps(['label', 'value'])
defineEmits(['input'])
</script>
<template>
  <label>
    {{ label }}
    <input
      v-bind="$attrs"
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    />
  </label>
</template>
interface ComponentOptions {
  components?: { [key: string]: Component }
}vuAn object that registers directives to be made available to the component instance.See also:Component Registration
directives
Type
Exampleimport Foo from './Foo.vue'
import Bar from './Bar.vue'
export default {
  components: {
    // shorthand
    Foo,
    // register under a different name
    RenamedBar: Bar
  }
}
interface ComponentOptions {
  directives?: { [key: string]: Directive }
}
export default {
  directives: {
    // enables v-focus in template
    focus: {
      mounted(el) {
        el.focus()
      }
    }
  }
}A hash of directives to be made available to the component instance.
See also:Custom Directives<input v-focus>templaThe object returned from the data option, made reactive by the component. The
component instance proxies access to the properties on its data object.
An object representing the component's current, resolved props.Component Instance
INFO
This page documents the built-in properties and methods exposed on the component
public instance, i.e. this.
All properties listed on this page are readonly (except nested properties in $data).ⓘ
$data
Type
$props
Typeinterface ComponentPublicInstance {
  $data: object
}
interface ComponentPublicInstance {
  $props: object
}The root DOM node that the component instance is managing.Details
Only props declared via the props option will be included. The component instance
proxies access to the properties on its props object.
$el
Type
Details
$el will be undefined until the component is mounted.
For components with a single root element, $el will point to that element.
For components with text root, $el will point to the text node.
For components with multiple root nodes, $el will be the placeholder DOM node that
Vue uses to keep track of the component's position in the DOM (a text node, or a
comment node in SSR hydration mode).
TIP
For consistency, it is recommended to use template refs for direct access to elements
instead of relying on $el.ⓘ
$optionsinterface ComponentPublicInstance {
  $el: Node | undefined
}The resolved component options used for instantiating the current component instance.
The parent instance, if the current instance has one. It will be null for the root instance
itself.Type
Details
The $options object exposes the resolved options for the current component and is the
merge result of these possible sources:
It is typically used to support custom component options:Global mixins
Component extends base
Component mixins
See also:app.config.optionMergeStrategies
$parent
Typeinterface ComponentPublicInstance {
  $options: ComponentOptions
}
const app = createApp({
  customOption: 'foo',
  created() {
    console.log(this.$options.customOption) // => 'foo'
  }
})The root component instance of the current component tree. If the current instance has no
parents this value will be itself.
An object representing the slots passed by the parent component.$root
Type
$slots
Type
Details
Typically used when manually authoring render functions, but can also be used to detect
whether a slot is present.interface ComponentPublicInstance {
  $parent: ComponentPublicInstance | null
}
interface ComponentPublicInstance {
  $root: ComponentPublicInstance
}
interface ComponentPublicInstance {
  $slots: { [name: string]: Slot }
}
type Slot = (...args: any[]) => VNode[]An object of DOM elements and component instances, registered via template refs.
An object that contains the component's fallthrough attributes.Each slot is exposed on this.$slots as a function that returns an array of vnodes
under the key corresponding to that slot's name. The default slot is exposed as
this.$slots.default.
If a slot is a scoped slot, arguments passed to the slot functions are available to the slot
as its slot props.
See also:Render Functions - Rendering Slots
$refs
Type
See also:
Template refs
Special Attributes - ref
$attrs
Typeinterface ComponentPublicInstance {
  $refs: { [name: string]: Element | ComponentPublicInstance | null }
}Imperative API for creating watchers.Details
Fallthrough Attributes are attributes and event handlers passed by the parent
component, but not declared as a prop or an emitted event by the child.
By default, everything in $attrs will be automatically inherited on the component's root
element if there is only a single root element. This behavior is disabled if the component
has multiple root nodes, and can be explicitly disabled with the inheritAttrs option.
See also:
Fallthrough Attributes
$watch()
Typeinterface ComponentPublicInstance {
  $attrs: object
}Details
The first argument is the watch source. It can be a component property name string, a
simple dot-delimited path string, or a getter function.
The second argument is the callback function. The callback receives the new value and
the old value of the watched source.
immediate: trigger the callback immediately on watcher creation. Old value will be
undefined on the first call.
deep: force deep traversal of the source if it is an object, so that the callback fires on
deep mutations. See Deep Watchers.
flush: adjust the callback's flush timing. See Callback Flush Timing and
watchEffect().
onTrack / onTrigger: debug the watcher's dependencies. See Watcher
Debugging.
Exampleinterface ComponentPublicInstance {
  $watch(
    source: string | (() => any),
    callback: WatchCallback,
    options?: WatchOptions
  ): StopHandle
}
type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void
interface WatchOptions {
  immediate?: boolean // default: false
  deep?: boolean // default: false
  flush?: 'pre' | 'post' | 'sync' // default: 'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}
type StopHandle = () => voidWatch a property name:
Watch a dot-delimited path:
Using getter for more complex expressions:
Stopping the watcher:
See also:
Options - watch
Guide - Watchers
$emit()this.$watch('a', (newVal, oldVal) => {})
this.$watch('a.b', (newVal, oldVal) => {})
this.$watch(
  // every time the expression `this.a + this.b` yields
  // a different result, the handler will be called.
  // It's as if we were watching a computed property
  // without defining the computed property itself.
  () => this.a + this.b,
  (newVal, oldVal) => {}
)
const unwatch = this.$watch('a', cb)
// later...
unwatch()Trigger a custom event on the current instance. Any additional arguments will be passed into
the listener's callback function.
Force the component instance to re-render.Type
Example
See also:
Component - Events
emits option
$forceUpdate()
Typeinterface ComponentPublicInstance {
  $emit(event: string, ...args: any[]): void
}
export default {
  created() {
    // only event
    this.$emit('foo')
    // with additional arguments
    this.$emit('bar', 1, 2, 3)
  }
}
interface ComponentPublicInstance {
  $forceUpdate(): void
}Instance-bound version of the global nextTick().Details
This should be rarely needed given Vue's fully automatic reactivity system. The only
cases where you may need it is when you have explicitly created non-reactive component
state using advanced reactivity APIs.
$nextTick()
Type
Details
The only difference from the global version of nextTick() is that the callback passed to
this.$nextTick() will have its this context bound to the current component
instance.
See also:nextTick()interface ComponentPublicInstance {
  $nextTick(callback?: (this: ComponentPublicInstance) => void): Promise<vo
}Update the element's text content.
Update the element's innerHTML.Built-in Directives
v-text
Expects:string
Details
v-text works by setting the element's textContent property, so it will overwrite any
existing content inside the element. If you need to update the part of textContent, you
should use mustache interpolations instead.
Example
See also:Template Syntax - Text Interpolation
v-html
Expects:string
Details:
Contents of v-html are inserted as plain HTML - Vue template syntax will not be
processed. If you find yourself trying to compose templates using v-html, try to rethink
the solution by using components instead.<span v-text="msg"></span>
<!-- same as -->
<span>{{msg}}</span>templaToggle the element's visibility based on the truthy-ness of the expression value.In Single-File Components, scoped styles will not apply to content inside v-html,
because that HTML is not processed by Vue's template compiler. If you want to target
v-html content with scoped CSS, you can instead use CSS modules or an additional,
global <style> element with a manual scoping strategy such as BEM.Security Note
Dynamically rendering arbitrary HTML on your website can be very dangerous
because it can easily lead to XSS attacks. Only use v-html on trusted content and
never on user-provided content.⚠
Example:
See also:Template Syntax - Raw HTML
v-show
Expects:any
Details
v-show works by setting the display CSS property via inline styles, and will try to
respect the initial display value when the element is visible. It also triggers transitions
when its condition changes.
See also:Conditional Rendering - v-show
v-if<div v-html="html"></div>templaConditionally render an element or a template fragment based on the truthy-ness of the
expression value.
Denote the "else block" for v-if or a v-if / v-else-if chain.Expects:any
Details
When a v-if element is toggled, the element and its contained directives / components
are destroyed and re-constructed. If the initial condition is falsy, then the inner content
won't be rendered at all.
Can be used on <template> to denote a conditional block containing only text or
multiple elements.
This directive triggers transitions when its condition changes.
When used together, v-if has a higher priority than v-for. We don't recommend
using these two directives together on one element — see the list rendering guide for
details.
See also:Conditional Rendering - v-if
v-else
Does not expect expression
Details
Restriction: previous sibling element must have v-if or v-else-if.
Can be used on <template> to denote a conditional block containing only text or
multiple elements.
ExampleDenote the "else if block" for v-if. Can be chained.See also:Conditional Rendering - v-else
v-else-if
Expects:any
Details
Restriction: previous sibling element must have v-if or v-else-if.
Can be used on <template> to denote a conditional block containing only text or
multiple elements.
Example
See also:Conditional Rendering - v-else-if<div v-if="Math.random() > 0.5">
  Now you see me
</div>
<div v-else>
  Now you don't
</div>
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>templa
templaRender the element or template block multiple times based on the source data.v-for
Expects:Array | Object | number | string | Iterable
Details
The directive's value must use the special syntax alias in expression to provide an
alias for the current element being iterated on:
Alternatively, you can also specify an alias for the index (or the key if used on an Object):
The default behavior of v-for will try to patch the elements in-place without moving
them. To force it to reorder elements, you should provide an ordering hint with the key
special attribute:
v-for can also work on values that implement the Iterable Protocol, including native
Map and Set.
See also:
List Rendering<div v-for="item in items">
  {{ item.text }}
</div>
<div v-for="(item, index) in items"></div>
<div v-for="(value, key) in object"></div>
<div v-for="(value, name, index) in object"></div>
<div v-for="item in items" :key="item.id">
  {{ item.text }}
</div>templa
templa
templaAttach an event listener to the element.v-on
Shorthand:@
Expects:Function | Inline Statement | Object (without argument)
Argument:event (optional if using Object syntax)
Modifiers:
.stop - call event.stopPropagation().
.prevent - call event.preventDefault().
.capture - add event listener in capture mode.
.self - only trigger handler if event was dispatched from this element.
.{keyAlias} - only trigger handler on certain keys.
.once - trigger handler at most once.
.left - only trigger handler for left button mouse events.
.right - only trigger handler for right button mouse events.
.middle - only trigger handler for middle button mouse events.
.passive - attaches a DOM event with { passive: true }.
Details
The event type is denoted by the argument. The expression can be a method name, an
inline statement, or omitted if there are modifiers present.
When used on a normal element, it listens to native DOM events only. When used on a
custom element component, it listens to custom events emitted on that child
component.
When listening to native DOM events, the method receives the native event as the only
argument. If using inline statement, the statement has access to the special $event
property: v-on:click="handle('ok', $event)".v-on also supports binding to an object of event / listener pairs without an argument.
Note when using the object syntax, it does not support any modifiers.
Example:
Listening to custom events on a child component (the handler is called when "my-event"
is emitted on the child):<!-- method handler -->
<button v-on:click="doThis"></button>
<!-- dynamic event -->
<button v-on:[event]="doThis"></button>
<!-- inline statement -->
<button v-on:click="doThat('hello', $event)"></button>
<!-- shorthand -->
<button @click="doThis"></button>
<!-- shorthand dynamic event -->
<button @[event]="doThis"></button>
<!-- stop propagation -->
<button @click.stop="doThis"></button>
<!-- prevent default -->
<button @click.prevent="doThis"></button>
<!-- prevent default without expression -->
<form @submit.prevent></form>
<!-- chain modifiers -->
<button @click.stop.prevent="doThis"></button>
<!-- key modifier using keyAlias -->
<input @keyup.enter="onEnter" />
<!-- the click event will be triggered at most once -->
<button v-on:click.once="doThis"></button>
<!-- object syntax -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>templaDynamically bind one or more attributes, or a component prop to an expression.See also:
Event Handling
Components - Custom Events
v-bind
Shorthand:: or . (when using .prop modifier)
Expects:any (with argument) | Object (without argument)
Argument:attrOrProp (optional)
Modifiers:
.camel - transform the kebab-case attribute name into camelCase.
.prop - force a binding to be set as a DOM property. 3.2+
.attr - force a binding to be set as a DOM attribute. 3.2+
Usage:
When used to bind the class or style attribute, v-bind supports additional value
types such as Array or Objects. See linked guide section below for more details.
When setting a binding on an element, Vue by default checks whether the element has
the key defined as a property using an in operator check. If the property is defined,
Vue will set the value as a DOM property instead of an attribute. This should work in most
cases, but you can override this behavior by explicitly using .prop or .attr modifiers.
This is sometimes necessary, especially when working with custom elements.<MyComponent @my-event="handleThis" />
<!-- inline statement -->
<MyComponent @my-event="handleThis(123, $event)" />templaWhen used for component prop binding, the prop must be properly declared in the child
component.
When used without an argument, can be used to bind an object containing attribute
name-value pairs.
Example:
<!-- bind an attribute -->
<img v-bind:src="imageSrc" />
<!-- dynamic attribute name -->
<button v-bind:[key]="value"></button>
<!-- shorthand -->
<img :src="imageSrc" />
<!-- shorthand dynamic attribute name -->
<button :[key]="value"></button>
<!-- with inline string concatenation -->
<img :src="'/path/to/images/' + fileName" />
<!-- class binding -->
<div :class="{ red: isRed }"></div>
<div :class="[classA, classB]"></div>
<div :class="[classA, { classB: isB, classC: isC }]"></div>
<!-- style binding -->
<div :style="{ fontSize: size + 'px' }"></div>
<div :style="[styleObjectA, styleObjectB]"></div>
<!-- binding an object of attributes -->
<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
<!-- prop binding. "prop" must be declared in the child component. -->
<MyComponent :prop="someThing" />
<!-- pass down parent props in common with a child component -->
<MyComponent v-bind="$props" />
<!-- XLink -->
<svg><a :xlink:special="foo"></a></svg>templaCreate a two-way binding on a form input element or a component.The .prop modifier also has a dedicated shorthand, .:
The .camel modifier allows camelizing a v-bind attribute name when using in-DOM
templates, e.g. the SVG viewBox attribute:
.camel is not needed if you are using string templates, or pre-compiling the template
with a build step.
See also:
Class and Style Bindings
Components - Prop Passing Details
v-model
Expects: varies based on value of form inputs element or output of components
Limited to:
<input>
<select>
<textarea>
components
Modifiers:<div :someProperty.prop="someObject"></div>
<!-- equivalent to -->
<div .someProperty="someObject"></div>
<svg :view-box.camel="viewBox"></svg>templa
templaDenote named slots or scoped slots that expect to receive props..lazy - listen to change events instead of input
.number - cast valid input string to numbers
.trim - trim input
See also:
Form Input Bindings
Component Events - Usage with v-model
v-slot
Shorthand:#
Expects: JavaScript expression that is valid in a function argument position, including
support for destructuring. Optional - only needed if expecting props to be passed to the
slot.
Argument: slot name (optional, defaults to default)
Limited to:
<template>
components (for a lone default slot with props)
Example:Skip compilation for this element and all its children.See also:
Components - Slots
v-pre
Does not expect expression
Details<!-- Named slots -->
<BaseLayout>
  <template v-slot:header>
    Header content
  </template>
  <template v-slot:default>
    Default slot content
  </template>
  <template v-slot:footer>
    Footer content
  </template>
</BaseLayout>
<!-- Named slot that receives props -->
<InfiniteScroll>
  <template v-slot:item="slotProps">
    <div class="item">
      {{ slotProps.item.text }}
    </div>
  </template>
</InfiniteScroll>
<!-- Default slot that receive props, with destructuring -->
<Mouse v-slot="{ x, y }">
  Mouse position: {{ x }}, {{ y }}
</Mouse>templaRender the element and component once only, and skip future updates.Inside the element with v-pre, all Vue template syntax will be preserved and rendered
as-is. The most common use case of this is displaying raw mustache tags.
Example:
v-once
Does not expect expression
Details
On subsequent re-renders, the element/component and all its children will be treated as
static content and skipped. This can be used to optimize update performance.
Since 3.2, you can also memoize part of the template with invalidation conditions using
v-memo.
See also:<span v-pre>{{ this will not be compiled }}</span>
<!-- single element -->
<span v-once>This will never change: {{msg}}</span>
<!-- the element have children -->
<div v-once>
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>
<!-- component -->
<MyComponent v-once :comment="msg"></MyComponent>
<!-- `v-for` directive -->
<ul>
  <li v-for="i in list" v-once>{{i}}</li>
</ul>templa
templaData Binding Syntax - interpolations
v-memo
v-memo 3.2+
Expects:any[]
Details
Memoize a sub-tree of the template. Can be used on both elements and components.
The directive expects a fixed-length array of dependency values to compare for the
memoization. If every value in the array was the same as last render, then updates for the
entire sub-tree will be skipped. For example:
When the component re-renders, if both valueA and valueB remain the same, all
updates for this <div> and its children will be skipped. In fact, even the Virtual DOM
VNode creation will also be skipped since the memoized copy of the sub-tree can be
reused.
It is important to specify the memoization array correctly, otherwise we may skip updates
that should indeed be applied. v-memo with an empty dependency array (v-memo="
[]") would be functionally equivalent to v-once.
Usage with v-for
v-memo is provided solely for micro optimizations in performance-critical scenarios and
should be rarely needed. The most common case where this may prove helpful is when
rendering large v-for lists (where length > 1000):<div v-memo="[valueA, valueB]">
  ...
</div>templaUsed to hide un-compiled template until it is ready.When the component's selected state changes, a large amount of VNodes will be
created even though most of the items remained exactly the same. The v-memo usage
here is essentially saying "only update this item if it went from non-selected to selected,
or the other way around". This allows every unaffected item to reuse its previous VNode
and skip diffing entirely. Note we don't need to include item.id in the memo
dependency array here since Vue automatically infers it from the item's :key.
v-memo can also be used on components to manually prevent unwanted updates in
certain edge cases where the child component update check has been de-optimized. But
again, it is the developer's responsibility to specify correct dependency arrays to avoid
skipping necessary updates.WARNING
When using v-memo with v-for, make sure they are used on the same element. v-
memo does not work inside v-for.⚠
See also:
v-once
v-cloak
Does not expect expression
Details
This directive is only needed in no-build-step setups.<div v-for="item in list" :key="item.id" v-memo="[item.id === selected]">
  <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>
  <p>...more child nodes</p>
</div>templaWhen using in-DOM templates, there can be a "flash of un-compiled templates": the
user may see raw mustache tags until the mounted component replaces them with
rendered content.
v-cloak will remain on the element until the associated component instance is
mounted. Combined with CSS rules such as [v-cloak] { display: none }, it can be
used to hide the raw templates until the component is ready.
Example:
The <div> will not be visible until the compilation is done.[v-cloak] {
  display: none;
}
<div v-cloak>
  {{ message }}
</div>c
templaProvides animated transition effects to a single element or component.Built-in Components
Registration and Usage
Built-in components can be used directly in templates without needing to be registered.
They are also tree-shakeable: they are only included in the build when they are used.
When using them in render functions, they need to be imported explicitly. For example:ⓘ
<Transition>
Propsimport { h, Transition } from 'vue'
h(Transition, {
  /* props */
})jsinterface TransitionProps {
  /**
   * Used to automatically generate transition CSS class names.
   * e.g. `name: 'fade'` will auto expand to `.fade-enter`,
   * `.fade-enter-active`, etc.
   */
  name?: string
  /**
   * Whether to apply CSS transition classes.
   * Default: true
   */
  css?: boolean
  /**
   * Specifies the type of transition events to wait for to
   * determine transition end timing.
   * Default behavior is auto detecting the type that has
   * longer duration.
   */
  type?: 'transition' | 'animation'
  /**
   * Specifies explicit durations of the transition.
   * Default behavior is wait for the first `transitionend`
   * or `animationend` event on the root transition element.
   */
  duration?: number | { enter: number; leave: number }
  /**
   * Controls the timing sequence of leaving/entering transitions.
   * Default behavior is simultaneous.
   */
  mode?: 'in-out' | 'out-in' | 'default'
  /**
   * Whether to apply transition on initial render.
   * Default: false
   */
  appear?: boolean
  /**
   * Props for customizing transition classes.
   * Use kebab-case in templates, e.g. enter-from-class="xxx"
   */
  enterFromClass?: string
  enterActiveClass?: string
  enterToClass?: string
  appearFromClass?: string
  appearActiveClass?: string
  appearToClass?: string
  leaveFromClass?: stringEvents
@before-enter
@before-leave
@enter
@leave
@appear
@after-enter
@after-leave
@after-appear
@enter-cancelled
@leave-cancelled (v-show only)
@appear-cancelled
Example
Simple element:
Dynamic component, with transition mode + animate on appear:
Listening to transition events:  leaveActiveClass?: string
  leaveToClass?: string
}
<Transition>
  <div v-if="ok">toggled content</div>
</Transition>
<Transition name="fade" mode="out-in" appear>
  <component :is="view"></component>
</Transition>
<Transition @after-enter="onTransitionComplete">
  <div v-show="ok">toggled content</div>
</Transition>templa
templa
templaProvides transition effects for multiple elements or components in a list.See also:<Transition> Guide
<TransitionGroup>
Props
<TransitionGroup> accepts the same props as <Transition> except mode, plus two
additional props:
Events
<TransitionGroup> emits the same events as <Transition>.
Details
By default, <TransitionGroup> doesn't render a wrapper DOM element, but one can be
defined via the tag prop.
Note that every child in a <transition-group> must be uniquely keyed for the
animations to work properly.
<TransitionGroup> supports moving transitions via CSS transform. When a child's
position on screen has changed after an update, it will get applied a moving CSS classinterface TransitionGroupProps extends Omit<TransitionProps, 'mode'> {
  /**
   * If not defined, renders as a fragment.
   */
  tag?: string
  /**
   * For customizing the CSS class applied during move transitions.
   * Use kebab-case in templates, e.g. move-class="xxx"
   */
  moveClass?: string
}Caches dynamically toggled components wrapped inside.(auto generated from the name attribute or configured with the move-class prop). If
the CSS transform property is "transition-able" when the moving class is applied, the
element will be smoothly animated to its destination using the FLIP technique.
Example
See also:Guide - TransitionGroup
<KeepAlive>
Props<TransitionGroup tag="ul" name="slide">
  <li v-for="item in items" :key="item.id">
    {{ item.text }}
  </li>
</TransitionGroup>
interface KeepAliveProps {
  /**
   * If specified, only components with names matched by
   * `include` will be cached.
   */
  include?: MatchPattern
  /**
   * Any component with a name matched by `exclude` will
   * not be cached.
   */
  exclude?: MatchPattern
  /**
   * The maximum number of component instances to cache.
   */
  max?: number | string
}
type MatchPattern = string | RegExp | (string | RegExp)[]templaDetails
When wrapped around a dynamic component, <KeepAlive> caches the inactive
component instances without destroying them.
There can only be one active component instance as the direct child of <KeepAlive> at
any time.
When a component is toggled inside <KeepAlive>, its activated and deactivated
lifecycle hooks will be invoked accordingly, providing an alternative to mounted and
unmounted, which are not called. This applies to the direct child of <KeepAlive> as
well as to all of its descendants.
Example
Basic usage:
When used with v-if / v-else branches, there must be only one component rendered
at a time:
Used together with <Transition>:
Using include / exclude:<KeepAlive>
  <component :is="view"></component>
</KeepAlive>
<KeepAlive>
  <comp-a v-if="a > 1"></comp-a>
  <comp-b v-else></comp-b>
</KeepAlive>
<Transition>
  <KeepAlive>
    <component :is="view"></component>
  </KeepAlive>
</Transition>templa
templa
templaRenders its slot content to another part of the DOM.Usage with max:
See also:Guide - KeepAlive
<Teleport>
Props<!-- comma-delimited string -->
<KeepAlive include="a,b">
  <component :is="view"></component>
</KeepAlive>
<!-- regex (use `v-bind`) -->
<KeepAlive :include="/a|b/">
  <component :is="view"></component>
</KeepAlive>
<!-- Array (use `v-bind`) -->
<KeepAlive :include="['a', 'b']">
  <component :is="view"></component>
</KeepAlive>
<KeepAlive :max="10">
  <component :is="view"></component>
</KeepAlive>templa
templaUsed for orchestrating nested async dependencies in a component tree.Example
Specifying target container:
Conditionally disabling:
See also:Guide - Teleport
<Suspense>Experimental
Propsinterface TeleportProps {
  /**
   * Required. Specify target container.
   * Can either be a selector or an actual element.
   */
  to: string | HTMLElement
  /**
   * When `true`, the content will remain in its original
   * location instead of moved into the target container.
   * Can be changed dynamically.
   */
  disabled?: boolean
}
<teleport to="#some-id" />
<teleport to=".some-class" />
<teleport to="[data-teleport]" />
<teleport to="#popup" :disabled="displayVideoInline">
  <video src="./my-movie.mp4">
</teleport>templa
templaEvents
@resolve
@pending
@fallback
Details
<Suspense> accepts two slots: the #default slot and the #fallback slot. It will
display the content of the fallback slot while rendering the default slot in memory.
If it encounters async dependencies (Async Components and components with async
setup()) while rendering the default slot, it will wait until all of them are resolved before
displaying the default slot.
See also:Guide - Suspenseinterface SuspenseProps {
  timeout?: string | number
}A "meta component" for rendering dynamic components or elements.Built-in Special Elements
Not Components
<component>, <slot> and <template> are component-like features and part of the
template syntax. They are not true components and are compiled away during template
compilation. As such, they are conventionally written with lowercase in templates.ⓘ
<component>
Props
Details
The actual component to render is determined by the is prop.
When is is a string, it could be either an HTML tag name or a component's
registered name.
Alternatively, is can also be directly bound to the definition of a component.
Example
Rendering components by registered name (Options API):interface DynamicComponentProps {
  is: string | Component
}Rendering components by definition (Composition API with <script setup>):
Rendering HTML elements:
The built-in components can all be passed to is, but you must register them if you
want to pass them by name. For example:<script>
import Foo from './Foo.vue'
import Bar from './Bar.vue'
export default {
  components: { Foo, Bar },
  data() {
    return {
      view: 'Foo'
    }
  }
}
</script>
<template>
  <component :is="view" />
</template>
<script setup>
import Foo from './Foo.vue'
import Bar from './Bar.vue'
</script>
<template>
  <component :is="Math.random() > 0.5 ? Foo : Bar" />
</template>
<component :is="href ? 'a' : 'span'"></component>v
v
templaRegistration is not required if you pass the component itself to is rather than its name,
e.g. in <script setup>.
If v-model is used on a <component> tag, the template compiler will expand it to a
modelValue prop and update:modelValue event listener, much like it would for any
other component. However, this won't be compatible with native HTML elements, such as
<input> or <select>. As a result, using v-model with a dynamically created native
element won't work:
In practice, this edge case isn't common as native form fields are typically wrapped in
components in real applications. If you do need to use a native element directly then you
can split the v-model into an attribute and event manually.<script>
import { Transition, TransitionGroup } from 'vue'
export default {
  components: {
    Transition,
    TransitionGroup
  }
}
</script>
<template>
  <component :is="isGroup ? 'TransitionGroup' : 'Transition'">
    ...
  </component>
</template>
<script setup>
import { ref } from 'vue'
const tag = ref('input')
const username = ref('')
</script>
<template>
  <!-- This won't work as 'input' is a native HTML element -->
  <component :is="tag" v-model="username" />
</template>v
vDenotes slot content outlets in templates.See also:Dynamic Components
<slot>
Props
Details
The <slot> element can use the name attribute to specify a slot name. When no
name is specified, it will render the default slot. Additional attributes passed to the slot
element will be passed as slot props to the scoped slot defined in the parent.
The element itself will be replaced by its matched slot content.
<slot> elements in Vue templates are compiled into JavaScript, so they are not to be
confused with native <slot> elements.
See also:Component - Slots
<template>interface SlotProps {
  /**
   * Any props passed to <slot> to passed as arguments
   * for scoped slots
   */
  [key: string]: any
  /**
   * Reserved for specifying slot name.
   */
  name?: string
}The <template> tag is used as a placeholder when we want to use a built-in directive
without rendering an element in the DOM.
Details:
The special handling for <template> is only triggered if it is used with one of these
directives:
If none of those directives are present then it will be rendered as a native <template>
element instead.
A <template> with a v-for can also have a key attribute. All other attributes and
directives will be discarded, as they aren't meaningful without a corresponding element.
Single-file components use a top-level <template> tag to wrap the entire template.
That usage is separate from the use of <template> described above. That top-level tag
is not part of the template itself and doesn't support template syntax, such as directives.v-if, v-else-if, or v-else
v-for
v-slot
See also:
Guide - v-if on <template>
Guide - v-for on <template>
Guide - Named slotsThe key special attribute is primarily used as a hint for Vue's virtual DOM algorithm to
identify vnodes when diffing the new list of nodes against the old list.Built-in Special Attributes
key
Expects:number | string | symbol
Details
Without keys, Vue uses an algorithm that minimizes element movement and tries to
patch/reuse elements of the same type in-place as much as possible. With keys, it will
reorder elements based on the order change of keys, and elements with keys that are no
longer present will always be removed / destroyed.
Children of the same common parent must have unique keys. Duplicate keys will cause
render errors.
The most common use case is combined with v-for:
It can also be used to force replacement of an element/component instead of reusing it.
This can be useful when you want to:
For example:Properly trigger lifecycle hooks of a component
Trigger transitions<ul>
  <li v-for="item in items" :key="item.id">...</li>
</ul>templaDenotes a template ref.When text changes, the <span> will always be replaced instead of patched, so a
transition will be triggered.
See also:Guide - List Rendering - Maintaining State with key
ref
Expects:string | Function
Details
ref is used to register a reference to an element or a child component.
In Options API, the reference will be registered under the component's this.$refs
object:
In Composition API, the reference will be stored in a ref with matching name:<transition>
  <span :key="text">{{ text }}</span>
</transition>
<!-- stored as this.$refs.p -->
<p ref="p">hello</p>
<script setup>
import { ref } from 'vue'
const p = ref()
</script>
<template>
  <p ref="p">hello</p>
</template>templa
templa
vUsed for binding dynamic components.If used on a plain DOM element, the reference will be that element; if used on a child
component, the reference will be the child component instance.
Alternatively ref can accept a function value which provides full control over where to
store the reference:
An important note about the ref registration timing: because the refs themselves are
created as a result of the render function, you must wait until the component is mounted
before accessing them.
this.$refs is also non-reactive, therefore you should not attempt to use it in templates
for data-binding.
See also:
Guide - Template Refs
Guide - Typing Template RefsTS
Guide - Typing Component Template RefsTS
is
Expects:string | Component
Usage on native elements
When the is attribute is used on a native HTML element, it will be interpreted as a
Customized built-in element, which is a native web platform feature.
There is, however, a use case where you may need Vue to replace a native element with a
Vue component, as explained in DOM Template Parsing Caveats. You can prefix the
value of the is attribute with vue: so that Vue will render the element as a Vue
component instead:3.1+<ChildComponent :ref="(el) => child = el" />templaSee also:
Built-in Special Element - <component>
Dynamic Components<table>
  <tr is="vue:my-row-component"></tr>
</table>templaA Vue Single-File Component (SFC), conventionally using the *.vue file extension, is a
custom file format that uses an HTML-like syntax to describe a Vue component. A Vue SFC
is syntactically compatible with HTML.
Each *.vue file consists of three types of top-level language blocks: <template>,
<script>, and <style>, and optionally additional custom blocks:SFC Syntax Specification
Overview
Language Blocks<template>
  <div class="example">{{ msg }}</div>
</template>
<script>
export default {
  data() {
    return {
      msg: 'Hello world!'
    }
  }
}
</script>
<style>
.example {
  color: red;
}
</style>
<custom1>
  This could be e.g. documentation for the component.
</custom1>v<template>
Each *.vue file can contain at most one top-level <template> block at a time.
Contents will be extracted and passed on to @vue/compiler-dom, pre-compiled into
JavaScript render functions, and attached to the exported component as its render
option.
<script>
Each *.vue file can contain at most one <script> block at a time (excluding <script
setup>).
The script is executed as an ES Module.
The default export should be a Vue component options object, either as a plain object
or as the return value of defineComponent.
<script setup>
Each *.vue file can contain at most one <script setup> block at a time (excluding
normal <script>).
The script is pre-processed and used as the component's setup() function, which
means it will be executed for each instance of the component. Top-level bindings in
<script setup> are automatically exposed to the template. For more details, see
dedicated documentation on <script setup>.
<style>
A single *.vue file can contain multiple <style> tags.
A <style> tag can have scoped or module attributes (see SFC Style Features for
more details) to help encapsulate the styles to the current component. Multiple
<style> tags with different encapsulation modes can be mixed in the same component.Additional custom blocks can be included in a *.vue file for any project-specific needs,
for example a <docs> block. Some real-world examples of custom blocks include:
Handling of Custom Blocks will depend on tooling - if you want to build your own custom
block integrations, see relevant tooling section for more details.
An SFC automatically infers the component's name from its filename in the following cases:
Blocks can declare pre-processor languages using the lang attribute. The most common
case is using TypeScript for the <script> block:Custom Blocks
Gridsome: <page-query>
vite-plugin-vue-gql: <gql>
vue-i18n: <i18n>
Automatic Name Inference
Dev warning formatting
DevTools inspection
Recursive self-reference. E.g. a file named FooBar.vue can refer to itself as
<FooBar/> in its template. This has lower priority than explicitly registered/imported
components.
Pre-Processors
<script lang="ts">
  // use TypeScript
</script>templalang can be applied to any block - for example we can use <style> with Sass and
<template> with Pug:
Note that integration with various pre-processors may differ by toolchain. Check out the
respective documentation for examples:
If you prefer splitting up your *.vue components into multiple files, you can use the src
attribute to import an external file for a language block:
Beware that src imports follow the same path resolution rules as webpack module
requests, which means:Vite
Vue CLI
webpack + vue-loader
Src Imports
Relative paths need to start with ./
You can import resources from npm dependencies:<template lang="pug">
p {{ msg }}
</template>
<style lang="scss">
  $primary-color: #333;
  body {
    color: $primary-color;
  }
</style>
<template src="./template.html"></template>
<style src="./style.css"></style>
<script src="./script.js"></script>templa
vsrc imports also work with custom blocks, e.g.:
Inside each block you shall use the comment syntax of the language being used (HTML,
CSS, JavaScript, Pug, etc.). For top-level comments, use HTML comment syntax: <!--
comment contents here -->Comments<!-- import a file from the installed "todomvc-app-css" npm package -->
<style src="todomvc-app-css/index.css" />
<unit-test src="./unit-test.js">
</unit-test>v
v<script setup> is a compile-time syntactic sugar for using Composition API inside Single-
File Components (SFCs). It is the recommended syntax if you are using both SFCs and
Composition API. It provides a number of advantages over the normal <script> syntax:
To opt-in to the syntax, add the setup attribute to the <script> block:
The code inside is compiled as the content of the component's setup() function. This
means that unlike normal <script>, which only executes once when the component is first
imported, code inside <script setup> will execute every time an instance of the
component is created.
When using <script setup>, any top-level bindings (including variables, function
declarations, and imports) declared inside <script setup> are directly usable in the
template:<script setup>
More succinct code with less boilerplate
Ability to declare props and emitted events using pure TypeScript
Better runtime performance (the template is compiled into a render function in the same
scope, without an intermediate proxy)
Better IDE type-inference performance (less work for the language server to extract types
from code)
Basic Syntax
Top-level bindings are exposed to template<script setup>
console.log('hello script setup')
</script>vuImports are exposed in the same fashion. This means you can directly use an imported
helper function in template expressions without having to expose it via the methods option:
Reactive state needs to be explicitly created using Reactivity APIs. Similar to values
returned from a setup() function, refs are automatically unwrapped when referenced in
templates:Reactivity<script setup>
// variable
const msg = 'Hello!'
// functions
function log() {
  console.log(msg)
}
</script>
<template>
  <button @click="log">{{ msg }}</button>
</template>
<script setup>
import { capitalize } from './helpers'
</script>
<template>
  <div>{{ capitalize('hello') }}</div>
</template>vu
vuValues in the scope of <script setup> can also be used directly as custom component
tag names:
Think of MyComponent as being referenced as a variable. If you have used JSX, the mental
model is similar here. The kebab-case equivalent <my-component> also works in the
template - however PascalCase component tags are strongly recommended for consistency.
It also helps differentiating from native custom elements.
Since components are referenced as variables instead of registered under string keys, we
should use dynamic :is binding when using dynamic components inside <script
setup>:Using Components
Dynamic Components<script setup>
import { ref } from 'vue'
const count = ref(0)
</script>
<template>
  <button @click="count++">{{ count }}</button>
</template>
<script setup>
import MyComponent from './MyComponent.vue'
</script>
<template>
  <MyComponent />
</template>vu
vuNote how the components can be used as variables in a ternary expression.
An SFC can implicitly refer to itself via its filename. E.g. a file named FooBar.vue can refer
to itself as <FooBar/> in its template.
Note this has lower priority than imported components. If you have a named import that
conflicts with the component's inferred name, you can alias the import:
You can use component tags with dots like <Foo.Bar> to refer to components nested
under object properties. This is useful when you import multiple components from a single
file:Recursive Components
Namespaced Components<script setup>
import Foo from './Foo.vue'
import Bar from './Bar.vue'
</script>
<template>
  <component :is="Foo" />
  <component :is="someCondition ? Foo : Bar" />
</template>
import { FooBar as FooBarChild } from './components'
<script setup>
import * as Form from './form-components'
</script>
<template>
  <Form.Input>
    <Form.Label>label</Form.Label>
  </Form.Input>
</template>vu
vuGlobally registered custom directives just work as normal. Local custom directives don't
need to be explicitly registered with <script setup>, but they must follow the naming
scheme vNameOfDirective:
If you're importing a directive from elsewhere, it can be renamed to fit the required naming
scheme:
To declare options like props and emits with full type inference support, we can use the
defineProps and defineEmits APIs, which are automatically available inside <script
setup>:Using Custom Directives
defineProps() & defineEmits()<script setup>
const vMyDirective = {
  beforeMount: (el) => {
    // do something with the element
  }
}
</script>
<template>
  <h1 v-my-directive>This is a Heading</h1>
</template>
<script setup>
import { myDirective as vMyDirective } from './MyDirective.js'
</script>vu
vuIf you are using TypeScript, it is also possible to declare props and emits using pure type
annotations.
Components using <script setup> are closed by default - i.e. the public instance of the
component, which is retrieved via template refs or $parent chains, will not expose any of
the bindings declared inside <script setup>.
To explicitly expose properties in a <script setup> component, use the defineExpose
compiler macro:defineProps and defineEmits are compiler macros only usable inside <script
setup>. They do not need to be imported, and are compiled away when <script
setup> is processed.
defineProps accepts the same value as the props option, while defineEmits
accepts the same value as the emits option.
defineProps and defineEmits provide proper type inference based on the options
passed.
The options passed to defineProps and defineEmits will be hoisted out of setup into
module scope. Therefore, the options cannot reference local variables declared in setup
scope. Doing so will result in a compile error. However, it can reference imported bindings
since they are in the module scope as well.
defineExpose()<script setup>
const props = defineProps({
  foo: String
})
const emit = defineEmits(['change', 'delete'])
// setup code
</script>vuWhen a parent gets an instance of this component via template refs, the retrieved instance
will be of the shape { a: number, b: number } (refs are automatically unwrapped just like
on normal instances).
Usage of slots and attrs inside <script setup> should be relatively rare, since you
can access them directly as $slots and $attrs in the template. In the rare case where
you do need them, use the useSlots and useAttrs helpers respectively:
useSlots and useAttrs are actual runtime functions that return the equivalent of
setupContext.slots and setupContext.attrs. They can be used in normal composition
API functions as well.useSlots() & useAttrs()<script setup>
import { ref } from 'vue'
const a = 1
const b = ref(2)
defineExpose({
  a,
  b
})
</script>
<script setup>
import { useSlots, useAttrs } from 'vue'
const slots = useSlots()
const attrs = useAttrs()
</script>vu
vu<script setup> can be used alongside normal <script>. A normal <script> may be
needed in cases where we need to:
Support for combining <script setup> and <script> in the same component is limited
to the scenarios described above. Specifically:
If you find yourself in one of the scenarios that is not supported then you should consider
switching to an explicit setup() function, instead of using <script setup>.Usage alongside normal <script>
Declare options that cannot be expressed in <script setup>, for example
inheritAttrs or custom options enabled via plugins.
Declaring named exports.
Run side effects or create objects that should only execute once.
Do NOT use a separate <script> section for options that can already be defined using
<script setup>, such as props and emits.
Variables created inside <script setup> are not added as properties to the component
instance, making them inaccessible from the Options API. Mixing APIs in this way is
strongly discouraged.<script>
// normal <script>, executed in module scope (only once)
runSideEffectOnce()
// declare additional options
export default {
  inheritAttrs: false,
  customOptions: {}
}
</script>
<script setup>
// executed in setup() scope (for each instance)
</script>vuTop-level await can be used inside <script setup>. The resulting code will be compiled
as async setup():
In addition, the awaited expression will be automatically compiled in a format that preserves
the current component instance context after the await.
Props and emits can also be declared using pure-type syntax by passing a literal type
argument to defineProps or defineEmits:Top-level await
Note
async setup() must be used in combination with Suspense, which is currently still an
experimental feature. We plan to finalize and document it in a future release - but if you
are curious now, you can refer to its tests to see how it works.⚠
TypeScript-only Features TS
Type-only props/emit declarations<script setup>
const post = await fetch(`/api/post/1`).then((r) => r.json())
</script>vudefineProps or defineEmits can only use either runtime declaration OR type
declaration. Using both at the same time will result in a compile error.
When using type declaration, the equivalent runtime declaration is automatically
generated from static analysis to remove the need for double declaration and still ensure
correct runtime behavior.
In dev mode, the compiler will try to infer corresponding runtime validation from the
types. For example here foo: String is inferred from the foo: string type. If the
type is a reference to an imported type, the inferred result will be foo: null (equal to
any type) since the compiler does not have information of external files.
In prod mode, the compiler will generate the array format declaration to reduce bundle
size (the props here will be compiled into ['foo', 'bar'])
The emitted code is still TypeScript with valid typing, which can be further processed
by other tools.
As of now, the type declaration argument must be one of the following to ensure correct
static analysis:
Currently complex types and type imports from other files are not supported. It is
possible to support type imports in the future.A type literal
A reference to an interface or a type literal in the same file
Default props values when using type declarationconst props = defineProps<{
  foo: string
  bar?: number
}>()
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()One drawback of the type-only defineProps declaration is that it doesn't have a way to
provide default values for the props. To resolve this problem, a withDefaults compiler
macro is also provided:
This will be compiled to equivalent runtime props default options. In addition, the
withDefaults helper provides type checks for the default values, and ensures the
returned props type has the optional flags removed for properties that do have default
values declared.
Due to the difference in module execution semantics, code inside <script setup> relies
on the context of an SFC. When moved into external .js or .ts files, it may lead to
confusion for both developers and tools. Therefore, <script setup> cannot be used with
the src attribute.Restrictionsexport interface Props {
  msg?: string
  labels?: string[]
}
const props = withDefaults(defineProps<Props>(), {
  msg: 'hello',
  labels: () => ['one', 'two']
})When a <style> tag has the scoped attribute, its CSS will apply to elements of the
current component only. This is similar to the style encapsulation found in Shadow DOM. It
comes with some caveats, but doesn't require any polyfills. It is achieved by using PostCSS
to transform the following:
Into the following:
With scoped, the parent component's styles will not leak into child components. However,
a child component's root node will be affected by both the parent's scoped CSS and theSFC CSS Features
Scoped CSS
Child Component Root Elements<style scoped>
.example {
  color: red;
}
</style>
<template>
  <div class="example">hi</div>
</template>
<style>
.example[data-v-f3f3eg9] {
  color: red;
}
</style>
<template>
  <div class="example" data-v-f3f3eg9>hi</div>
</template>vu
vuchild's scoped CSS. This is by design so that the parent can style the child root element for
layout purposes.
If you want a selector in scoped styles to be "deep", i.e. affecting child components, you
can use the :deep() pseudo-class:
The above will be compiled into:
By default, scoped styles do not affect contents rendered by <slot/>, as they are
considered to be owned by the parent component passing them in. To explicitly target slot
content, use the :slotted pseudo-class:Deep Selectors
TIP
DOM content created with v-html are not affected by scoped styles, but you can still
style them using deep selectors.ⓘ
Slotted Selectors<style scoped>
.a :deep(.b) {
  /* ... */
}
</style>
.a[data-v-f3f3eg9] .b {
  /* ... */
}vu
cIf you want just one rule to apply globally, you can use the :global pseudo-class rather
than creating another <style> (see below):
You can also include both scoped and non-scoped styles in the same component:Global Selectors
Mixing Local and Global Styles
Scoped Style Tips
Scoped styles do not eliminate the need for classes. Due to the way browsers render
various CSS selectors, p { color: red } will be many times slower when scoped (i.e.
when combined with an attribute selector). If you use classes or ids instead, such as in
.example { color: red }, then you virtually eliminate that performance hit.<style scoped>
:slotted(div) {
  color: red;
}
</style>
<style scoped>
:global(.red) {
  color: red;
}
</style>
<style>
/* global styles */
</style>
<style scoped>
/* local styles */
</style>vu
vu
vuA <style module> tag is compiled as CSS Modules and exposes the resulting CSS
classes to the component as an object under the key of $style:
The resulting classes are hashed to avoid collision, achieving the same effect of scoping the
CSS to the current component only.
Refer to the CSS Modules spec for more details such as global exceptions and
composition.
You can customize the property key of the injected classes object by giving the module
attribute a value:Be careful with descendant selectors in recursive components! For a CSS rule with
the selector .a .b, if the element that matches .a contains a recursive child
component, then all .b in that child component will be matched by the rule.
CSS Modules
Custom Inject Name<template>
  <p :class="$style.red">This should be red</p>
</template>
<style module>
.red {
  color: red;
}
</style>vuThe injected classes can be accessed in setup() and <script setup> via the
useCssModule API. For <style module> blocks with custom injection names,
useCssModule accepts the matching module attribute value as the first argument:
SFC <style> tags support linking CSS values to dynamic component state using the v-
bind CSS function:Usage with Composition API
v-bind() in CSS<template>
  <p :class="classes.red">red</p>
</template>
<style module="classes">
.red {
  color: red;
}
</style>
import { useCssModule } from 'vue'
// inside setup() scope...
// default, returns classes for <style module>
useCssModule()
// named, returns classes for <style module="classes">
useCssModule('classes')vuThe syntax works with <script setup>, and supports JavaScript expressions (must be
wrapped in quotes):
The actual value will be compiled into a hashed CSS custom property, so the CSS is still
static. The custom property will be applied to the component's root element via inline styles
and reactively updated if the source value changes.<template>
  <div class="text">hello</div>
</template>
<script>
export default {
  data() {
    return {
      color: 'red'
    }
  }
}
</script>
<style>
.text {
  color: v-bind(color);
}
</style>
<script setup>
const theme = {
  color: 'red'
}
</script>
<template>
  <p>hello</p>
</template>
<style scoped>
p {
  color: v-bind('theme.color');
}
</style>vu
vuCreates virtual DOM nodes (vnodes).Render Function APIs
h()
Type
Types are simplified for readability.
Details
The first argument can either be a string (for native elements) or a Vue component
definition. The second argument is the props to be passed, and the third argument is the
children.
When creating a component vnode, the children must be passed as slot functions. A
single slot function can be passed if the component expects only the default slot.
Otherwise, the slots must be passed as an object of slot functions.
For convenience, the props argument can be omitted when the children is not a slots
object.// full signature
function h(
  type: string | Component,
  props?: object | null,
  children?: Children | Slot | Slots
): VNode
// omitting props
function h(type: string | Component, children?: Children | Slot): VNode
type Children = string | number | boolean | VNode | null | Children[]
type Slot = () => Children
type Slots = { [name: string]: Slot }Example
Creating native elements:
Creating components:import { h } from 'vue'
// all arguments except the type are optional
h('div')
h('div', { id: 'foo' })
// both attributes and properties can be used in props
// Vue automatically picks the right way to assign it
h('div', { class: 'bar', innerHTML: 'hello' })
// class and style have the same object / array
// value support like in templates
h('div', { class: [foo, { bar }], style: { color: 'red' } })
// event listeners should be passed as onXxx
h('div', { onClick: () => {} })
// children can be a string
h('div', { id: 'foo' }, 'hello')
// props can be omitted when there are no props
h('div', 'hello')
h('div', [h('span', 'hello')])
// children array can contain mixed vnodes and strings
h('div', ['hello', h('span', 'hello')])Merge multiple props objects with special handling for certain props.See also:Guide - Render Functions - Creating VNodes
mergeProps()
Type
Details
mergeProps() supports merging multiple props objects with special handling for the
following props:
classimport Foo from './Foo.vue'
// passing props
h(Foo, {
  // equivalent of some-prop="hello"
  someProp: 'hello',
  // equivalent of @update="() => {}"
  onUpdate: () => {}
})
// passing single default slot
h(Foo, () => 'default slot')
// passing named slots
// notice the `null` is required to avoid
// slots object being treated as props
h(MyComponent, null, {
  default: () => 'default slot',
  foo: () => h('div', 'foo'),
  bar: () => [h('span', 'one'), h('span', 'two')]
})
function mergeProps(...args: object[]): objectClones a vnode.If you do not need the merge behavior and want simple overwrites, native object spread
can be used instead.style
onXxx event listeners - multiple listeners with the same name will be merged into an
array.
Example
cloneVNode()
Type
Detailsimport { mergeProps } from 'vue'
const one = {
  class: 'foo',
  onClick: handlerA
}
const two = {
  class: { bar: true },
  onClick: handlerB
}
const merged = mergeProps(one, two)
/**
 {
   class: 'foo bar',
   onClick: [handlerA, handlerB]
 }
 */
function cloneVNode(vnode: VNode, extraProps?: object): VNodeChecks if a value is a vnode.
For manually resolving a registered component by name.Returns a cloned vnode, optionally with extra props to merge with the original.
Vnodes should be considered immutable once created, and you should not mutate the
props of an existing vnode. Instead, clone it with different / extra props.
Vnodes have special internal properties, so cloning them is not as simple as an object
spread. cloneVNode() handles most of the internal logic.
Example
isVNode()
Type
resolveComponent()
Typeimport { h, cloneVNode } from 'vue'
const original = h('div')
const cloned = cloneVNode(original, { id: 'foo' })
function isVNode(value: unknown): boolean
function resolveComponent(name: string): Component | stringFor manually resolving a registered directive by name.Details
Note: you do not need this if you can import the component directly.
resolveComponent() must be called inside either setup() or the render function in
order to resolve from the correct component context.
If the component is not found, a runtime warning will be emitted, and the name string is
returned.
Example
See also:Guide - Render Functions - Components
resolveDirective()
Type
Detailsconst { h, resolveComponent } = Vue
export default {
  setup() {
    const ButtonCounter = resolveComponent('ButtonCounter')
    return () => {
      return h(ButtonCounter)
    }
  }
}
function resolveDirective(name: string): Directive | undefinedFor adding custom directives to vnodes.Note: you do not need this if you can import the component directly.
resolveDirective() must be called inside either setup() or the render function in
order to resolve from the correct component context.
If the directive is not found, a runtime warning will be emitted, and the function returns
undefined.
See also:Guide - Render Functions - Custom Directives
withDirectives()
Type
Details
Wraps an existing vnode with custom directives. The second argument is an array of
custom directives. Each custom directive is also represented as an array in the form of
[Directive, value, argument, modifiers]. Tailing elements of the array can be
omitted if not needed.
Examplefunction withDirectives(
  vnode: VNode,
  directives: DirectiveArguments
): VNode
// [Directive, value, argument, modifiers]
type DirectiveArguments = Array<
  | [Directive]
  | [Directive, any]
  | [Directive, any, string]
  | [Directive, any, string, DirectiveModifiers]
>For adding built-in v-on modifiers to an event handler function.See also:Guide - Render Functions - Custom Directives
withModifiers()
Type
Exampleimport { h, withDirectives } from 'vue'
// a custom directive
const pin = {
  mounted() {
    /* ... */
  },
  updated() {
    /* ... */
  }
}
// <div v-pin:top.animate="200"></div>
const vnode = withDirectives(h('div'), [
  [pin, 200, 'top', { animate: true }]
])
function withModifiers(fn: Function, modifiers: string[]): Function
import { h, withModifiers } from 'vue'
const vnode = h('button', {
  // equivalent of v-on.stop.prevent
  onClick: withModifiers(() => {
    // ...
  }, ['stop', 'prevent'])
})See also:Guide - Render Functions - Event ModifiersServer-Side Rendering API
renderToString()
Exported from vue/server-renderer
Type
Example
You can pass an optional context object, which can be used to record additional data
during the render, for example accessing content of Teleports:SSR Contextfunction renderToString(
  input: App | VNode,
  context?: SSRContext
): Promise<string>
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'
const app = createSSRApp({
  data: () => ({ msg: 'hello' }),
  template: `<div>{{ msg }}</div>`
})
;(async () => {
  const html = await renderToString(app)
  console.log(html)
})()Renders input as a Node.js Readable stream.Most other SSR APIs on this page also optionally accept a context object. The context
object can be accessed in component code via the useSSRContext helper.
See also:Guide - Server-Side Rendering
renderToNodeStream()
Exported from vue/server-renderer
Type
Example
Note
This method is not supported in the ESM build of vue/server-renderer, which is
decoupled from Node.js environments. Use pipeToNodeWritable instead.ⓘconst ctx = {}
const html = await renderToString(app, ctx)
console.log(ctx.teleports) // { '#teleported': 'teleported content' }
function renderToNodeStream(
  input: App | VNode,
  context?: SSRContext
): Readable
// inside a Node.js http handler
renderToNodeStream(app).pipe(res)Render and pipe to an existing Node.js Writable stream instance.
Renders input as a Web ReadableStream.pipeToNodeWritable()
Exported from vue/server-renderer
Type
Example
renderToWebStream()
Exported from vue/server-renderer
Type
Examplefunction pipeToNodeWritable(
  input: App | VNode,
  context: SSRContext = {},
  writable: Writable
): void
// inside a Node.js http handler
pipeToNodeWritable(app, {}, res)
function renderToWebStream(
  input: App | VNode,
  context?: SSRContext
): ReadableStreamRender and pipe to an existing Web WritableStream instance.Note
In environments that do not expose ReadableStream constructor in the global scope,
pipeToWebWritable() should be used instead.ⓘ
pipeToWebWritable()
Exported from vue/server-renderer
Type
Example
This is typically used in combination with TransformStream:// inside an environment with ReadableStream support
return new Response(renderToWebStream(app))
function pipeToWebWritable(
  input: App | VNode,
  context: SSRContext = {},
  writable: WritableStream
): void
// TransformStream is available in environments such as CloudFlare workers.
// in Node.js, TransformStream needs to be explicitly imported from 'stream
const { readable, writable } = new TransformStream()
pipeToWebWritable(app, {}, writable)
return new Response(readable)Renders input in streaming mode using a simple readable interface.renderToSimpleStream()
Exported from vue/server-renderer
Type
Examplefunction renderToSimpleStream(
  input: App | VNode,
  context: SSRContext,
  options: SimpleReadable
): SimpleReadable
interface SimpleReadable {
  push(content: string | null): void
  destroy(err: any): void
}
let res = ''
renderToSimpleStream(
  app,
  {},
  {
    push(chunk) {
      if (chunk === null) {
        // done
        console(`render complete: ${res}`)
      } else {
        res += chunk
      }
    },
    destroy(err) {
      // error encountered
    }
  }
)A runtime API used to retrieve the context object passed to renderToString() or other
server render APIs.useSSRContext()
Type
Example
The retrieved context can be used to attach information that is needed for rendering the
final HTML (e.g. head metadata).function useSSRContext<T = Record<string, any>>(): T | undefined
<script setup>
import { useSSRContext } from 'vue'
// make sure to only call it during SSR
// https://vitejs.dev/guide/ssr.html#conditional-logic
if (import.meta.env.SSR) {
  const ctx = useSSRContext()
  // ...attach properties to the context
}
</script>vuUsed to annotate a prop with more advanced types when using runtime props declarations.Utility Types
INFO
This page only lists a few commonly used utility types that may need explanation for their
usage. For a full list of exported types, consult the source code.ⓘ
PropType<T>
Example
See also:Guide - Typing Component Propsimport type { PropType } from 'vue'
interface Book {
  title: string
  author: string
  year: number
}
export default {
  props: {
    book: {
      // provide more specific type to `Object`
      type: Object as PropType<Book>,
      required: true
    }
  }
}Used to augment the component instance type to support custom global properties.
Used to augment the component options type to support custom options.ComponentCustomProperties
Example
TIP
Augmentations must be placed in a module .ts or .d.ts file. See Type
Augmentation Placement for more details.ⓘ
See also:Guide - Augmenting Global Properties
ComponentCustomOptions
Exampleimport axios from 'axios'
declare module 'vue' {
  interface ComponentCustomProperties {
    $http: typeof axios
    $translate: (key: string) => string
  }
}Used to augment allowed TSX props in order to use non-declared props on TSX elements.TIP
Augmentations must be placed in a module .ts or .d.ts file. See Type
Augmentation Placement for more details.ⓘ
See also:Guide - Augmenting Custom Options
ComponentCustomProps
Exampleimport { Route } from 'vue-router'
declare module 'vue' {
  interface ComponentCustomOptions {
    beforeRouteEnter?(to: any, from: any, next: () => void): void
  }
}
declare module 'vue' {
  interface ComponentCustomProps {
    hello?: string
  }
}
export {}
// now works even if hello is not a declared prop
<MyComponent hello="world" />tUsed to augment allowed values in style property bindings.TIP
Augmentations must be placed in a module .ts or .d.ts file. See Type
Augmentation Placement for more details.ⓘ
CSSProperties
Example
Allow any custom CSS property
TIP
Augmentations must be placed in a module .ts or .d.ts file. See Type Augmentation
Placement for more details.ⓘdeclare module 'vue' {
  interface CSSProperties {
    [key: `--${string}`]: string
  }
}
<div style={ { '--bg-color': 'blue' } }>
<div :style="{ '--bg-color': 'blue' }">t
htSee also
SFC <style> tags support linking CSS values to dynamic component state using the v-
bind CSS function. This allows for custom properties without type augmentation.ⓘ
v-bind() in CSSCreates a custom renderer. By providing platform-specific node creation and manipulation
APIs, you can leverage Vue's core runtime to target non-DOM environments.Custom Renderer API
createRenderer()
Typefunction createRenderer<HostNode, HostElement>(
  options: RendererOptions<HostNode, HostElement>
): Renderer<HostElement>
interface Renderer<HostElement> {
  render: RootRenderFunction<HostElement>
  createApp: CreateAppFunction<HostElement>
}
interface RendererOptions<HostNode, HostElement> {
  patchProp(
    el: HostElement,
    key: string,
    prevValue: any,
    nextValue: any,
    // the rest is unused for most custom renderers
    isSVG?: boolean,
    prevChildren?: VNode<HostNode, HostElement>[],
    parentComponent?: ComponentInternalInstance | null,
    parentSuspense?: SuspenseBoundary | null,
    unmountChildren?: UnmountChildrenFn
  ): void
  insert(
    el: HostNode,
    parent: HostElement,
    anchor?: HostNode | null
  ): void
  remove(el: HostNode): void
  createElement(
    type: string,
    isSVG?: boolean,
    isCustomizedBuiltIn?: string,
    vnodeProps?: (VNodeProps & { [key: string]: any }) | null
  ): HostElement
  createText(text: string): HostNode
  createComment(text: string): HostNode
  setText(node: HostNode, text: string): void
  setElementText(node: HostElement, text: string): void
  parentNode(node: HostNode): HostElement | null
  nextSibling(node: HostNode): HostNode | null
  // optional, DOM-specific
  querySelector?(selector: string): HostElement | null
  setScopeId?(el: HostElement, id: string): void
  cloneNode?(node: HostNode): HostNode
  insertStaticContent?(
    content: string,Example
Vue's own @vue/runtime-dom is implemented using the same API. For a simpler
implementation, check out @vue/runtime-test which is a private package for Vue's
own unit testing.    parent: HostElement,
    anchor: HostNode | null,
    isSVG: boolean
  ): [HostNode, HostNode]
}
import { createRenderer } from '@vue/runtime-core'
const { render, createApp } = createRenderer({
  patchProp,
  insert,
  remove,
  createElement
  // ...
})
// `render` is the low-level API
// `createApp` returns an app instance
export { render, createApp }
// re-export Vue core APIs
export * from '@vue/runtime-core'